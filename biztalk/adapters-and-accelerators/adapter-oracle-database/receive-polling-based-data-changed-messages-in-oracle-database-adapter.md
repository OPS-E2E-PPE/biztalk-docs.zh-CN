---
title: "Oracle 数据库适配器中接收基于轮询的数据更改消息 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: polling-base notification, support for
ms.assetid: 043afb88-701c-41d8-8b8e-84702bd0d984
caps.latest.revision: "16"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 2f234e57353d22c785dc57271add297e7a6d2c9f
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="receive-polling-based-data-changed-messages-in-oracle-database-adapter"></a><span data-ttu-id="c12ef-102">Oracle 数据库适配器中接收基于轮询的数据更改消息</span><span class="sxs-lookup"><span data-stu-id="c12ef-102">Receive polling-based data-changed messages in Oracle Database adapter</span></span>
<span data-ttu-id="c12ef-103">[!INCLUDE[adapteroracle](../../includes/adapteroracle-md.md)]支持通过轮询 Oracle 数据库接收基于轮询的数据更改消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-103">The [!INCLUDE[adapteroracle](../../includes/adapteroracle-md.md)] supports receiving polling-based data-changed messages by polling the Oracle database.</span></span> <span data-ttu-id="c12ef-104">适配器将消息传送到您的应用程序：</span><span class="sxs-lookup"><span data-stu-id="c12ef-104">The adapter delivers the messages to your application by:</span></span>  
  
-   <span data-ttu-id="c12ef-105">执行 SQL SELECT 查询以确定数据是否可用于轮询。</span><span class="sxs-lookup"><span data-stu-id="c12ef-105">Executing a SQL SELECT query to determine whether data is available for polling.</span></span> <span data-ttu-id="c12ef-106">你可以配置执行 SQL SELECT 查询定期或连续的适配器。</span><span class="sxs-lookup"><span data-stu-id="c12ef-106">You can configure the adapter to execute the SQL SELECT query periodically or continuously.</span></span>  
  
-   <span data-ttu-id="c12ef-107">执行 SQL SELECT 查询针对 Oracle 表或视图或执行存储过程、 函数或打包的过程和函数。</span><span class="sxs-lookup"><span data-stu-id="c12ef-107">Executing a SQL SELECT query against an Oracle table or view or executing stored procedures, functions, or packaged procedures and functions.</span></span>  
  
-   <span data-ttu-id="c12ef-108">执行对 Oracle 数据库的一个可选的后轮询 PL/SQL 代码块。</span><span class="sxs-lookup"><span data-stu-id="c12ef-108">Executing an optional post-poll PL/SQL code block on the Oracle database.</span></span> <span data-ttu-id="c12ef-109">若要更新目标中的查询记录上的字段或将查询的记录移到另一个表或视图，通常使用此代码块。</span><span class="sxs-lookup"><span data-stu-id="c12ef-109">This code block is often used to update a field on the queried records in the target or to move the queried records to another table or view.</span></span>  
  
-   <span data-ttu-id="c12ef-110">在结果中返回查询结果设置通过调用 POLLINGSTMT 操作或存储的过程、 函数或打包的过程和函数作为轮询操作公开。</span><span class="sxs-lookup"><span data-stu-id="c12ef-110">Returning the query results in a result set by invoking the POLLINGSTMT operation or the stored procedures, functions, or packaged procedures and functions that are exposed as polling operations.</span></span>  
  
 <span data-ttu-id="c12ef-111">适配器执行所有这些操作 Oracle 事务内。</span><span class="sxs-lookup"><span data-stu-id="c12ef-111">The adapter executes all of these operations inside of an Oracle transaction.</span></span>  
  
 <span data-ttu-id="c12ef-112">适配器还可以通过公开在同一应用程序接收多个 Oracle 的项目的数据更改消息`PollingId`连接 URI 中的参数。</span><span class="sxs-lookup"><span data-stu-id="c12ef-112">The adapter also enables you to receive data-changes messages for multiple Oracle artifacts in the same application by exposing a `PollingId` parameter in the connection URI.</span></span> <span data-ttu-id="c12ef-113">此参数修改 POLLINGSTMT 操作的目标命名空间。</span><span class="sxs-lookup"><span data-stu-id="c12ef-113">This parameter modifies the target namespace of the POLLINGSTMT operation.</span></span>  
  
## <a name="change-the-target-namespace-of-pollingstmt"></a><span data-ttu-id="c12ef-114">更改 POLLINGSTMT 的目标命名空间</span><span class="sxs-lookup"><span data-stu-id="c12ef-114">Change the target namespace of POLLINGSTMT</span></span>  
 <span data-ttu-id="c12ef-115">你可以通过设置修改 POLLINGSTMT 操作的目标命名空间`PollingId`查询中连接 URI 的字符串参数。</span><span class="sxs-lookup"><span data-stu-id="c12ef-115">You can modify the target namespace of the POLLINGSTMT operation by setting the `PollingId` query string parameter in the connection URI.</span></span> <span data-ttu-id="c12ef-116">如果`PollingId`中连接 URI，指定[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]追加中指定的字符串`PollingId`POLLINGSTMT 操作的默认目标命名空间的参数： `http://microsoft.lobservices.oracledb/2007/03/POLLINGSTMT`。</span><span class="sxs-lookup"><span data-stu-id="c12ef-116">If a `PollingId` is specified in the connection URI, the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] appends the string specified in the `PollingId` parameter to the default target namespace for the POLLINGSTMT operation: `http://microsoft.lobservices.oracledb/2007/03/POLLINGSTMT`.</span></span> <span data-ttu-id="c12ef-117">不修改 POLLINGSTMT 操作的消息操作。</span><span class="sxs-lookup"><span data-stu-id="c12ef-117">The message action of the POLLINGSTMT operation is not modified.</span></span>  
  
 <span data-ttu-id="c12ef-118">例如，如果指定以下连接 URI: `OracleDb://User=SCOTT;Password=TIGER@Adapter?PollingId=AcctActivity`，目标命名空间将是`http:/microsoft.lobservices.oracledb/2007/03/POLLINGSTMTAcctActivity`。</span><span class="sxs-lookup"><span data-stu-id="c12ef-118">For example, if the following connection URI is specified: `OracleDb://User=SCOTT;Password=TIGER@Adapter?PollingId=AcctActivity`, the target namespace will be `http:/microsoft.lobservices.oracledb/2007/03/POLLINGSTMTAcctActivity`.</span></span>  
  
 <span data-ttu-id="c12ef-119">通过为每个 POLLINGSTMT 操作提供唯一的命名空间，你可以在你的应用程序中接收数据更改多个 Oracle 表和视图的消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-119">By providing a unique namespace for each POLLINGSTMT operation, you can receive data-changed messages for multiple Oracle tables and views in your application.</span></span>  
  
 <span data-ttu-id="c12ef-120">有关详细信息[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]连接 URI，请参阅[创建 Oracle 数据库连接 URI](../../adapters-and-accelerators/adapter-oracle-database/create-the-oracle-database-connection-uri.md)。</span><span class="sxs-lookup"><span data-stu-id="c12ef-120">For more information about the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] connection URI, see [Create the Oracle Database connection URI](../../adapters-and-accelerators/adapter-oracle-database/create-the-oracle-database-connection-uri.md).</span></span>  
  
## <a name="receive-data-changed-messages-using-binding-properties"></a><span data-ttu-id="c12ef-121">接收数据更改的消息，使用绑定属性</span><span class="sxs-lookup"><span data-stu-id="c12ef-121">Receive data-changed messages using binding properties</span></span>
 <span data-ttu-id="c12ef-122">你配置[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]以通过设置部分或全部以下绑定属性来接收数据更改消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-122">You configure the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] to receive data-changed messages by setting some or all of the following binding properties.</span></span>  
  
|<span data-ttu-id="c12ef-123">绑定属性</span><span class="sxs-lookup"><span data-stu-id="c12ef-123">Binding Property</span></span>|<span data-ttu-id="c12ef-124">值</span><span class="sxs-lookup"><span data-stu-id="c12ef-124">Value</span></span>|<span data-ttu-id="c12ef-125">默认</span><span class="sxs-lookup"><span data-stu-id="c12ef-125">Default</span></span>|<span data-ttu-id="c12ef-126">必需/可选</span><span class="sxs-lookup"><span data-stu-id="c12ef-126">Required/Optional</span></span>|  
|----------------------|-----------|-------------|------------------------|  
|<span data-ttu-id="c12ef-127">**InboundOperationType**</span><span class="sxs-lookup"><span data-stu-id="c12ef-127">**InboundOperationType**</span></span>|<span data-ttu-id="c12ef-128">请确保值设置为**轮询**。</span><span class="sxs-lookup"><span data-stu-id="c12ef-128">Make sure that the value is set to **Polling**.</span></span>|<span data-ttu-id="c12ef-129">轮询</span><span class="sxs-lookup"><span data-stu-id="c12ef-129">Polling</span></span>|<span data-ttu-id="c12ef-130">必需的。</span><span class="sxs-lookup"><span data-stu-id="c12ef-130">Required.</span></span> <span data-ttu-id="c12ef-131">如果未显式设置，默认值将应用。</span><span class="sxs-lookup"><span data-stu-id="c12ef-131">If not explicitly set, the default value will apply.</span></span>|  
|<span data-ttu-id="c12ef-132">**PolledDataAvailableStatement**</span><span class="sxs-lookup"><span data-stu-id="c12ef-132">**PolledDataAvailableStatement**</span></span>|<span data-ttu-id="c12ef-133">指定执行，以确定任何数据是否可用于轮询的特定表的 SELECT 语句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-133">Specify the SELECT statement executed to determine whether any data is available for polling for a specific table.</span></span> <span data-ttu-id="c12ef-134">指定的语句必须返回的结果集行和列组成。</span><span class="sxs-lookup"><span data-stu-id="c12ef-134">The specified statement must return a result set consisting of rows and columns.</span></span> <span data-ttu-id="c12ef-135">结果集的第一个单元中的值指示适配器是否执行指定的值**PollingStatement**绑定属性。</span><span class="sxs-lookup"><span data-stu-id="c12ef-135">The value in the first cell of the result set indicates whether the adapter executes the value specified for the **PollingStatement** binding property.</span></span> <span data-ttu-id="c12ef-136">如果结果的第一个单元包含一个正值，适配器执行的轮询语句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-136">If the first cell of the result contains a positive value, the adapter executes the polling statement.</span></span> <span data-ttu-id="c12ef-137">例如，将为此绑定属性有效的语句：</span><span class="sxs-lookup"><span data-stu-id="c12ef-137">For example, a valid statement for this binding property will be:</span></span><br /><br /> `Select * from <table_name>`<br /><br /> <span data-ttu-id="c12ef-138">**注意：**您不能指定此绑定属性的存储的过程。</span><span class="sxs-lookup"><span data-stu-id="c12ef-138">**Note:** You must not specify stored procedures for this binding property.</span></span> <span data-ttu-id="c12ef-139">此外，此语句不能修改基础的 Oracle 数据库。</span><span class="sxs-lookup"><span data-stu-id="c12ef-139">Also, this statement must not modify the underlying Oracle database.</span></span>|<span data-ttu-id="c12ef-140">从双选择 1</span><span class="sxs-lookup"><span data-stu-id="c12ef-140">SELECT 1 FROM DUAL</span></span>|<span data-ttu-id="c12ef-141">必需的。</span><span class="sxs-lookup"><span data-stu-id="c12ef-141">Required.</span></span> <span data-ttu-id="c12ef-142">如果未显式设置，默认值将应用，这意味着，适配器必须继续进行而不考虑或不轮询表是否具有数据的轮询。</span><span class="sxs-lookup"><span data-stu-id="c12ef-142">If not explicitly set, the default value will apply, which implies that the adapter must continue polling irrespective of whether the table being polled has data or not.</span></span>|  
|<span data-ttu-id="c12ef-143">**PollingAction**</span><span class="sxs-lookup"><span data-stu-id="c12ef-143">**PollingAction**</span></span>|<span data-ttu-id="c12ef-144">指定轮询操作的操作。</span><span class="sxs-lookup"><span data-stu-id="c12ef-144">Specifies the action for the polling operation.</span></span> <span data-ttu-id="c12ef-145">你可以确定从元数据生成操作使用特定操作的轮询操作[!INCLUDE[consumeadapterservshort](../../includes/consumeadapterservshort-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c12ef-145">You can determine the polling action for a specific operation from the metadata you generate for the operation using the [!INCLUDE[consumeadapterservshort](../../includes/consumeadapterservshort-md.md)].</span></span>|<span data-ttu-id="c12ef-146">null</span><span class="sxs-lookup"><span data-stu-id="c12ef-146">null</span></span>|<span data-ttu-id="c12ef-147">对于上表和视图使用 SELECT 语句的轮询操作可选。</span><span class="sxs-lookup"><span data-stu-id="c12ef-147">Optional for polling operations on tables and views using the SELECT statement.</span></span>|  
|<span data-ttu-id="c12ef-148">**PollingInterval**</span><span class="sxs-lookup"><span data-stu-id="c12ef-148">**PollingInterval**</span></span>|<span data-ttu-id="c12ef-149">设置为间隔，以秒为单位，您想要在 Oracle 数据库中查询的适配器。</span><span class="sxs-lookup"><span data-stu-id="c12ef-149">Set to the interval, in seconds, at which you want the adapter to query the Oracle database.</span></span> <span data-ttu-id="c12ef-150">此属性指定轮询间隔和轮询事务超时。值应大于执行的查询和后轮询语句 （如果指定了一个） 对 Oracle 数据库所花的时间量加上的客户端来处理查询数据并返回轮询响应消息所花费的时间量。</span><span class="sxs-lookup"><span data-stu-id="c12ef-150">This property specifies the polling interval and the polling transaction time out. The value should be greater than the amount of time it takes to execute the query and post-poll statement (if one is specified) on the Oracle database plus the amount of time it takes for the client to process the query data and return the polling response message.</span></span>|<span data-ttu-id="c12ef-151">500</span><span class="sxs-lookup"><span data-stu-id="c12ef-151">500</span></span>|<span data-ttu-id="c12ef-152">必需的。</span><span class="sxs-lookup"><span data-stu-id="c12ef-152">Required.</span></span> <span data-ttu-id="c12ef-153">如果未显式设置，默认值将应用。</span><span class="sxs-lookup"><span data-stu-id="c12ef-153">If not explicitly set, the default value will apply.</span></span>|  
|<span data-ttu-id="c12ef-154">**PollingStatement**</span><span class="sxs-lookup"><span data-stu-id="c12ef-154">**PollingStatement**</span></span>|<span data-ttu-id="c12ef-155">指定以下方法之一：</span><span class="sxs-lookup"><span data-stu-id="c12ef-155">Specify either of the following:</span></span><br /><br /> <span data-ttu-id="c12ef-156">应对其执行 Oracle 数据库的 SQL SELECT 语句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-156">- SQL SELECT statement that should be executed against the Oracle database.</span></span> <span data-ttu-id="c12ef-157">此语句应包含 FOR UPDATE 子句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-157">This statement should include a FOR UPDATE clause.</span></span> <span data-ttu-id="c12ef-158">有关 FOR UPDATE 子句的信息，请参阅[的轮询语句中指定 FOR UPDATE 子句](#ForUpdate)本主题中更高版本。</span><span class="sxs-lookup"><span data-stu-id="c12ef-158">For information about the FOR UPDATE clause, see [Specifying a FOR UPDATE Clause in the Polling Statement](#ForUpdate) later in this topic.</span></span><br /><br /> <span data-ttu-id="c12ef-159">-请求的存储的过程、 函数或过程或函数在你想要进行轮询一个包内的消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-159">- Request message for a stored procedure, function, or procedure or function within a package that you want to be polled.</span></span>|<span data-ttu-id="c12ef-160">null</span><span class="sxs-lookup"><span data-stu-id="c12ef-160">null</span></span>|<span data-ttu-id="c12ef-161">必需的。</span><span class="sxs-lookup"><span data-stu-id="c12ef-161">Required.</span></span> <span data-ttu-id="c12ef-162">设置**PollingStatement**为非 null 值可启用轮询。</span><span class="sxs-lookup"><span data-stu-id="c12ef-162">Setting **PollingStatement** to a non-null value enables polling.</span></span>|  
|<span data-ttu-id="c12ef-163">**PollWhileDataFound**</span><span class="sxs-lookup"><span data-stu-id="c12ef-163">**PollWhileDataFound**</span></span>|<span data-ttu-id="c12ef-164">指定是否[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]忽略轮询间隔和持续轮询 Oracle 数据库时，如果数据中轮询的表。</span><span class="sxs-lookup"><span data-stu-id="c12ef-164">Specifies whether the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] ignores the polling interval and continuously polls the Oracle database, if data is available in the table being polled.</span></span> <span data-ttu-id="c12ef-165">如果表中可用的任何数据不，该适配器将恢复执行 SQL 语句按照指定的轮询间隔</span><span class="sxs-lookup"><span data-stu-id="c12ef-165">If no data is available in the table, the adapter reverts to execute the SQL statement at the specified polling interval</span></span>|<span data-ttu-id="c12ef-166">False</span><span class="sxs-lookup"><span data-stu-id="c12ef-166">False</span></span>|<span data-ttu-id="c12ef-167">必需的。</span><span class="sxs-lookup"><span data-stu-id="c12ef-167">Required.</span></span> <span data-ttu-id="c12ef-168">如果未显式设置，默认值将应用。</span><span class="sxs-lookup"><span data-stu-id="c12ef-168">If not explicitly set, the default value will apply.</span></span>|  
|<span data-ttu-id="c12ef-169">**PostPollStatement**</span><span class="sxs-lookup"><span data-stu-id="c12ef-169">**PostPollStatement**</span></span>|<span data-ttu-id="c12ef-170">设置为一个可选的 PL/SQL 代码块后，执行查询，但在查询之前数据返回到客户端执行适配器。</span><span class="sxs-lookup"><span data-stu-id="c12ef-170">Set to an optional PL/SQL code block that is executed by the adapter after the query is performed, but before the query data is returned to the client.</span></span>|<span data-ttu-id="c12ef-171">null</span><span class="sxs-lookup"><span data-stu-id="c12ef-171">null</span></span>|<span data-ttu-id="c12ef-172">可选。</span><span class="sxs-lookup"><span data-stu-id="c12ef-172">Optional.</span></span> <span data-ttu-id="c12ef-173">如果未不指定任何值，则不执行 post 轮询语句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-173">If no value is specified, a post poll statement is not executed.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="c12ef-174">如果你使用的 WCF 服务模型或 WCF 通道模型，你还必须设置**AcceptCredentialsInUri**绑定属性。</span><span class="sxs-lookup"><span data-stu-id="c12ef-174">If you are using the WCF service model or the WCF channel model, you must also set the **AcceptCredentialsInUri** binding property.</span></span>  
  
##  <span data-ttu-id="c12ef-175"><a name="ForUpdate"></a>在轮询语句中输入的更新</span><span class="sxs-lookup"><span data-stu-id="c12ef-175"><a name="ForUpdate"></a> Enter a FOR UPDATE in the polling statement</span></span>  
 <span data-ttu-id="c12ef-176">如果使用的作为轮询语句和执行影响在 SELECT 语句中指定的行后轮询语句的 SELECT 语句，你必须在轮询语句中使用 FOR UPDATE 子句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-176">If you are using a SELECT statement as the polling statement and executing a post-poll statement that affects the rows specified in the SELECT statement, you must use the FOR UPDATE clause in the polling statement.</span></span> <span data-ttu-id="c12ef-177">指定 FOR UPDATE 子句可确保通过轮询语句所选择的记录将被锁定在事务处理期间并后轮询语句可以对它们执行任何所需的更新。</span><span class="sxs-lookup"><span data-stu-id="c12ef-177">Specifying a FOR UPDATE clause ensures that the records selected by the polling statement are locked during the transaction and that the post-poll statement can perform any required updates on them.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c12ef-178">你可以方案其中在轮询和后轮询语句之间的时间范围，更多记录添加到满足后轮询语句的条件的表中。</span><span class="sxs-lookup"><span data-stu-id="c12ef-178">You can have scenarios where in the time window between the polling and post-poll statements, more records are added to the table that meet the condition of the post-poll statement.</span></span> <span data-ttu-id="c12ef-179">在这种情况下，满足条件的所有记录，以及不只是选择作为轮询语句的一部分的记录，将更新后的轮询语句。</span><span class="sxs-lookup"><span data-stu-id="c12ef-179">In such situations, the post-poll statement would update all the records that satisfy the condition and not just the records selected as part of the polling statement.</span></span>  
  
 <span data-ttu-id="c12ef-180">如果未指定后期轮询语句和轮询语句不包含 FOR UPDATE 子句，则会出现以下两种情况之一：</span><span class="sxs-lookup"><span data-stu-id="c12ef-180">If a post-poll statement is specified and the polling statement does not contain a FOR UPDATE clause, you will experience one of the following two conditions:</span></span>  
  
-   <span data-ttu-id="c12ef-181">如果**TransactionIsolationLevel**设置为**ReadCommitted**后, 轮询查询不会更新所选的行。</span><span class="sxs-lookup"><span data-stu-id="c12ef-181">If **TransactionIsolationLevel** is set to **ReadCommitted**, the post-poll query will not update the selected rows.</span></span>  
  
-   <span data-ttu-id="c12ef-182">如果**TransactionIsolationLevel**设置为**Serializable**，以下面向系统异常 (**Microsoft.ServiceModel.Channels.Common.TargetSystemException**) 执行后轮询语句时将发生:"ORA 08177 无法序列化此事务的访问"。</span><span class="sxs-lookup"><span data-stu-id="c12ef-182">If **TransactionIsolationLevel** is set to **Serializable**, the following target system exception (**Microsoft.ServiceModel.Channels.Common.TargetSystemException**) will occur when the post-poll statement is executed: "ORA-08177 can't serialize access for this transaction".</span></span> <span data-ttu-id="c12ef-183">在这种情况下，你必须设置**PollingRetryCount**绑定属性，用于定义所需的适配器重试相同的事务的次数。</span><span class="sxs-lookup"><span data-stu-id="c12ef-183">In such a case, you must set the **PollingRetryCount** binding property to define the number of times you want the adapter to retry the same transaction.</span></span>  
  
 <span data-ttu-id="c12ef-184">有关如何设置事务的隔离级别的说明，请参阅[与 Oracle 数据库配置事务隔离级别和事务超时](../../adapters-and-accelerators/adapter-oracle-database/configure-transaction-isolation-level-and-transaction-timeout-with-oracle-db.md)。</span><span class="sxs-lookup"><span data-stu-id="c12ef-184">For instructions on how to set the transaction isolation level, see [Configure transaction isolation level and transaction timeout with Oracle Database](../../adapters-and-accelerators/adapter-oracle-database/configure-transaction-isolation-level-and-transaction-timeout-with-oracle-db.md).</span></span>  
  
 <span data-ttu-id="c12ef-185">如果适配器客户端已配置为使用事务和的值，则在事务中执行的轮询和后轮询语句**UseAmbientTransaction**绑定属性设置为**True**适配器中。</span><span class="sxs-lookup"><span data-stu-id="c12ef-185">The polling and post-poll statements are executed in a transaction if the adapter clients have configured to use transactions and the value of the **UseAmbientTransaction** binding property is set to **True** in the adapter.</span></span>  
  
 <span data-ttu-id="c12ef-186">具有 FOR UPDATE 选项的轮询查询的一个示例是：</span><span class="sxs-lookup"><span data-stu-id="c12ef-186">An example of a polling query with the FOR UPDATE option is:</span></span>  
  
```  
SELECT * from EMP WHERE FLAG = 'Y' FOR UPDATE  
```  
  
### <a name="enter-a-nowait-clause-in-the-polling-statement"></a><span data-ttu-id="c12ef-187">在轮询语句中输入的 NOWAIT 子句</span><span class="sxs-lookup"><span data-stu-id="c12ef-187">Enter a NOWAIT clause in the polling statement</span></span>  
 <span data-ttu-id="c12ef-188">您可能必须的方案，并发线程访问表轮询，从而导致过多表中的争用。</span><span class="sxs-lookup"><span data-stu-id="c12ef-188">You may have scenarios where concurrent threads are accessing the table being polled, leading to too many contentions in the table.</span></span> <span data-ttu-id="c12ef-189">这可能导致轮询查询才会被阻止，以在表行获取锁。</span><span class="sxs-lookup"><span data-stu-id="c12ef-189">This may cause the polling query to be blocked to get a lock on table rows.</span></span> <span data-ttu-id="c12ef-190">如果使用的作为轮询语句的 SELECT 语句，你可能想要在 SELECT 语句中指定 FOR UPDATE 关键字以及 NOWAIT 关键字。</span><span class="sxs-lookup"><span data-stu-id="c12ef-190">If you are using a SELECT statement as the polling statement, you may want to specify a NOWAIT keyword along with the FOR UPDATE keyword in the SELECT statement.</span></span> <span data-ttu-id="c12ef-191">这将导致轮询查询执行中的适配器上的轮询查询尝试选择行是否存在锁立即返回。</span><span class="sxs-lookup"><span data-stu-id="c12ef-191">This will cause the polling query execution within the adapter to return immediately if there are locks on rows which the polling query is trying to select.</span></span> <span data-ttu-id="c12ef-192">异常通常在这种情况下引发由 Oracle。</span><span class="sxs-lookup"><span data-stu-id="c12ef-192">An exception is usually thrown by Oracle under such conditions.</span></span> <span data-ttu-id="c12ef-193">若要再次使用适配器客户端可能**PollingInterval**绑定属性指定为轮询数据的时间间隔之后适配器客户端必须重试。</span><span class="sxs-lookup"><span data-stu-id="c12ef-193">Again, adapter clients may use the **PollingInterval** binding property to specify the time interval after which the adapter clients must retry for polling the data.</span></span>  
  
 <span data-ttu-id="c12ef-194">具有 NOWAIT 选项的轮询查询的一个示例是：</span><span class="sxs-lookup"><span data-stu-id="c12ef-194">An example of a polling query with the NOWAIT option is:</span></span>  
  
```  
SELECT * from EMP WHERE FLAG = 'Y' FOR UPDATE NOWAIT  
```  
  
### <a name="enter-a-skip-locked-clause-in-the-polling-statement"></a><span data-ttu-id="c12ef-195">在轮询语句中输入的跳过锁定子句</span><span class="sxs-lookup"><span data-stu-id="c12ef-195">Enter a SKIP LOCKED clause in the polling statement</span></span>  
 <span data-ttu-id="c12ef-196">您可能必须并发线程访问轮询的表，由于锁定中轮询查询中指定的 WHERE 子句的结果集的某些行是其中方案。</span><span class="sxs-lookup"><span data-stu-id="c12ef-196">You may have scenarios where due to concurrent threads accessing the table being polled, some rows in the result set of the WHERE clause specified in the polling query are locked.</span></span> <span data-ttu-id="c12ef-197">例如，轮询查询从表; 返回 6 行方式由于某些其他事务已锁定 4 超出这些 6 行。</span><span class="sxs-lookup"><span data-stu-id="c12ef-197">For example, your polling query returns 6 rows from a table; 4 out of these 6 rows are already locked because of some other transaction.</span></span> <span data-ttu-id="c12ef-198">在这种情况下，你可能想要指定 FOR UPDATE 关键字，指示要尝试锁定由 WHERE 子句中，指定的行，并跳过找到已锁定所有行的数据库以及一个跳都过锁定关键字。</span><span class="sxs-lookup"><span data-stu-id="c12ef-198">In this case, you might want to specify a SKIP LOCKED keyword along with the FOR UPDATE keyword that instructs the database to attempt to lock the rows specified by the WHERE clause, and to skip any rows that are found to be already locked.</span></span> <span data-ttu-id="c12ef-199">WHERE 子句中未锁定的行被锁定在事务处理期间，并后轮询语句可以任何所需的更新在执行，以便不会再次轮询这些行。</span><span class="sxs-lookup"><span data-stu-id="c12ef-199">The unlocked rows in the WHERE clause are locked during the transaction and the post-poll statement can perform any required updates on them so that these rows are not polled again.</span></span> <span data-ttu-id="c12ef-200">这可确保你无需等待以接收的轮询消息，直到所有行都指定由 WHERE 子句均已解除锁定。</span><span class="sxs-lookup"><span data-stu-id="c12ef-200">This ensures that you do not have to wait to receive the polling messages until all the rows specified by the WHERE clause are unlocked.</span></span>  
  
 <span data-ttu-id="c12ef-201">跳过锁定关键字可在方案中必须用轮询数据库中的相同表的多台计算机适配器客户端。</span><span class="sxs-lookup"><span data-stu-id="c12ef-201">The SKIP LOCKED keyword is useful in a scenario where you have adapter clients on multiple computers that are polling the same table in a database.</span></span> <span data-ttu-id="c12ef-202">你可以通过配置接收在该点的时间，未锁定的行由 WHERE 子句指定的基于轮询的数据更改消息的方式轮询操作负载适配器客户端之间的平衡，然后更新的行，以确保如果适配器客户端收到基于轮询的数据更改消息时，其他客户端未得到，同一消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-202">You can load balance among the adapter clients by configuring the polling operation in such a way that you receive polling-based data-change messages for the rows specified by the WHERE clause that are unlocked at that point of time, and then update the row to ensure that if a polling-based data-change message is received by an adapter client, the other clients do not get the same message.</span></span>  
  
 <span data-ttu-id="c12ef-203">轮询查询使用跳过锁定选项的一个示例是：</span><span class="sxs-lookup"><span data-stu-id="c12ef-203">An example of a polling query with the SKIP LOCKED option is:</span></span>  
  
```  
SELECT * from EMP WHERE FLAG = 'Y' FOR UPDATE SKIP LOCKED  
```  
  
## <a name="support-for-ordered-delivery-fifo"></a><span data-ttu-id="c12ef-204">对有序传递 (FIFO) 的支持</span><span class="sxs-lookup"><span data-stu-id="c12ef-204">Support for ordered delivery (FIFO)</span></span>  
 <span data-ttu-id="c12ef-205">在生产环境中，轮询可以用于监视 Oracle 数据库中的数据更改。</span><span class="sxs-lookup"><span data-stu-id="c12ef-205">In a production environment, polling can be used to monitor the data changes in the Oracle database.</span></span> <span data-ttu-id="c12ef-206">这些数据更改的消息接收适配器客户端使用[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c12ef-206">These data-changed messages are received by the adapter client using the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)].</span></span> <span data-ttu-id="c12ef-207">根据业务方案，它可能非常重要，正确的顺序中的适配器客户端接收的数据更改的消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-207">Based on business scenarios, it can be critical that the data-changed messages are received by the adapter client in the right order.</span></span>  
  
 <span data-ttu-id="c12ef-208">[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]支持有序传递或后进先出 (FIFO) 以维护从 Oracle 数据库接收消息的顺序。</span><span class="sxs-lookup"><span data-stu-id="c12ef-208">The [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] supports ordered delivery or first-in-first-out (FIFO) to maintain the order in which messages are received from the Oracle database.</span></span> <span data-ttu-id="c12ef-209">以下是相关支持在入站方案中的先进先出的几个注意事项[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="c12ef-209">Here are a few considerations related to support for FIFO in inbound scenarios for the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)].</span></span>  
  
-   <span data-ttu-id="c12ef-210">如果消息所使用的业务流程，业务流程必须设置为来自的消息有序的传递[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]接收端口。</span><span class="sxs-lookup"><span data-stu-id="c12ef-210">If the message is being consumed by an orchestration, the orchestration must have the ordered delivery set for the messages coming from the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] receive port.</span></span>  
  
-   <span data-ttu-id="c12ef-211">如果消息所使用的发送端口 （在基于内容的路由） 方案，必须订购发送端口传递来自的消息设置[!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)]接收端口。</span><span class="sxs-lookup"><span data-stu-id="c12ef-211">If the message is being consumed by a send port (in a content-based routing) scenario, the send port must have ordered delivery set for the messages coming from the [!INCLUDE[adapteroracle_short](../../includes/adapteroracle-short-md.md)] receive port.</span></span>  
  
 <span data-ttu-id="c12ef-212">WCF 自定义或 WCF OracleDB 适配器有一个属性**失败的挂起请求消息**，它指定是否挂起失败入站的处理的请求消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-212">The WCF-Custom or WCF-OracleDB adapter has a property **Suspend request message on failure** that specifies whether to suspend the request message that fails inbound processing.</span></span> <span data-ttu-id="c12ef-213">可以设置此属性上**消息**WCF 自定义或 WCF OracleDB 选项卡上接收端口下的**错误处理**部分。</span><span class="sxs-lookup"><span data-stu-id="c12ef-213">This property can be set on the **Messages** tab of the WCF-Custom or WCF-OracleDB receive port under the **Error handling** section.</span></span> <span data-ttu-id="c12ef-214">下表列出了描述如何处理传入消息的方案基于是否设置此属性和消息订阅服务器 （业务流程或端口） 的状态。</span><span class="sxs-lookup"><span data-stu-id="c12ef-214">The following table lists the scenarios describing how the incoming messages are processed based on whether this property is set and the state of the message subscriber (orchestration or port).</span></span>  
  
|<span data-ttu-id="c12ef-215">Port 属性</span><span class="sxs-lookup"><span data-stu-id="c12ef-215">Port property</span></span>|<span data-ttu-id="c12ef-216">订阅服务器中取消登记的状态</span><span class="sxs-lookup"><span data-stu-id="c12ef-216">Subscriber in Unenlisted state</span></span>|<span data-ttu-id="c12ef-217">登记的过程中但已停止状态的订阅服务器</span><span class="sxs-lookup"><span data-stu-id="c12ef-217">Subscriber in Enlisted but Stopped state</span></span>|  
|-------------------|------------------------------------|----------------------------------------------|  
|<span data-ttu-id="c12ef-218">**挂起失败的请求消息**未设置属性</span><span class="sxs-lookup"><span data-stu-id="c12ef-218">**Suspend request message on failure** property NOT set</span></span>|<span data-ttu-id="c12ef-219">-路由故障报告生成为挂起的 （非挂起消息）</span><span class="sxs-lookup"><span data-stu-id="c12ef-219">- Routing Failure Report is generated as a suspended (non-resumable message)</span></span><br /><br /> <span data-ttu-id="c12ef-220">-实际的消息则不会挂起</span><span class="sxs-lookup"><span data-stu-id="c12ef-220">- Actual message is not suspended</span></span><br /><br /> <span data-ttu-id="c12ef-221">-Post，如获取中止事务时不执行轮询查询。</span><span class="sxs-lookup"><span data-stu-id="c12ef-221">- Post poll query is not executed as transaction gets aborted.</span></span> <span data-ttu-id="c12ef-222">因此轮询重复并且再次提取行。</span><span class="sxs-lookup"><span data-stu-id="c12ef-222">Hence polling repeats and fetches the rows again.</span></span><br /><br /> <span data-ttu-id="c12ef-223">-在事件日志，以说明发生中报告的错误。</span><span class="sxs-lookup"><span data-stu-id="c12ef-223">- Errors reported in the event log to describe what has happened.</span></span>|<span data-ttu-id="c12ef-224">-不被视为"失败"。</span><span class="sxs-lookup"><span data-stu-id="c12ef-224">- Not considered a “Failure”.</span></span> <span data-ttu-id="c12ef-225">事件日志中有任何错误消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-225">There are no error messages in the event log.</span></span><br /><br /> <span data-ttu-id="c12ef-226">-实际消息放入挂起 （恢复） 队列中。</span><span class="sxs-lookup"><span data-stu-id="c12ef-226">- Actual message is put into the suspended (resumable) queue.</span></span><br /><br /> <span data-ttu-id="c12ef-227">-订阅的端口或业务流程启动时，还可以自动恢复消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-227">- When the subscribing port or orchestration starts, the messages are automatically resumed.</span></span> <span data-ttu-id="c12ef-228">如果在订阅服务器上设置有序的传递，则它将遵循此模式。</span><span class="sxs-lookup"><span data-stu-id="c12ef-228">If ordered delivery is set on the subscriber, it will be honored.</span></span><br /><br /> <span data-ttu-id="c12ef-229">的此外可能手动恢复消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-229">- The messages may also be resumed manually.</span></span>|  
|<span data-ttu-id="c12ef-230">**挂起失败的请求消息**属性设置</span><span class="sxs-lookup"><span data-stu-id="c12ef-230">**Suspend request message on failure** property IS set</span></span>|<span data-ttu-id="c12ef-231">-路由故障报告生成为挂起的 （非挂起消息）</span><span class="sxs-lookup"><span data-stu-id="c12ef-231">- Routing Failure Report is generated as a suspended (non-resumable message)</span></span><br /><br /> <span data-ttu-id="c12ef-232">-实际消息也会被暂停</span><span class="sxs-lookup"><span data-stu-id="c12ef-232">- Actual message is also suspended</span></span><br /><br /> <span data-ttu-id="c12ef-233">-Post，如获取中止事务时不执行轮询查询。</span><span class="sxs-lookup"><span data-stu-id="c12ef-233">- Post poll query is not executed as transaction gets aborted.</span></span> <span data-ttu-id="c12ef-234">因此轮询重复并且再次提取行。</span><span class="sxs-lookup"><span data-stu-id="c12ef-234">Hence polling repeats and fetches the rows again.</span></span><br /><br /> <span data-ttu-id="c12ef-235">-在事件日志，以说明发生中报告的错误。</span><span class="sxs-lookup"><span data-stu-id="c12ef-235">- Errors reported in the event log to describe what has happened.</span></span>|<span data-ttu-id="c12ef-236">-不被视为"失败"。</span><span class="sxs-lookup"><span data-stu-id="c12ef-236">- Not considered a “Failure”.</span></span> <span data-ttu-id="c12ef-237">事件日志中有任何错误消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-237">There are no error messages in the event log.</span></span><br /><br /> <span data-ttu-id="c12ef-238">-实际消息放入挂起 （恢复） 队列中。</span><span class="sxs-lookup"><span data-stu-id="c12ef-238">- Actual message is put into the suspended (resumable) queue.</span></span><br /><br /> <span data-ttu-id="c12ef-239">-订阅的端口或业务流程启动时，还可以自动恢复消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-239">- When the subscribing port or orchestration starts, the messages are automatically resumed.</span></span> <span data-ttu-id="c12ef-240">如果在订阅服务器上设置有序的传递，则它将遵循此模式。</span><span class="sxs-lookup"><span data-stu-id="c12ef-240">If ordered delivery is set on the subscriber, it will be honored.</span></span><br /><br /> <span data-ttu-id="c12ef-241">的此外可能手动恢复消息。</span><span class="sxs-lookup"><span data-stu-id="c12ef-241">- The messages may also be resumed manually.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="c12ef-242">另请参阅</span><span class="sxs-lookup"><span data-stu-id="c12ef-242">See also</span></span>  
[<span data-ttu-id="c12ef-243">开发 Oracle 数据库应用程序</span><span class="sxs-lookup"><span data-stu-id="c12ef-243">Develop your Oracle Database applications</span></span>](../../adapters-and-accelerators/adapter-oracle-database/develop-your-oracle-database-applications.md)  
 <span data-ttu-id="c12ef-244">[使用 BizTalk Server 轮询 Oracle 数据库](../../adapters-and-accelerators/adapter-oracle-database/poll-oracle-database-using-biztalk-server.md) </span><span class="sxs-lookup"><span data-stu-id="c12ef-244">[Poll Oracle Database using BizTalk Server](../../adapters-and-accelerators/adapter-oracle-database/poll-oracle-database-using-biztalk-server.md) </span></span>  
 <span data-ttu-id="c12ef-245">[使用 WCF 服务模型的 Oracle 数据库中接收基于轮询的数据更改消息](../../adapters-and-accelerators/adapter-oracle-database/receive-polling-based-data-changed-messages-in-oracle-db-using-a-wcf-service.md) </span><span class="sxs-lookup"><span data-stu-id="c12ef-245">[Receive Polling-based Data-changed Messages in Oracle Database using the WCF Service Model](../../adapters-and-accelerators/adapter-oracle-database/receive-polling-based-data-changed-messages-in-oracle-db-using-a-wcf-service.md) </span></span>  
 [<span data-ttu-id="c12ef-246">使用 WCF 通道模型的 Oracle 数据库中接收基于轮询的数据更改消息</span><span class="sxs-lookup"><span data-stu-id="c12ef-246">Receive Polling-based Data-changed Messages in Oracle Database using the WCF Channel Model</span></span>](../../adapters-and-accelerators/adapter-oracle-database/receive-polling-based-data-changed-messages-in-oracle-db-using-a-wcf-channel.md)