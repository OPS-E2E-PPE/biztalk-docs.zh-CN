---
title: 交互适配器存储和转发 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: d596780a-085d-48db-be44-a3ae58f591d0
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 6c7aff0b2421a19f5fe84ee914c4f9d2bd7ef04e
ms.sourcegitcommit: 5abd0ed3f9e4858ffaaec5481bfa8878595e95f7
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2017
ms.locfileid: "25963203"
---
# <a name="interact-adapter-store-and-forward"></a><span data-ttu-id="2f733-102">交互适配器存储和转发</span><span class="sxs-lookup"><span data-stu-id="2f733-102">InterAct Adapter Store and Forward</span></span>
<span data-ttu-id="2f733-103">存储区中和进 (SnF) 模式下，消息在发送时，传递到队列并从由目标队列检索。</span><span class="sxs-lookup"><span data-stu-id="2f733-103">In Store and Forward (SnF) mode, messages are delivered to a queue at send time, and are retrieved from the queue by the destination.</span></span> <span data-ttu-id="2f733-104">当使用 SnF，响应来自 SWIFTNet SnF 本身，并且不包含从响应方的任何反馈。</span><span class="sxs-lookup"><span data-stu-id="2f733-104">When using SnF, the response comes from SWIFTNet SnF itself, and does not contain any feedback from the Responder.</span></span>  
  
 <span data-ttu-id="2f733-105">消息和文件可以使用作为消息路由到的服务器进程，不使用 SnF 时一样灵活地处理路由排入队列。</span><span class="sxs-lookup"><span data-stu-id="2f733-105">Messages and files can be routed into queues with the same flexibility as a message routed to a server process when not using SnF.</span></span> <span data-ttu-id="2f733-106">此定义都在 MRR （内 SWIFTNet) 内。</span><span class="sxs-lookup"><span data-stu-id="2f733-106">This definition is within MRR (inside of SWIFTNet).</span></span> <span data-ttu-id="2f733-107">它是接收方负责决定哪个队列在消息或文件都将发送方发送后而言。</span><span class="sxs-lookup"><span data-stu-id="2f733-107">It is the Receiver who decides in which queue a message or file will be put after it is sent by the Sender.</span></span> <span data-ttu-id="2f733-108">将消息或文件放入队列可通过标记 （在 RequestControl) SnF 传递模式的消息。</span><span class="sxs-lookup"><span data-stu-id="2f733-108">Putting a message or file in a queue is done by flagging the message for SnF delivery mode (within the RequestControl).</span></span>  
  
 <span data-ttu-id="2f733-109">从队列检索消息所做的工作会两种不同模式，具体取决于应用程序设计器所做的选择。</span><span class="sxs-lookup"><span data-stu-id="2f733-109">Retrieving a message from a queue can occur in two different modes, depending on the choice made by the application designer.</span></span> <span data-ttu-id="2f733-110">这些模式被调用推送和拉取。</span><span class="sxs-lookup"><span data-stu-id="2f733-110">These modes are called push and pull.</span></span>  
  
 <span data-ttu-id="2f733-111">使用推送模式时，与 SWIFTNet SnF 驻留驻留计划传递的消息。</span><span class="sxs-lookup"><span data-stu-id="2f733-111">When using the push mode, the initiative to deliver a message resides with SWIFTNet SnF.</span></span> <span data-ttu-id="2f733-112">消息然后"推送"从 SWIFTNet SnF，并且接收 SWIFTNet 链接上的应用程序服务器。</span><span class="sxs-lookup"><span data-stu-id="2f733-112">The message is then “pushed” from SWIFTNet SnF and is received by an application server on SWIFTNet Link.</span></span> <span data-ttu-id="2f733-113">服务器应用程序以确保使用确认响应之前，消息，是 safestored。</span><span class="sxs-lookup"><span data-stu-id="2f733-113">The server application has to ensure that the message is safestored before responding with an acknowledgement.</span></span> <span data-ttu-id="2f733-114">此确认指示 SWIFTNet SnF 接收消息的方式。</span><span class="sxs-lookup"><span data-stu-id="2f733-114">This acknowledgement indicates to SWIFTNet SnF how the message was received.</span></span> <span data-ttu-id="2f733-115">确认不包含任何其他附加"业务"逻辑。</span><span class="sxs-lookup"><span data-stu-id="2f733-115">An acknowledgement does not contain any other additional “business” logic.</span></span>  
  
## <a name="queues-in-swiftnet"></a><span data-ttu-id="2f733-116">SWIFTNet 中的队列</span><span class="sxs-lookup"><span data-stu-id="2f733-116">Queues in SWIFTNet</span></span>  
 <span data-ttu-id="2f733-117">队列包含消息和发件人发送到指定的接收方发送的文件。</span><span class="sxs-lookup"><span data-stu-id="2f733-117">Queues contain the messages and files that were sent by the Sender to be delivered to the specified Receiver.</span></span> <span data-ttu-id="2f733-118">队列也包含由 SWIFTNet SnF 生成的发送通知。</span><span class="sxs-lookup"><span data-stu-id="2f733-118">Queues contain as well the delivery notifications that are generated by SWIFTNet SnF.</span></span>  
  
 <span data-ttu-id="2f733-119">队列是定义和配置由接收方的组织。</span><span class="sxs-lookup"><span data-stu-id="2f733-119">Queues are defined and configured by the Receiver’s organization.</span></span> <span data-ttu-id="2f733-120">实际创建队列是通过 SWIFT 上的用户的请求。</span><span class="sxs-lookup"><span data-stu-id="2f733-120">The actual creation of a queue is done by SWIFT on request of the user.</span></span> <span data-ttu-id="2f733-121">发件人不知道任何有关在其中最终会将消息队列。</span><span class="sxs-lookup"><span data-stu-id="2f733-121">The Sender does not know anything about the queue in which the message will ultimately be put.</span></span> <span data-ttu-id="2f733-122">这是完全受控制的接收方。</span><span class="sxs-lookup"><span data-stu-id="2f733-122">That is entirely under control of the Receiver.</span></span>  
  
 <span data-ttu-id="2f733-123">Queue 窗口大小属性控制的最大 SWIFTNet SnF 从而无需确认队列中检索的消息数。</span><span class="sxs-lookup"><span data-stu-id="2f733-123">The queue Window Size attribute controls the maximum number of messages SWIFTNet SnF retrieves from a queue without acknowledgement.</span></span> <span data-ttu-id="2f733-124">接收方仍必须确认消息之前，释放窗口中的槽。</span><span class="sxs-lookup"><span data-stu-id="2f733-124">The receiver still has to acknowledge the message before the slot in the window is freed up.</span></span>  
  
### <a name="delivery-into-a-queue"></a><span data-ttu-id="2f733-125">传递到队列</span><span class="sxs-lookup"><span data-stu-id="2f733-125">Delivery into a Queue</span></span>  
 <span data-ttu-id="2f733-126">使用存储转发的服务接收方判定哪个队列将用于存储在存储转发模式下发送的消息。</span><span class="sxs-lookup"><span data-stu-id="2f733-126">For services using store-and-forward the Receiver decides which queue will be used to store the message that was sent in store-and-forward mode.</span></span>  
  
 <span data-ttu-id="2f733-127">送达通知被放入发件人机构，以通知发件人发送的消息的传递状态有关的队列。</span><span class="sxs-lookup"><span data-stu-id="2f733-127">Delivery notifications are put into a queue of the Senders institution, to inform the Sender about the delivery status of a message sent.</span></span> <span data-ttu-id="2f733-128">这是与发送适配器属性可配置。</span><span class="sxs-lookup"><span data-stu-id="2f733-128">This is configurable with the send adapter properties.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="2f733-129">会话</span><span class="sxs-lookup"><span data-stu-id="2f733-129">Sessions</span></span>  
 <span data-ttu-id="2f733-130">获取队列时, 启动会话。</span><span class="sxs-lookup"><span data-stu-id="2f733-130">When acquiring a queue, a session is started.</span></span> <span data-ttu-id="2f733-131">Sw:SnFSessionId 返回每个消息，则由 SWIFTNet SnF 传送中。</span><span class="sxs-lookup"><span data-stu-id="2f733-131">The Sw:SnFSessionId is returned for every message that is delivered by SWIFTNet SnF.</span></span> <span data-ttu-id="2f733-132">Sw:SnFSessionId 包含队列名称、 会话模式： 推送和会话数。</span><span class="sxs-lookup"><span data-stu-id="2f733-132">The Sw:SnFSessionId contains the queue name, the session mode: push, and a session number.</span></span> <span data-ttu-id="2f733-133">所会话数将增加为每个会话中。</span><span class="sxs-lookup"><span data-stu-id="2f733-133">The session number is incremented for every session.</span></span> <span data-ttu-id="2f733-134">是一个示例：</span><span class="sxs-lookup"><span data-stu-id="2f733-134">An example is:</span></span>  
  
 <span data-ttu-id="2f733-135">**\<Sw:SnFSessionId\>bankwxyz_applicq1:p:000458\</Sw:SnFSessionId\>**</span><span class="sxs-lookup"><span data-stu-id="2f733-135">**\<Sw:SnFSessionId\>bankwxyz_applicq1:p:000458\</Sw:SnFSessionId\>**</span></span>  
  
 <span data-ttu-id="2f733-136">"P"指示推送会话。</span><span class="sxs-lookup"><span data-stu-id="2f733-136">The “p” indicates a push session.</span></span> <span data-ttu-id="2f733-137">会话可以也被视为队列的保留由授权者。</span><span class="sxs-lookup"><span data-stu-id="2f733-137">A session can also be seen as a reservation of the queue by an Authorizer.</span></span> <span data-ttu-id="2f733-138">后续的消息具有相同授权者的确认。</span><span class="sxs-lookup"><span data-stu-id="2f733-138">The subsequent messages have to be acknowledged by the same Authorizer.</span></span>  
  
 <span data-ttu-id="2f733-139">将消息发送到存储转发时，会话不适用。</span><span class="sxs-lookup"><span data-stu-id="2f733-139">Sessions are not applicable when sending messages to store-and-forward.</span></span>  
  
### <a name="push-session-snf"></a><span data-ttu-id="2f733-140">推送会话 SnF</span><span class="sxs-lookup"><span data-stu-id="2f733-140">Push session SnF</span></span>  
 <span data-ttu-id="2f733-141">SnF 序列假设如下：</span><span class="sxs-lookup"><span data-stu-id="2f733-141">The SnF sequence assumes the following:</span></span>  
  
-   <span data-ttu-id="2f733-142">客户端进程完成其工作时，并可以立即终止。</span><span class="sxs-lookup"><span data-stu-id="2f733-142">The client process has done its job and can now terminate.</span></span> <span data-ttu-id="2f733-143">若要执行此操作，打开安全上下文必须通过发出 SwSec:DestroyContextRequest 的身份清理。</span><span class="sxs-lookup"><span data-stu-id="2f733-143">To do this, the open security contexts must be cleaned up by issuing an SwSec:DestroyContextRequest.</span></span> <span data-ttu-id="2f733-144">后 Sw:TermRequest，进程可能 exit()。</span><span class="sxs-lookup"><span data-stu-id="2f733-144">After the Sw:TermRequest, the process may exit().</span></span>  
  
-   <span data-ttu-id="2f733-145">启动另一个客户端。</span><span class="sxs-lookup"><span data-stu-id="2f733-145">Another client is started.</span></span> <span data-ttu-id="2f733-146">初始化步骤都与第一个客户端的相同。</span><span class="sxs-lookup"><span data-stu-id="2f733-146">The initialization steps are the same as for the first client.</span></span> <span data-ttu-id="2f733-147">通过执行与作为输入基元 Sw:ReleaseSnFQueueRequest SwCall 是队列的版本。</span><span class="sxs-lookup"><span data-stu-id="2f733-147">The release of the queue is by performing an SwCall with the Sw:ReleaseSnFQueueRequest as input primitive.</span></span>  
  
     <span data-ttu-id="2f733-148">SWIFTNet 停止从队列的消息传递，一旦它已成功处理的队列的版本。</span><span class="sxs-lookup"><span data-stu-id="2f733-148">SWIFTNet stops delivery of messages from the queue as soon as it successfully processes the release of the queue.</span></span>  
  
 <span data-ttu-id="2f733-149">服务器在时间处理一个请求。</span><span class="sxs-lookup"><span data-stu-id="2f733-149">The server processes one request at the time.</span></span> <span data-ttu-id="2f733-150">SWIFTNet SnF 提供从队列中移除的多个请求。</span><span class="sxs-lookup"><span data-stu-id="2f733-150">SWIFTNet SnF delivers several requests out of the queue.</span></span> <span data-ttu-id="2f733-151">服务器响应，或发生超时之前网络和 SWIFTNet 链接中缓冲。</span><span class="sxs-lookup"><span data-stu-id="2f733-151">These are buffered within the network and SWIFTNet Link until the server responds, or a timeout occurs.</span></span>  
  
 <span data-ttu-id="2f733-152">有可能，一些请求了已传递，但尚未确认之前释放队列。</span><span class="sxs-lookup"><span data-stu-id="2f733-152">It is possible that some requests were already being delivered, but not yet acknowledged before releasing the queue.</span></span> <span data-ttu-id="2f733-153">SWIFTNet SnF 不处理这些消息的任何详细确认，直到队列被释放。</span><span class="sxs-lookup"><span data-stu-id="2f733-153">SWIFTNet SnF does not process any more acknowledgements for these messages until the queue is released.</span></span> <span data-ttu-id="2f733-154">这些消息将重新发送后续会话中。</span><span class="sxs-lookup"><span data-stu-id="2f733-154">These messages will be re-delivered in a subsequent session.</span></span>  
  
 <span data-ttu-id="2f733-155">它是从左到的本地实现是否服务器应用程序仍将使用进行响应的请求在客户端已发出版本的该队列，但是通常这不是这种情况后从队列传递一个正确认。</span><span class="sxs-lookup"><span data-stu-id="2f733-155">It is left to the local implementation whether the server application still responds with a positive acknowledgement for requests delivered from a queue after the client has issued the release of that queue, but typically this would not be the case.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2f733-156">另请参阅</span><span class="sxs-lookup"><span data-stu-id="2f733-156">See Also</span></span>  
 <span data-ttu-id="2f733-157">[交互适配器体系结构](../../adapters-and-accelerators/fileact-interact/interact-adapter-architecture.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-157">[InterAct Adapter Architecture](../../adapters-and-accelerators/fileact-interact/interact-adapter-architecture.md) </span></span>  
 <span data-ttu-id="2f733-158">[交互适配器组件](../../adapters-and-accelerators/fileact-interact/interact-adapter-components.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-158">[InterAct Adapter Components](../../adapters-and-accelerators/fileact-interact/interact-adapter-components.md) </span></span>  
 <span data-ttu-id="2f733-159">[适用于业务 Exchange 交互适配器消息](../../adapters-and-accelerators/fileact-interact/interact-adapter-messages-for-business-exchange.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-159">[InterAct Adapter Messages for Business Exchange](../../adapters-and-accelerators/fileact-interact/interact-adapter-messages-for-business-exchange.md) </span></span>  
 <span data-ttu-id="2f733-160">[交互适配器客户端应用程序](../../adapters-and-accelerators/fileact-interact/interact-adapter-client-application.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-160">[InterAct Adapter Client Application](../../adapters-and-accelerators/fileact-interact/interact-adapter-client-application.md) </span></span>  
 <span data-ttu-id="2f733-161">[交互适配器服务器应用程序](../../adapters-and-accelerators/fileact-interact/interact-adapter-server-application.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-161">[InterAct Adapter Server Application](../../adapters-and-accelerators/fileact-interact/interact-adapter-server-application.md) </span></span>  
 <span data-ttu-id="2f733-162">[交互适配器安全体系结构](../../adapters-and-accelerators/fileact-interact/interact-adapter-security-architecture.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-162">[InterAct Adapter Security Architecture](../../adapters-and-accelerators/fileact-interact/interact-adapter-security-architecture.md) </span></span>  
 <span data-ttu-id="2f733-163">[交互适配器端到端可靠传递](../../adapters-and-accelerators/fileact-interact/interact-adapter-end-to-end-reliable-delivery.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-163">[InterAct Adapter End-to-End Reliable Delivery](../../adapters-and-accelerators/fileact-interact/interact-adapter-end-to-end-reliable-delivery.md) </span></span>  
 <span data-ttu-id="2f733-164">[交互适配器状态监视](../../adapters-and-accelerators/fileact-interact/interact-adapter-status-monitoring.md) </span><span class="sxs-lookup"><span data-stu-id="2f733-164">[InterAct Adapter Status Monitoring](../../adapters-and-accelerators/fileact-interact/interact-adapter-status-monitoring.md) </span></span>  
 [<span data-ttu-id="2f733-165">InterAct 适配器不可否认性</span><span class="sxs-lookup"><span data-stu-id="2f733-165">InterAct Adapter Non-Repudiation</span></span>](../../adapters-and-accelerators/fileact-interact/interact-adapter-non-repudiation.md)