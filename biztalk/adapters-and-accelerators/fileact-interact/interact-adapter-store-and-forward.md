---
title: InterAct 适配器存储和转发 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: d596780a-085d-48db-be44-a3ae58f591d0
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8697cd25af9622057d9bd3224fe93f26b214716d
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65366662"
---
# <a name="interact-adapter-store-and-forward"></a><span data-ttu-id="26f97-102">InterAct 适配器存储和转发</span><span class="sxs-lookup"><span data-stu-id="26f97-102">InterAct Adapter Store and Forward</span></span>
<span data-ttu-id="26f97-103">在存储和转发 (SnF) 模式下，消息在发送时，传递到的队列和目标队列中的检索。</span><span class="sxs-lookup"><span data-stu-id="26f97-103">In Store and Forward (SnF) mode, messages are delivered to a queue at send time, and are retrieved from the queue by the destination.</span></span> <span data-ttu-id="26f97-104">当使用 SnF，响应来自 SWIFTNet SnF 本身并不包含从响应方的任何反馈。</span><span class="sxs-lookup"><span data-stu-id="26f97-104">When using SnF, the response comes from SWIFTNet SnF itself, and does not contain any feedback from the Responder.</span></span>  
  
 <span data-ttu-id="26f97-105">消息和文件可使用一条消息路由到的服务器进程时不使用 SnF 灵活路由到队列。</span><span class="sxs-lookup"><span data-stu-id="26f97-105">Messages and files can be routed into queues with the same flexibility as a message routed to a server process when not using SnF.</span></span> <span data-ttu-id="26f97-106">此定义位于 MRR （内部 SWIFTNet)。</span><span class="sxs-lookup"><span data-stu-id="26f97-106">This definition is within MRR (inside of SWIFTNet).</span></span> <span data-ttu-id="26f97-107">它是决定哪个队列在消息或文件将处于由发件人发送后接收方。</span><span class="sxs-lookup"><span data-stu-id="26f97-107">It is the Receiver who decides in which queue a message or file will be put after it is sent by the Sender.</span></span> <span data-ttu-id="26f97-108">将消息或文件放在队列中，可以标记 （在 RequestControl) SnF 传递模式的消息。</span><span class="sxs-lookup"><span data-stu-id="26f97-108">Putting a message or file in a queue is done by flagging the message for SnF delivery mode (within the RequestControl).</span></span>  
  
 <span data-ttu-id="26f97-109">从队列检索消息可能在两个不同的模式下，具体取决于应用程序设计器所做的选择。</span><span class="sxs-lookup"><span data-stu-id="26f97-109">Retrieving a message from a queue can occur in two different modes, depending on the choice made by the application designer.</span></span> <span data-ttu-id="26f97-110">这些模式被调用推送和拉取。</span><span class="sxs-lookup"><span data-stu-id="26f97-110">These modes are called push and pull.</span></span>  
  
 <span data-ttu-id="26f97-111">使用推送模式时，计划时传递语音消息位于 SWIFTNet SnF。</span><span class="sxs-lookup"><span data-stu-id="26f97-111">When using the push mode, the initiative to deliver a message resides with SWIFTNet SnF.</span></span> <span data-ttu-id="26f97-112">该消息然后"推送"从 SWIFTNet SnF 且会收到 SWIFTNet 链接上的应用程序服务器。</span><span class="sxs-lookup"><span data-stu-id="26f97-112">The message is then “pushed” from SWIFTNet SnF and is received by an application server on SWIFTNet Link.</span></span> <span data-ttu-id="26f97-113">服务器应用程序必须确保该消息是 safestored 确认响应之前。</span><span class="sxs-lookup"><span data-stu-id="26f97-113">The server application has to ensure that the message is safestored before responding with an acknowledgement.</span></span> <span data-ttu-id="26f97-114">此确认指示 SWIFTNet SnF 如何接收消息。</span><span class="sxs-lookup"><span data-stu-id="26f97-114">This acknowledgement indicates to SWIFTNet SnF how the message was received.</span></span> <span data-ttu-id="26f97-115">确认不包含任何其他更多"业务"逻辑。</span><span class="sxs-lookup"><span data-stu-id="26f97-115">An acknowledgement does not contain any other additional “business” logic.</span></span>  
  
## <a name="queues-in-swiftnet"></a><span data-ttu-id="26f97-116">SWIFTNet 中的队列</span><span class="sxs-lookup"><span data-stu-id="26f97-116">Queues in SWIFTNet</span></span>  
 <span data-ttu-id="26f97-117">队列包含消息和发送的发送方要传递到指定的接收方的文件。</span><span class="sxs-lookup"><span data-stu-id="26f97-117">Queues contain the messages and files that were sent by the Sender to be delivered to the specified Receiver.</span></span> <span data-ttu-id="26f97-118">队列还包含生成的 SWIFTNet SnF 的发送通知。</span><span class="sxs-lookup"><span data-stu-id="26f97-118">Queues contain as well the delivery notifications that are generated by SWIFTNet SnF.</span></span>  
  
 <span data-ttu-id="26f97-119">队列定义和配置的接收方的组织。</span><span class="sxs-lookup"><span data-stu-id="26f97-119">Queues are defined and configured by the Receiver’s organization.</span></span> <span data-ttu-id="26f97-120">实际创建队列，可以在用户请求 SWIFT。</span><span class="sxs-lookup"><span data-stu-id="26f97-120">The actual creation of a queue is done by SWIFT on request of the user.</span></span> <span data-ttu-id="26f97-121">发件人不知道在其中最终会将消息队列有关的任何信息。</span><span class="sxs-lookup"><span data-stu-id="26f97-121">The Sender does not know anything about the queue in which the message will ultimately be put.</span></span> <span data-ttu-id="26f97-122">这是完全受控制的接收方。</span><span class="sxs-lookup"><span data-stu-id="26f97-122">That is entirely under control of the Receiver.</span></span>  
  
 <span data-ttu-id="26f97-123">队列窗口大小属性控制 SWIFTNet SnF 确认对队列中检索的消息的最大数目。</span><span class="sxs-lookup"><span data-stu-id="26f97-123">The queue Window Size attribute controls the maximum number of messages SWIFTNet SnF retrieves from a queue without acknowledgement.</span></span> <span data-ttu-id="26f97-124">接收方仍必须确认该消息之前，释放在窗口中的槽。</span><span class="sxs-lookup"><span data-stu-id="26f97-124">The receiver still has to acknowledge the message before the slot in the window is freed up.</span></span>  
  
### <a name="delivery-into-a-queue"></a><span data-ttu-id="26f97-125">传递到队列</span><span class="sxs-lookup"><span data-stu-id="26f97-125">Delivery into a Queue</span></span>  
 <span data-ttu-id="26f97-126">使用存储和转发的服务接收方判定哪个队列用于存储中存储和转发模式发送的消息。</span><span class="sxs-lookup"><span data-stu-id="26f97-126">For services using store-and-forward the Receiver decides which queue will be used to store the message that was sent in store-and-forward mode.</span></span>  
  
 <span data-ttu-id="26f97-127">送达通知被放入队列的发件人机构，若要发送的消息的传递状态通知发件人。</span><span class="sxs-lookup"><span data-stu-id="26f97-127">Delivery notifications are put into a queue of the Senders institution, to inform the Sender about the delivery status of a message sent.</span></span> <span data-ttu-id="26f97-128">这是可配置为发送适配器属性。</span><span class="sxs-lookup"><span data-stu-id="26f97-128">This is configurable with the send adapter properties.</span></span>  
  
## <a name="sessions"></a><span data-ttu-id="26f97-129">会话</span><span class="sxs-lookup"><span data-stu-id="26f97-129">Sessions</span></span>  
 <span data-ttu-id="26f97-130">获取队列时, 启动一个会话。</span><span class="sxs-lookup"><span data-stu-id="26f97-130">When acquiring a queue, a session is started.</span></span> <span data-ttu-id="26f97-131">Sw:SnFSessionId 返回每个消息，则由 SWIFTNet SnF 传送。</span><span class="sxs-lookup"><span data-stu-id="26f97-131">The Sw:SnFSessionId is returned for every message that is delivered by SWIFTNet SnF.</span></span> <span data-ttu-id="26f97-132">Sw:SnFSessionId 包含队列名称的会话模式： 推送和会话编号。</span><span class="sxs-lookup"><span data-stu-id="26f97-132">The Sw:SnFSessionId contains the queue name, the session mode: push, and a session number.</span></span> <span data-ttu-id="26f97-133">会话号会递增为每个会话。</span><span class="sxs-lookup"><span data-stu-id="26f97-133">The session number is incremented for every session.</span></span> <span data-ttu-id="26f97-134">是一个示例：</span><span class="sxs-lookup"><span data-stu-id="26f97-134">An example is:</span></span>  
  
 <span data-ttu-id="26f97-135">**\<Sw:SnFSessionId\>bankwxyz_applicq1:p:000458\</Sw:SnFSessionId\>**</span><span class="sxs-lookup"><span data-stu-id="26f97-135">**\<Sw:SnFSessionId\>bankwxyz_applicq1:p:000458\</Sw:SnFSessionId\>**</span></span>  
  
 <span data-ttu-id="26f97-136">"P"指示推送会话。</span><span class="sxs-lookup"><span data-stu-id="26f97-136">The “p” indicates a push session.</span></span> <span data-ttu-id="26f97-137">会话可以也被视为的队列保留授权者。</span><span class="sxs-lookup"><span data-stu-id="26f97-137">A session can also be seen as a reservation of the queue by an Authorizer.</span></span> <span data-ttu-id="26f97-138">必须确认相同授权者的后续消息。</span><span class="sxs-lookup"><span data-stu-id="26f97-138">The subsequent messages have to be acknowledged by the same Authorizer.</span></span>  
  
 <span data-ttu-id="26f97-139">将消息发送到存储转发时，会话不适用。</span><span class="sxs-lookup"><span data-stu-id="26f97-139">Sessions are not applicable when sending messages to store-and-forward.</span></span>  
  
### <a name="push-session-snf"></a><span data-ttu-id="26f97-140">推送会话 SnF</span><span class="sxs-lookup"><span data-stu-id="26f97-140">Push session SnF</span></span>  
 <span data-ttu-id="26f97-141">SnF 序列的假设条件如下：</span><span class="sxs-lookup"><span data-stu-id="26f97-141">The SnF sequence assumes the following:</span></span>  
  
- <span data-ttu-id="26f97-142">客户端进程已完成其工作，并可以立即终止。</span><span class="sxs-lookup"><span data-stu-id="26f97-142">The client process has done its job and can now terminate.</span></span> <span data-ttu-id="26f97-143">若要执行此操作，打开安全上下文必须通过发出 SwSec:DestroyContextRequest 的身份清理。</span><span class="sxs-lookup"><span data-stu-id="26f97-143">To do this, the open security contexts must be cleaned up by issuing an SwSec:DestroyContextRequest.</span></span> <span data-ttu-id="26f97-144">后 Sw:TermRequest，进程可能 exit()。</span><span class="sxs-lookup"><span data-stu-id="26f97-144">After the Sw:TermRequest, the process may exit().</span></span>  
  
- <span data-ttu-id="26f97-145">启动另一个客户端。</span><span class="sxs-lookup"><span data-stu-id="26f97-145">Another client is started.</span></span> <span data-ttu-id="26f97-146">与第一个客户端相同的初始化步骤。</span><span class="sxs-lookup"><span data-stu-id="26f97-146">The initialization steps are the same as for the first client.</span></span> <span data-ttu-id="26f97-147">通过执行与作为输入基元 Sw:ReleaseSnFQueueRequest SwCall 是队列的版本。</span><span class="sxs-lookup"><span data-stu-id="26f97-147">The release of the queue is by performing an SwCall with the Sw:ReleaseSnFQueueRequest as input primitive.</span></span>  
  
   <span data-ttu-id="26f97-148">SWIFTNet 停止从队列的消息传递，只要它已成功处理的队列的版本。</span><span class="sxs-lookup"><span data-stu-id="26f97-148">SWIFTNet stops delivery of messages from the queue as soon as it successfully processes the release of the queue.</span></span>  
  
  <span data-ttu-id="26f97-149">服务器时将处理一个请求。</span><span class="sxs-lookup"><span data-stu-id="26f97-149">The server processes one request at the time.</span></span> <span data-ttu-id="26f97-150">SWIFTNet SnF 提供了多个请求从队列中移除。</span><span class="sxs-lookup"><span data-stu-id="26f97-150">SWIFTNet SnF delivers several requests out of the queue.</span></span> <span data-ttu-id="26f97-151">这些被缓存中的网络和 SWIFTNet 链接，直到服务器做出响应，或发生超时。</span><span class="sxs-lookup"><span data-stu-id="26f97-151">These are buffered within the network and SWIFTNet Link until the server responds, or a timeout occurs.</span></span>  
  
  <span data-ttu-id="26f97-152">有可能，某些请求已被传递，但尚未确认之前释放队列。</span><span class="sxs-lookup"><span data-stu-id="26f97-152">It is possible that some requests were already being delivered, but not yet acknowledged before releasing the queue.</span></span> <span data-ttu-id="26f97-153">SWIFTNet SnF 不处理任何多个确认中的为这些消息，直到释放队列。</span><span class="sxs-lookup"><span data-stu-id="26f97-153">SWIFTNet SnF does not process any more acknowledgements for these messages until the queue is released.</span></span> <span data-ttu-id="26f97-154">这些消息将被重新传送后续会话中。</span><span class="sxs-lookup"><span data-stu-id="26f97-154">These messages will be re-delivered in a subsequent session.</span></span>  
  
  <span data-ttu-id="26f97-155">服务器应用程序仍会响应与请求后的客户端发出的新版该队列，但这不是这种情况通常从队列传递的肯定确认是否将由的本地实现。</span><span class="sxs-lookup"><span data-stu-id="26f97-155">It is left to the local implementation whether the server application still responds with a positive acknowledgement for requests delivered from a queue after the client has issued the release of that queue, but typically this would not be the case.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="26f97-156">请参阅</span><span class="sxs-lookup"><span data-stu-id="26f97-156">See Also</span></span>  
 <span data-ttu-id="26f97-157">[InterAct 适配器体系结构](../../adapters-and-accelerators/fileact-interact/interact-adapter-architecture.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-157">[InterAct Adapter Architecture](../../adapters-and-accelerators/fileact-interact/interact-adapter-architecture.md) </span></span>  
 <span data-ttu-id="26f97-158">[InterAct 适配器组件](../../adapters-and-accelerators/fileact-interact/interact-adapter-components.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-158">[InterAct Adapter Components](../../adapters-and-accelerators/fileact-interact/interact-adapter-components.md) </span></span>  
 <span data-ttu-id="26f97-159">[Business Exchange 的 interAct 适配器消息](../../adapters-and-accelerators/fileact-interact/interact-adapter-messages-for-business-exchange.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-159">[InterAct Adapter Messages for Business Exchange](../../adapters-and-accelerators/fileact-interact/interact-adapter-messages-for-business-exchange.md) </span></span>  
 <span data-ttu-id="26f97-160">[InterAct 适配器客户端应用程序](../../adapters-and-accelerators/fileact-interact/interact-adapter-client-application.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-160">[InterAct Adapter Client Application](../../adapters-and-accelerators/fileact-interact/interact-adapter-client-application.md) </span></span>  
 <span data-ttu-id="26f97-161">[InterAct 适配器服务器应用程序](../../adapters-and-accelerators/fileact-interact/interact-adapter-server-application.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-161">[InterAct Adapter Server Application](../../adapters-and-accelerators/fileact-interact/interact-adapter-server-application.md) </span></span>  
 <span data-ttu-id="26f97-162">[InterAct 适配器安全体系结构](../../adapters-and-accelerators/fileact-interact/interact-adapter-security-architecture.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-162">[InterAct Adapter Security Architecture](../../adapters-and-accelerators/fileact-interact/interact-adapter-security-architecture.md) </span></span>  
 <span data-ttu-id="26f97-163">[交互适配器端到端可靠传递](../../adapters-and-accelerators/fileact-interact/interact-adapter-end-to-end-reliable-delivery.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-163">[InterAct Adapter End-to-End Reliable Delivery](../../adapters-and-accelerators/fileact-interact/interact-adapter-end-to-end-reliable-delivery.md) </span></span>  
 <span data-ttu-id="26f97-164">[InterAct 适配器状态监视](../../adapters-and-accelerators/fileact-interact/interact-adapter-status-monitoring.md) </span><span class="sxs-lookup"><span data-stu-id="26f97-164">[InterAct Adapter Status Monitoring](../../adapters-and-accelerators/fileact-interact/interact-adapter-status-monitoring.md) </span></span>  
 [<span data-ttu-id="26f97-165">InterAct 适配器不可否认性</span><span class="sxs-lookup"><span data-stu-id="26f97-165">InterAct Adapter Non-Repudiation</span></span>](../../adapters-and-accelerators/fileact-interact/interact-adapter-non-repudiation.md)