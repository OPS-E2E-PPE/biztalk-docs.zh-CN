---
title: "优化业务规则引擎 (BRE) 性能 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: c271b059-174d-4e8b-88b5-c3f408a97f1f
caps.latest.revision: "4"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 14c3adf32ac06d80c1aab8f870d82156470097a5
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="optimizing-business-rule-engine-bre-performance"></a><span data-ttu-id="5e4c6-102">优化业务规则引擎 (BRE) 性能</span><span class="sxs-lookup"><span data-stu-id="5e4c6-102">Optimizing Business Rule Engine (BRE) Performance</span></span>
<span data-ttu-id="5e4c6-103">在 BizTalk Server 解决方案中实施业务规则引擎 (BRE) 时，应考虑以下因素：</span><span class="sxs-lookup"><span data-stu-id="5e4c6-103">The following factors should be considered when implementing the Business Rule Engine (BRE) in a BizTalk Server solution:</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="5e4c6-104">事实类型</span><span class="sxs-lookup"><span data-stu-id="5e4c6-104">Fact types</span></span>  
 <span data-ttu-id="5e4c6-105">规则引擎对访问.NET 事实相对于时间要花费数来访问 XML 和数据库事实的更少的时间。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-105">The rule engine takes less time to access .NET facts compared to the time it takes to access XML and database facts.</span></span> <span data-ttu-id="5e4c6-106">如果你有一种策略中使用.NET 或 XML 或数据库事实，您应考虑使用.NET 事实以提高性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-106">If you have a choice of using either .NET or XML or database facts in a policy, you should consider using .NET facts for improved performance.</span></span>  
  
## <a name="data-table-vs-data-connection"></a><span data-ttu-id="5e4c6-107">与数据连接的数据表</span><span class="sxs-lookup"><span data-stu-id="5e4c6-107">Data table vs. data connection</span></span>  
 <span data-ttu-id="5e4c6-108">当数据集的大小很小 (< 10 个）， **TypedDataTable**绑定提供更好的性能比**该组**绑定。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-108">When the size of the data set is small (< 10 or so), the **TypedDataTable** binding provides better performance than the **DataConnection** binding.</span></span> <span data-ttu-id="5e4c6-109">但是，**该组**绑定更好地执行比**TypedDataTable**绑定时数据集很大 （大于或等于 10 行大约）。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-109">However, the **DataConnection** binding performs better than the **TypedDataTable** binding when the data set is large (greater than or equal to 10 rows approximately).</span></span> <span data-ttu-id="5e4c6-110">因此，你应确定是否使用**该组**绑定或**TypedDataTable**绑定基于数据集的估计大小。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-110">Therefore, you should decide whether to use the **DataConnection** binding or **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="5e4c6-111">事实检索器</span><span class="sxs-lookup"><span data-stu-id="5e4c6-111">Fact retrievers</span></span>  
 <span data-ttu-id="5e4c6-112">事实检索器实现标准方法通常用来提供到规则引擎的长期和渐变事实数据之前执行策略。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-112">A fact retriever implements standard methods which are typically used to supply long-term and slowly changing facts to the rule engine before a policy is executed.</span></span> <span data-ttu-id="5e4c6-113">引擎将缓存这些事实，并在多个执行循环中使用它们。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="5e4c6-114">而不是提交的静态或相当静态事实每次调用的规则引擎，你应创建的事实检索器第一次，提交这一事实，然后更新仅在必要时的内存中的事实。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-114">Instead of submitting a static or fairly static fact each time that you invoke the rule engine, you should create a fact retriever that submits the fact for the first time, and then updates the fact in memory only when necessary.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="5e4c6-115">规则的优先级</span><span class="sxs-lookup"><span data-stu-id="5e4c6-115">Rule priority</span></span>  
 <span data-ttu-id="5e4c6-116">优先级设置的任何一侧的范围规则可以**0**，有了更多具有更高的优先级。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="5e4c6-117">从最高优先级到最低优先级的顺序执行操作。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-117">Actions are executed in order from the highest priority to lowest priority.</span></span> <span data-ttu-id="5e4c6-118">当策略都实现通过使用正向链接行为**断言/更新**调用，链接，可优化通过使用的优先级设置。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="5e4c6-119">例如，假定**Rule2**具有设置的一个值的依赖关系**规则 1**。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-119">For example, assume that **Rule2** has a dependency on a value set by **Rule1**.</span></span> <span data-ttu-id="5e4c6-120">提供**规则 1**更高的优先级意味着**Rule2**将仅执行后**规则 1**激发和更新的值。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-120">Giving **Rule1** a higher priority means that **Rule2** will only execute after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="5e4c6-121">相反，如果**Rule2**已分配更高的优先级，它无法触发一次，并显示后再次然后激发**规则 1**触发并更新这一事实， **Rule2**使用条件。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-121">Conversely, if **Rule2** were given a higher priority, it could fire once, and then fire again after **Rule1** fires and update the fact that **Rule2** is using a condition.</span></span> <span data-ttu-id="5e4c6-122">尽管这可以提供正确的结果，让**规则 1**的优先级高于在此方案中将提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-122">While this may provide a correct result, giving **Rule1** a higher priority in this scenario will provide better performance.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="5e4c6-123">更新调用</span><span class="sxs-lookup"><span data-stu-id="5e4c6-123">Update calls</span></span>  
 <span data-ttu-id="5e4c6-124">Update 函数会导致使用的更新的事实数据进行重新求值的所有规则。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-124">The Update function causes all the rules using the updated facts to be reevaluated.</span></span> <span data-ttu-id="5e4c6-125">更新函数调用可能开销大，尤其是在更新事实数据时，一大组规则进行重新计算。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-125">Update function calls can be expensive especially if a large set of rules is reevaluated when updating facts.</span></span> <span data-ttu-id="5e4c6-126">在一些情况下此行为可以避免这样做。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-126">There are situations where this behavior can be avoided.</span></span> <span data-ttu-id="5e4c6-127">例如，请考虑以下规则。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-127">For example, consider the following rules.</span></span>  
  
 <span data-ttu-id="5e4c6-128">**规则 1:**</span><span class="sxs-lookup"><span data-stu-id="5e4c6-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="5e4c6-129">**Rule2:**</span><span class="sxs-lookup"><span data-stu-id="5e4c6-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="5e4c6-130">策略使用的所有剩余规则**StatusObj.Flag**在其条件。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="5e4c6-131">因此，当**更新**上调用**StatusObj**对象，将会重新计算所有规则。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-131">Therefore, when **Update** is called on the **StatusObj** object, all rules will be reevaluated.</span></span> <span data-ttu-id="5e4c6-132">任意值**量**字段为，除之外的所有规则**规则 1**或**Rule2**两次，计算一次之前**更新**调用和一次之后**更新**调用。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-132">Whatever the value of the **Amount** field is, all rules except **Rule1** or **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="5e4c6-133">若要缓解关联开销，你可以设置的值**标志**字段**false**之前调用的策略和仅限然后使用**规则 1**中设置标志的策略.</span><span class="sxs-lookup"><span data-stu-id="5e4c6-133">To mitigate the associated overhead, you could set the value of the **flag** field to **false** prior to invoking the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="5e4c6-134">在这种情况下，**更新**才会调用的值**量**字段大于 5，和**更新**如果，将不会调用函数的值**量**小于或等于 5。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-134">In this case, **Update** would be called only if the value of the **Amount** field is greater than 5, and the **Update** function is not called if the value of **Amount** is less than or equal to 5.</span></span> <span data-ttu-id="5e4c6-135">因此，所有规则除**规则 1**或**Rule2**计算两次才的值**量**字段大于 5。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-135">Therefore, all the rules except **Rule1** or **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="usage-of-logical-or-operators"></a><span data-ttu-id="5e4c6-136">逻辑 OR 运算符的使用情况</span><span class="sxs-lookup"><span data-stu-id="5e4c6-136">Usage of logical OR operators</span></span>  
 <span data-ttu-id="5e4c6-137">在条件中使用越来越多的逻辑 OR 运算符创建展开规则引擎的分析网络的其他排列。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-137">Using an increasing number of logical OR operators in conditions creates additional permutations that expand the analysis network of the rule engine.</span></span> <span data-ttu-id="5e4c6-138">从性能角度看，你完全了解将条件拆分为不包含逻辑 OR 运算符的原子规则。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-138">From a performance standpoint, you are better off splitting the conditions into atomic rules that do not contain logical OR operators.</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="5e4c6-139">缓存设置</span><span class="sxs-lookup"><span data-stu-id="5e4c6-139">Caching settings</span></span>  
 <span data-ttu-id="5e4c6-140">规则引擎会使用两个缓存。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-140">The Rule Engine uses two caches.</span></span> <span data-ttu-id="5e4c6-141">更新服务使用的第一个和第二个由每个 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-141">The first one is used by the update service and the second one is used by each BizTalk process.</span></span> <span data-ttu-id="5e4c6-142">第一次使用策略时，BizTalk 过程从更新服务请求的策略信息。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-142">The first time a policy is used, the BizTalk process requests the policy information from the update service.</span></span> <span data-ttu-id="5e4c6-143">更新服务从规则引擎数据库中检索的策略信息、 其进行缓存和到 BizTalk 进程返回的信息。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-143">The update service retrieves the policy information from the rule engine database, caches it and returns the information to the BizTalk process.</span></span> <span data-ttu-id="5e4c6-144">BizTalk 进程创建基于该信息的策略对象，并将该策略对象存储在缓存中，关联的规则引擎实例完成执行的策略时。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-144">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes execution of the policy.</span></span> <span data-ttu-id="5e4c6-145">当再次调用相同的策略时，BizTalk 进程将重用缓存中的策略对象，如果有的话。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-145">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available.</span></span> <span data-ttu-id="5e4c6-146">同样，如果 BizTalk 过程从更新服务请求有关策略的信息，更新服务查找其缓存中的策略信息是否可用。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-146">Similarly, if the BizTalk process requests information about a policy from update service, the update service looks for the policy information in its cache if it is available.</span></span> <span data-ttu-id="5e4c6-147">每隔 60 秒，更新服务还检查是否已在数据库中的策略的任何更新。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-147">Every 60 seconds, the update service also checks if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="5e4c6-148">如果有任何更新，更新服务检索信息，并缓存更新的信息。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-148">If there are any updates, the update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="5e4c6-149">与这些缓存相关的规则引擎的三个优化参数： **CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-149">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="5e4c6-150">您可以在注册表或配置文件中为这些参数指定值。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-150">You can specify the values for these parameters either in the registry or in a configuration file.</span></span> <span data-ttu-id="5e4c6-151">值**CacheEntries**参数是缓存中的最大项数，默认设置为值为 32。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-151">The value of the **CacheEntries** parameter is the maximum number of entries in the cache and is set to a value of 32 by default.</span></span> <span data-ttu-id="5e4c6-152">你可能想要的值增加**CacheEntries**参数来提高某些方案中的性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-152">You may want to increase the value of the **CacheEntries** parameter to improve performance in certain scenarios.</span></span> <span data-ttu-id="5e4c6-153">例如，假设你重复; 使用 40 策略你可以增加的值**CacheEntries**为 40 以提高性能的参数。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-153">For example, say you are using 40 policies repeatedly; you could to increase the value of the **CacheEntries** parameter to 40 to improve performance.</span></span> <span data-ttu-id="5e4c6-154">这样可以允许更新服务维护的最多 40 策略在内存中的缓存详细信息。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-154">This would allow the update service to maintain cache details of up to 40 policies in memory.</span></span>  
  
 <span data-ttu-id="5e4c6-155">值**CacheTimeout**是以秒为单位，在更新服务缓存中维护一个条目的时间。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-155">The value of **CacheTimeout** is the time in seconds that an entry is maintained in the update service cache.</span></span> <span data-ttu-id="5e4c6-156">换而言之， **CacheTimeout**的策略不所引用的情况下，在缓存中保留多长时间的缓存项引用值。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-156">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is maintained in the cache without being referenced.</span></span> <span data-ttu-id="5e4c6-157">默认值**CacheTimeout**参数为 3600 秒或 1 小时。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-157">The default value of **CacheTimeout** parameter is 3600 seconds, or 1 hour.</span></span> <span data-ttu-id="5e4c6-158">这意味着，如果一小时内未引用的缓存项，该条目并被删除。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-158">It means that if the cache entry is not referenced within an hour, the entry is deleted.</span></span> <span data-ttu-id="5e4c6-159">在某些情况下，它可能是有益的值增加**CacheTimeout**参数来提高性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-159">In some cases, it may be beneficial to increase the value of the **CacheTimeout** parameter to improve performance.</span></span> <span data-ttu-id="5e4c6-160">例如，如果每两小时调用一个策略，则策略执行的性能将提高通过增加**CacheTimeout**参数大于两个小时的值。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-160">For example, if a policy is invoked every two hours, performance of the policy execution would be improved by increasing the **CacheTimeout** parameter to a value higher than two hours.</span></span>  
  
 <span data-ttu-id="5e4c6-161">**PollingInterval**的规则引擎的参数以秒为单位的更新服务检查更新的规则引擎数据库中定义的时间。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-161">The **PollingInterval** parameter of the rule engine defines the time in seconds for the update service to check the rule engine database for updates.</span></span> <span data-ttu-id="5e4c6-162">默认值为**PollingInterval**参数为 60 秒。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-162">The default value for the **PollingInterval** parameter is 60 seconds.</span></span> <span data-ttu-id="5e4c6-163">如果你知道策略未在所有更新或更新时极少数情况下，您可以更改此参数为更高版本的值，以提高性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-163">If you know that the policies do not get updated at all or are updated rarely, you could change this parameter to a higher value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="5e4c6-164">SideEffects 属性</span><span class="sxs-lookup"><span data-stu-id="5e4c6-164">SideEffects property</span></span>  
 <span data-ttu-id="5e4c6-165">**ClassMemberBinding**， **DatabaseColumnBinding**，和**XmlDocumentFieldBinding**类具有名为的属性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="5e4c6-165">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="5e4c6-166">此属性确定是否缓存绑定字段的值、成员或列。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-166">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="5e4c6-167">默认值**SideEffects**中的属性**DatabaseColumnBinding**和**XmlDocumentFieldBinding**类**false**.</span><span class="sxs-lookup"><span data-stu-id="5e4c6-167">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="5e4c6-168">默认值**SideEffects**中的属性**ClassMemberBinding**类是**true**。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-168">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="5e4c6-169">因此，如果 XML 文档字段或数据库表的列是在策略中第二次访问或稍后访问的，则其值从缓存中检索。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-169">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="5e4c6-170">不过，如果 .NET 对象的成员是第二次访问或稍后访问的，其值从 .NET 对象检索，而不是从缓存中检索。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-170">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="5e4c6-171">设置**SideEffects** .NET 属性**ClassMemberBinding**到**false**将提高性能，因为从缓存中检索字段的值第二次及以上版本。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-171">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="5e4c6-172">您只能通过编程方式来完成此步骤。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-172">You can only do this programmatically.</span></span> <span data-ttu-id="5e4c6-173">业务规则编辑器工具不会公开**SideEffects**属性。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-173">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="5e4c6-174">实例和选择性</span><span class="sxs-lookup"><span data-stu-id="5e4c6-174">Instances and selectivity</span></span>  
 <span data-ttu-id="5e4c6-175">**XmlDocumentBinding**， **ClassBinding**，和**DatabaseBinding**类具有两个属性：**实例**和**选择性**。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-175">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="5e4c6-176">Instances 的值是工作内存中类的实例的预期数目。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-176">The value of Instances is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="5e4c6-177">值**选择性**是成功传递的规则条件的类实例的百分比。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-177">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="5e4c6-178">规则引擎使用这些值来优化条件计算，这样在条件计算中最初尽可能使用最少的实例，以后再使用其余的实例。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-178">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="5e4c6-179">如果必须事先了解的对象的实例数，请设置**实例**属性与此值会提高性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-179">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="5e4c6-180">同样，如果必须事先了解这些对象传递条件的百分比，则设置**选择性**属性与此值会提高性能。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-180">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="5e4c6-181">只能通过编程方式来设置这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-181">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="5e4c6-182">业务规则编辑器工具不公开这些属性。</span><span class="sxs-lookup"><span data-stu-id="5e4c6-182">The Business Rule Composer tool does not expose them.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5e4c6-183">另请参阅</span><span class="sxs-lookup"><span data-stu-id="5e4c6-183">See Also</span></span>  
 [<span data-ttu-id="5e4c6-184">优化 BizTalk Server 性能</span><span class="sxs-lookup"><span data-stu-id="5e4c6-184">Optimizing BizTalk Server Performance</span></span>](../technical-guides/optimizing-biztalk-server-performance.md)