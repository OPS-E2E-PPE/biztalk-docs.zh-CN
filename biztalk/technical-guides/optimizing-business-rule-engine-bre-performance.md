---
title: 优化业务规则引擎 (BRE) 性能 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c271b059-174d-4e8b-88b5-c3f408a97f1f
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 18fdd1e642d211a79f591f5029dcd37ac618011b
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65242633"
---
# <a name="optimizing-business-rule-engine-bre-performance"></a><span data-ttu-id="18feb-102">优化业务规则引擎 (BRE) 性能</span><span class="sxs-lookup"><span data-stu-id="18feb-102">Optimizing Business Rule Engine (BRE) Performance</span></span>
<span data-ttu-id="18feb-103">在 BizTalk Server 解决方案中实施业务规则引擎 (BRE) 时，应考虑以下因素：</span><span class="sxs-lookup"><span data-stu-id="18feb-103">The following factors should be considered when implementing the Business Rule Engine (BRE) in a BizTalk Server solution:</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="18feb-104">事实类型</span><span class="sxs-lookup"><span data-stu-id="18feb-104">Fact types</span></span>  
 <span data-ttu-id="18feb-105">规则引擎需要访问.NET 事实的时间访问 XML 和数据库事实所花费更少的时间。</span><span class="sxs-lookup"><span data-stu-id="18feb-105">The rule engine takes less time to access .NET facts compared to the time it takes to access XML and database facts.</span></span> <span data-ttu-id="18feb-106">如果您可以在策略中使用.NET 或 XML 或数据库事实的选择，应考虑使用.NET 事实会提高性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-106">If you have a choice of using either .NET or XML or database facts in a policy, you should consider using .NET facts for improved performance.</span></span>  
  
## <a name="data-table-vs-data-connection"></a><span data-ttu-id="18feb-107">数据连接和数据表</span><span class="sxs-lookup"><span data-stu-id="18feb-107">Data table vs. data connection</span></span>  
 <span data-ttu-id="18feb-108">当数据集的大小很小 （< 10 个左右）， **TypedDataTable**绑定提供了更好的性能比**DataConnection**绑定。</span><span class="sxs-lookup"><span data-stu-id="18feb-108">When the size of the data set is small (< 10 or so), the **TypedDataTable** binding provides better performance than the **DataConnection** binding.</span></span> <span data-ttu-id="18feb-109">但是， **DataConnection**绑定的性能更好地比**TypedDataTable**绑定时数据集较大 （大于或等于 10 行大约）。</span><span class="sxs-lookup"><span data-stu-id="18feb-109">However, the **DataConnection** binding performs better than the **TypedDataTable** binding when the data set is large (greater than or equal to 10 rows approximately).</span></span> <span data-ttu-id="18feb-110">因此，应决定是使用**DataConnection**绑定或**TypedDataTable**绑定基于数据集的估计大小。</span><span class="sxs-lookup"><span data-stu-id="18feb-110">Therefore, you should decide whether to use the **DataConnection** binding or **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="18feb-111">事实检索器</span><span class="sxs-lookup"><span data-stu-id="18feb-111">Fact retrievers</span></span>  
 <span data-ttu-id="18feb-112">事实检索器实现通常用于提供长期和缓慢变化的事实，到规则引擎策略执行前的标准方法。</span><span class="sxs-lookup"><span data-stu-id="18feb-112">A fact retriever implements standard methods which are typically used to supply long-term and slowly changing facts to the rule engine before a policy is executed.</span></span> <span data-ttu-id="18feb-113">引擎将缓存这些事实，并使用多个执行循环。</span><span class="sxs-lookup"><span data-stu-id="18feb-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="18feb-114">而不是提交一个静态的或相当静态的事实每次调用规则引擎，则应创建事实检索器的第一次提交这一事实，然后更新仅在必要时的内存中的事实。</span><span class="sxs-lookup"><span data-stu-id="18feb-114">Instead of submitting a static or fairly static fact each time that you invoke the rule engine, you should create a fact retriever that submits the fact for the first time, and then updates the fact in memory only when necessary.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="18feb-115">规则优先级</span><span class="sxs-lookup"><span data-stu-id="18feb-115">Rule priority</span></span>  
 <span data-ttu-id="18feb-116">优先级设置规则范围的任何一侧**0**，更大的数字越大优先级越高。</span><span class="sxs-lookup"><span data-stu-id="18feb-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="18feb-117">从最高优先级到最低优先级的顺序执行操作。</span><span class="sxs-lookup"><span data-stu-id="18feb-117">Actions are executed in order from the highest priority to lowest priority.</span></span> <span data-ttu-id="18feb-118">当此策略将实现通过使用正向链接行为**Assert/Update**可以使用优先级设置优化链接的调用。</span><span class="sxs-lookup"><span data-stu-id="18feb-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="18feb-119">例如，假定**Rule2**设置的值具有的依赖项**Rule1**。</span><span class="sxs-lookup"><span data-stu-id="18feb-119">For example, assume that **Rule2** has a dependency on a value set by **Rule1**.</span></span> <span data-ttu-id="18feb-120">为提供**Rule1**更高的优先级意味着**Rule2**将仅执行后**Rule1**触发和更新值。</span><span class="sxs-lookup"><span data-stu-id="18feb-120">Giving **Rule1** a higher priority means that **Rule2** will only execute after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="18feb-121">相反，如果**Rule2**了更高的优先级，它可能触发一次，而且并触发后**Rule1**触发和更新这一事实的**Rule2**使用的条件。</span><span class="sxs-lookup"><span data-stu-id="18feb-121">Conversely, if **Rule2** were given a higher priority, it could fire once, and then fire again after **Rule1** fires and update the fact that **Rule2** is using a condition.</span></span> <span data-ttu-id="18feb-122">虽然这可以提供正确的结果，使**Rule1**在此方案中更高的优先级将提供更好的性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-122">While this may provide a correct result, giving **Rule1** a higher priority in this scenario will provide better performance.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="18feb-123">Update 调用</span><span class="sxs-lookup"><span data-stu-id="18feb-123">Update calls</span></span>  
 <span data-ttu-id="18feb-124">Update 函数会导致使用的已更新事实数据进行重新求值的所有规则。</span><span class="sxs-lookup"><span data-stu-id="18feb-124">The Update function causes all the rules using the updated facts to be reevaluated.</span></span> <span data-ttu-id="18feb-125">Update 函数调用可能成本高昂，尤其是当更新事实数据时将被重新计算一大组规则。</span><span class="sxs-lookup"><span data-stu-id="18feb-125">Update function calls can be expensive especially if a large set of rules is reevaluated when updating facts.</span></span> <span data-ttu-id="18feb-126">有些情况下，可以避免此行为。</span><span class="sxs-lookup"><span data-stu-id="18feb-126">There are situations where this behavior can be avoided.</span></span> <span data-ttu-id="18feb-127">例如，请考虑以下规则。</span><span class="sxs-lookup"><span data-stu-id="18feb-127">For example, consider the following rules.</span></span>  
  
 <span data-ttu-id="18feb-128">**规则 1:**</span><span class="sxs-lookup"><span data-stu-id="18feb-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="18feb-129">**规则 2:**</span><span class="sxs-lookup"><span data-stu-id="18feb-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="18feb-130">策略使用的所有其余规则**StatusObj.Flag**在其条件中。</span><span class="sxs-lookup"><span data-stu-id="18feb-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="18feb-131">因此，当**更新**上调用**StatusObj**对象，将重新计算所有规则。</span><span class="sxs-lookup"><span data-stu-id="18feb-131">Therefore, when **Update** is called on the **StatusObj** object, all rules will be reevaluated.</span></span> <span data-ttu-id="18feb-132">任何值**量**字段是，除了**Rule1**或**Rule2**计算两次，一次之前**更新**调用和一次之后**更新**调用。</span><span class="sxs-lookup"><span data-stu-id="18feb-132">Whatever the value of the **Amount** field is, all rules except **Rule1** or **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="18feb-133">若要缓解关联开销，你可以设置的值**标志**字段**false**之前调用策略，然后使用仅**Rule1**在策略中设置标志.</span><span class="sxs-lookup"><span data-stu-id="18feb-133">To mitigate the associated overhead, you could set the value of the **flag** field to **false** prior to invoking the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="18feb-134">在这种情况下，**更新**才会调用的值**量**字段大于 5，并且**更新**如果不调用函数的值**量**小于或等于 5。</span><span class="sxs-lookup"><span data-stu-id="18feb-134">In this case, **Update** would be called only if the value of the **Amount** field is greater than 5, and the **Update** function is not called if the value of **Amount** is less than or equal to 5.</span></span> <span data-ttu-id="18feb-135">因此，所有规则除外**Rule1**或**Rule2**计算两次才的值**量**字段大于 5。</span><span class="sxs-lookup"><span data-stu-id="18feb-135">Therefore, all the rules except **Rule1** or **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="usage-of-logical-or-operators"></a><span data-ttu-id="18feb-136">逻辑 OR 运算符的使用情况</span><span class="sxs-lookup"><span data-stu-id="18feb-136">Usage of logical OR operators</span></span>  
 <span data-ttu-id="18feb-137">在条件中使用越来越多的逻辑 OR 运算符可以创建其他排列，从而扩展规则引擎的分析网络。</span><span class="sxs-lookup"><span data-stu-id="18feb-137">Using an increasing number of logical OR operators in conditions creates additional permutations that expand the analysis network of the rule engine.</span></span> <span data-ttu-id="18feb-138">从性能角度看，您完全了解条件拆分不包含逻辑 OR 运算符的原子规则。</span><span class="sxs-lookup"><span data-stu-id="18feb-138">From a performance standpoint, you are better off splitting the conditions into atomic rules that do not contain logical OR operators.</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="18feb-139">缓存设置</span><span class="sxs-lookup"><span data-stu-id="18feb-139">Caching settings</span></span>  
 <span data-ttu-id="18feb-140">规则引擎使用两个缓存。</span><span class="sxs-lookup"><span data-stu-id="18feb-140">The Rule Engine uses two caches.</span></span> <span data-ttu-id="18feb-141">更新服务使用的第一个和第二个由每个 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="18feb-141">The first one is used by the update service and the second one is used by each BizTalk process.</span></span> <span data-ttu-id="18feb-142">首次使用一个策略，BizTalk 进程从更新服务请求的策略信息。</span><span class="sxs-lookup"><span data-stu-id="18feb-142">The first time a policy is used, the BizTalk process requests the policy information from the update service.</span></span> <span data-ttu-id="18feb-143">更新服务从规则引擎数据库中检索策略信息、 对其进行缓存和将信息返回到 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="18feb-143">The update service retrieves the policy information from the rule engine database, caches it and returns the information to the BizTalk process.</span></span> <span data-ttu-id="18feb-144">BizTalk 进程创建基于该信息的策略对象，并将该策略对象存储在缓存中，相关联的规则引擎实例完成后执行策略。</span><span class="sxs-lookup"><span data-stu-id="18feb-144">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes execution of the policy.</span></span> <span data-ttu-id="18feb-145">再次调用同一个策略时，BizTalk 进程重用缓存中的策略对象，如果有可用。</span><span class="sxs-lookup"><span data-stu-id="18feb-145">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available.</span></span> <span data-ttu-id="18feb-146">同样，如果 BizTalk 进程从更新服务请求有关策略的信息，更新服务将查找其缓存中的策略信息是否可用。</span><span class="sxs-lookup"><span data-stu-id="18feb-146">Similarly, if the BizTalk process requests information about a policy from update service, the update service looks for the policy information in its cache if it is available.</span></span> <span data-ttu-id="18feb-147">每隔 60 秒更新服务还会检查是否已对数据库中的策略的任何更新。</span><span class="sxs-lookup"><span data-stu-id="18feb-147">Every 60 seconds, the update service also checks if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="18feb-148">如果有任何更新，更新服务检索信息，并将缓存的更新的信息。</span><span class="sxs-lookup"><span data-stu-id="18feb-148">If there are any updates, the update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="18feb-149">有三个规则引擎与这些缓存相关的优化参数：**CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="18feb-149">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="18feb-150">在注册表或配置文件中，可以指定这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="18feb-150">You can specify the values for these parameters either in the registry or in a configuration file.</span></span> <span data-ttu-id="18feb-151">值**CacheEntries**参数是在缓存中的最大项数，默认情况下设置为值为 32。</span><span class="sxs-lookup"><span data-stu-id="18feb-151">The value of the **CacheEntries** parameter is the maximum number of entries in the cache and is set to a value of 32 by default.</span></span> <span data-ttu-id="18feb-152">你可能想要增加的价值**CacheEntries**参数，以提高某些方案中的性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-152">You may want to increase the value of the **CacheEntries** parameter to improve performance in certain scenarios.</span></span> <span data-ttu-id="18feb-153">例如，假设重复; 使用 40 个策略可能的值增加**CacheEntries**至 40 以提高性能的参数。</span><span class="sxs-lookup"><span data-stu-id="18feb-153">For example, say you are using 40 policies repeatedly; you could to increase the value of the **CacheEntries** parameter to 40 to improve performance.</span></span> <span data-ttu-id="18feb-154">这将允许更新服务维护的最多 40 个策略在内存中的缓存详细信息。</span><span class="sxs-lookup"><span data-stu-id="18feb-154">This would allow the update service to maintain cache details of up to 40 policies in memory.</span></span>  
  
 <span data-ttu-id="18feb-155">值**CacheTimeout**是以秒为单位的更新服务缓存中维护一个条目的时间。</span><span class="sxs-lookup"><span data-stu-id="18feb-155">The value of **CacheTimeout** is the time in seconds that an entry is maintained in the update service cache.</span></span> <span data-ttu-id="18feb-156">换而言之， **CacheTimeout**值指的多长时间的缓存项的策略不被引用的情况下维护在缓存中。</span><span class="sxs-lookup"><span data-stu-id="18feb-156">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is maintained in the cache without being referenced.</span></span> <span data-ttu-id="18feb-157">默认值**CacheTimeout**参数为 3600 秒或 1 小时。</span><span class="sxs-lookup"><span data-stu-id="18feb-157">The default value of **CacheTimeout** parameter is 3600 seconds, or 1 hour.</span></span> <span data-ttu-id="18feb-158">这意味着如果一小时内未引用的缓存项，则删除该条目。</span><span class="sxs-lookup"><span data-stu-id="18feb-158">It means that if the cache entry is not referenced within an hour, the entry is deleted.</span></span> <span data-ttu-id="18feb-159">在某些情况下，可能会有所帮助增加的价值**CacheTimeout**参数，以提高性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-159">In some cases, it may be beneficial to increase the value of the **CacheTimeout** parameter to improve performance.</span></span> <span data-ttu-id="18feb-160">例如，如果每隔两小时调用策略，策略执行的性能将提高通过增加**CacheTimeout**参数的值大于两小时。</span><span class="sxs-lookup"><span data-stu-id="18feb-160">For example, if a policy is invoked every two hours, performance of the policy execution would be improved by increasing the **CacheTimeout** parameter to a value higher than two hours.</span></span>  
  
 <span data-ttu-id="18feb-161">**PollingInterval**规则引擎的参数以秒为单位的更新服务检查更新的规则引擎数据库中定义的时间。</span><span class="sxs-lookup"><span data-stu-id="18feb-161">The **PollingInterval** parameter of the rule engine defines the time in seconds for the update service to check the rule engine database for updates.</span></span> <span data-ttu-id="18feb-162">默认值为**PollingInterval**参数为 60 秒。</span><span class="sxs-lookup"><span data-stu-id="18feb-162">The default value for the **PollingInterval** parameter is 60 seconds.</span></span> <span data-ttu-id="18feb-163">如果您知道策略不在所有更新或者很少更新，也可以更改此参数为更高版本的值以提高性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-163">If you know that the policies do not get updated at all or are updated rarely, you could change this parameter to a higher value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="18feb-164">SideEffects 属性</span><span class="sxs-lookup"><span data-stu-id="18feb-164">SideEffects property</span></span>  
 <span data-ttu-id="18feb-165">**ClassMemberBinding**， **DatabaseColumnBinding**，并**XmlDocumentFieldBinding**类具有一个名为属性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="18feb-165">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="18feb-166">此属性确定是否缓存绑定的字段、 成员或列的值。</span><span class="sxs-lookup"><span data-stu-id="18feb-166">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="18feb-167">默认值**SideEffects**属性中的**DatabaseColumnBinding**并**XmlDocumentFieldBinding**类是**false**.</span><span class="sxs-lookup"><span data-stu-id="18feb-167">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="18feb-168">默认值**SideEffects**属性中的**ClassMemberBinding**类是**true**。</span><span class="sxs-lookup"><span data-stu-id="18feb-168">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="18feb-169">因此，XML 文档的字段或数据库表的列访问时的第二次或更高版本的策略内，从缓存检索其值。</span><span class="sxs-lookup"><span data-stu-id="18feb-169">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="18feb-170">但是，第二次或更高版本访问.NET 对象的成员时，从.NET 对象，而不是从缓存检索的值。</span><span class="sxs-lookup"><span data-stu-id="18feb-170">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="18feb-171">设置**SideEffects**的.NET 属性**ClassMemberBinding**到**false**会提高性能，因为从缓存中检索的字段的值第二次及更高版本。</span><span class="sxs-lookup"><span data-stu-id="18feb-171">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="18feb-172">您可以仅执行此操作以编程方式。</span><span class="sxs-lookup"><span data-stu-id="18feb-172">You can only do this programmatically.</span></span> <span data-ttu-id="18feb-173">业务规则编辑器工具不会公开**SideEffects**属性。</span><span class="sxs-lookup"><span data-stu-id="18feb-173">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="18feb-174">Instances 和 selectivity</span><span class="sxs-lookup"><span data-stu-id="18feb-174">Instances and selectivity</span></span>  
 <span data-ttu-id="18feb-175">**XmlDocumentBinding**， **ClassBinding**，并**DatabaseBinding**类具有两个属性：**实例**并**选择性**。</span><span class="sxs-lookup"><span data-stu-id="18feb-175">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="18feb-176">实例的值为预期的工作内存中的类的实例数。</span><span class="sxs-lookup"><span data-stu-id="18feb-176">The value of Instances is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="18feb-177">值**选择性**是成功传递规则条件的类实例的百分比。</span><span class="sxs-lookup"><span data-stu-id="18feb-177">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="18feb-178">规则引擎使用这些值来优化条件评估，以便在条件计算中首次使用最少可能实例，然后使用剩余的实例。</span><span class="sxs-lookup"><span data-stu-id="18feb-178">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="18feb-179">如果您有经验的对象的实例数，则将设置**实例**属性设置为该值也会提高性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-179">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="18feb-180">同样，如果必须预先知道满足条件这些对象的百分比，则设置**选择性**属性设置为该值也会提高性能。</span><span class="sxs-lookup"><span data-stu-id="18feb-180">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="18feb-181">只能以编程方式设置这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="18feb-181">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="18feb-182">业务规则编辑器工具不公开它们。</span><span class="sxs-lookup"><span data-stu-id="18feb-182">The Business Rule Composer tool does not expose them.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="18feb-183">请参阅</span><span class="sxs-lookup"><span data-stu-id="18feb-183">See Also</span></span>  
 [<span data-ttu-id="18feb-184">优化 BizTalk Server 性能</span><span class="sxs-lookup"><span data-stu-id="18feb-184">Optimizing BizTalk Server Performance</span></span>](../technical-guides/optimizing-biztalk-server-performance.md)