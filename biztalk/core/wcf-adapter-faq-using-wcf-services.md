---
title: WCF 适配器常见问题： 使用 WCF 服务 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: befa2268-8a65-465f-8086-70a66808845e
caps.latest.revision: ''
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 41d02fe0b7be1f53edaac4c18cfd7717a25c3a71
ms.sourcegitcommit: 8418b1a8f38b7f56979cd6e203f0b591e2f40fe1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/23/2018
---
# <a name="wcf-adapter-faq-using-wcf-services"></a><span data-ttu-id="751af-102">WCF 适配器常见问题解答：使用 WCF 服务</span><span class="sxs-lookup"><span data-stu-id="751af-102">WCF Adapter FAQ: Using WCF Services</span></span>
## <a name="how-does-biztalk-server-use-its-wcf-adapters-to-access-wcf-services"></a><span data-ttu-id="751af-103">BizTalk Server 如何使用其 WCF 适配器访问 WCF 服务？</span><span class="sxs-lookup"><span data-stu-id="751af-103">How does BizTalk Server use its WCF adapters to access WCF services?</span></span>  
 <span data-ttu-id="751af-104">BizTalk WCF 适配器在 BizTalk Server 中通过 WCF 接收位置或发送端口进行配置。</span><span class="sxs-lookup"><span data-stu-id="751af-104">BizTalk WCF adapters are configured in BizTalk Server through either a WCF receive location or a send port.</span></span> <span data-ttu-id="751af-105">当启用使用 WCF 适配器的接收位置时，将为每个接收位置实例化并初始化一个 ServiceHost 实例。</span><span class="sxs-lookup"><span data-stu-id="751af-105">When a receive location using a WCF adapter is enabled, a single ServiceHost instance is instantiated and initialized for each receive location.</span></span> <span data-ttu-id="751af-106">ServiceHost 运行一个接受传入 WCF 消息的通用服务，然后在将这些消息发布到 BizTalk MessageBox 数据库之前将其转换为 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="751af-106">The ServiceHost runs a generic service that accepts incoming WCF messages, and converts them to BizTalk messages before publishing them to the BizTalk MessageBox database.</span></span> <span data-ttu-id="751af-107">通用 ServiceHost 服务处于 WCF BizTalk 接收适配器实现内部，并公开一个无类型的协定。</span><span class="sxs-lookup"><span data-stu-id="751af-107">The generic ServiceHost service is internal to the WCF BizTalk receive adapter implementation and exposes a typeless contract.</span></span> <span data-ttu-id="751af-108">在 WCF 中，一个无类型协定由操作签名组成，它们采用类型为 WCF System.ServiceModel.Channel.Message 的一个参数。</span><span class="sxs-lookup"><span data-stu-id="751af-108">In WCF, a typeless contract consists of operation signatures that take a single parameter of type WCF System.ServiceModel.Channel.Message.</span></span>  
  
 <span data-ttu-id="751af-109">如果 WCF 服务将由 BizTalk 发送端口访问，即便无数据返回，也应将 WCF 服务的操作标记为 IsOneWay=false。</span><span class="sxs-lookup"><span data-stu-id="751af-109">The operation  of a WCF service should be marked as IsOneWay=false if they are to be accessed by a BizTalk send port even if there is no data to return.</span></span> <span data-ttu-id="751af-110">客户端协定上的操作应使用 IsOneWay=false 和 ReplyAction=”\*” 进行批注。</span><span class="sxs-lookup"><span data-stu-id="751af-110">The operations on the client-side contract should be annotated with IsOneWay=false and ReplyAction=”\*”.</span></span>  <span data-ttu-id="751af-111">此外，来自客户端的所有调用都应标记为 IsOneWay=”false”。</span><span class="sxs-lookup"><span data-stu-id="751af-111">Additionally all calls from the client should be marked at IsOneWay=”false”.</span></span> <span data-ttu-id="751af-112">双向服务操作可以返回的消息类型的值。</span><span class="sxs-lookup"><span data-stu-id="751af-112">A two-way service operation may return a value of type Message.</span></span> <span data-ttu-id="751af-113">此规则的例外使用 WCF NetMsmq 适配器，因为它会执行将消息发送到 MSMQ 队列的单向操作。</span><span class="sxs-lookup"><span data-stu-id="751af-113">The exception to this is using the WCF-NetMsmq adapter since it executes a one-way operation that posts a message into an MSMQ queue.</span></span> <span data-ttu-id="751af-114">在这种情况下，发送端口可以是单向的，并且任何服务操作可标记为 IsOneWay=true。</span><span class="sxs-lookup"><span data-stu-id="751af-114">In this case the send port can be one-way and any service operation marked as IsOneWay=true.</span></span>  
  
 <span data-ttu-id="751af-115">还可以在 WCF 中的实际返回空值的方法上定义 isOneWay=false OperationContract，这可能有点令人困惑。</span><span class="sxs-lookup"><span data-stu-id="751af-115">It may be a little confusing that it is also possible in WCF to define an isOneWay=false OperationContract on a method that actually returns void.</span></span> <span data-ttu-id="751af-116">在这种情况下，实际上会在网络上返回一个由 WCF 运行时为您创建的消息。</span><span class="sxs-lookup"><span data-stu-id="751af-116">In such a situation there is actually a message returned on the wire created by the WCF runtime for you.</span></span>  
  
 <span data-ttu-id="751af-117">BizTalk WCF 适配器将使用此功能。</span><span class="sxs-lookup"><span data-stu-id="751af-117">The BizTalk WCF adapters make use of this feature.</span></span> <span data-ttu-id="751af-118">当您指定单向 BizTalk 端口时，实际上会获得一个在 WCF 适配器实现中 isOneWay=false 的空方法。</span><span class="sxs-lookup"><span data-stu-id="751af-118">When you specify a one-way BizTalk port you actually get a void method with isOneWay=false within the implementation of the WCF adapter.</span></span> <span data-ttu-id="751af-119">关键是，在使用直接通道（如 HTTP 或 net.tcp）时，BizTalk 单向端口实际将对应 isOneWay=false OperationContract。</span><span class="sxs-lookup"><span data-stu-id="751af-119">The point is that a BizTalk one-way port, when using a direct channel such as HTTP or net.tcp, will actually correspond to an isOneWay=false OperationContract.</span></span> <span data-ttu-id="751af-120">列队通道（如 net.msmq）的不同之处在于，单向 BizTalk 端口确实会设置为 isOneWay=true OperationContract。</span><span class="sxs-lookup"><span data-stu-id="751af-120">Queued channels such as net.msmq are different in that a one-way BizTalk port does happen to talk to an isOneWay=true OperationContract.</span></span> <span data-ttu-id="751af-121">情况不同是因为，WCF 调度程序针对该通道使用一个事务。</span><span class="sxs-lookup"><span data-stu-id="751af-121">The situation is different because the WCF dispatcher is using a transaction against the channel.</span></span>  
  
## <a name="how-do-you-create-and-use-a-custom-binding-with-a-wcf-custom-adapter"></a><span data-ttu-id="751af-122">你如何创建和自定义绑定中使用 WCF 自定义适配器？</span><span class="sxs-lookup"><span data-stu-id="751af-122">How do you create and use a custom binding with a WCF custom adapter?</span></span>  
 <span data-ttu-id="751af-123">WCF CustomBinding 包含的绑定元素集合。</span><span class="sxs-lookup"><span data-stu-id="751af-123">A WCF CustomBinding consists of a collection of BindingElements.</span></span> <span data-ttu-id="751af-124">CustomBinding 可通过汇集已存在的 BindingElement 来创建（例如，将已存在的“传输”和另一个源中已存在的“编码器”合并）。</span><span class="sxs-lookup"><span data-stu-id="751af-124">A CustomBinding can be created by pulling together pre-existing BindingElements (for example, combining a pre-existing Transport with a pre-existing Encoder from another source).</span></span> <span data-ttu-id="751af-125">或者，可以通过结合使用新编写的自定义 BindingElement 预先存在 BindingElement 创建它。</span><span class="sxs-lookup"><span data-stu-id="751af-125">Or it can be created by combining a pre-existing BindingElement with a newly written custom BindingElement.</span></span> <span data-ttu-id="751af-126">在代码中 CustomBinding 可以从这些组件绑定元素生成通过以编程方式添加它们。</span><span class="sxs-lookup"><span data-stu-id="751af-126">In code a CustomBinding can be built from these component BindingElements by adding them programmatically.</span></span> <span data-ttu-id="751af-127">WCF 还允许这种结构通过.NET 配置 （配置文件）。</span><span class="sxs-lookup"><span data-stu-id="751af-127">WCF also allows this construction through .NET Configuration (config files).</span></span> <span data-ttu-id="751af-128">使用 BizTalk Server 可以通过 BizTalk WCF 自定义适配器创建此 CustomBinding。</span><span class="sxs-lookup"><span data-stu-id="751af-128">By using BizTalk Server this CustomBinding can be created through the BizTalk WCF Custom adapter.</span></span>  
  
 <span data-ttu-id="751af-129">BizTalk WCF 自定义适配器不仅允许你从绑定元素生成一个新的绑定，而且还可以在配置新的绑定直接。</span><span class="sxs-lookup"><span data-stu-id="751af-129">The BizTalk WCF Custom adapter not only allows you to build a new binding from BindingElements but also lets you configure a new binding directly.</span></span> <span data-ttu-id="751af-130">它还允许你配置标准绑定上的行为。</span><span class="sxs-lookup"><span data-stu-id="751af-130">It also allows you to configure behaviors on standard bindings.</span></span> <span data-ttu-id="751af-131">这是特别有用，因为编写自定义行为是比写入新的绑定元素对象容易得多。</span><span class="sxs-lookup"><span data-stu-id="751af-131">This is particularly useful because writing custom behaviors is much easier than writing new BindingElements objects.</span></span>  
  
 <span data-ttu-id="751af-132">生成 BindingElement 是一项涉及的开发任务和它的引用的最佳来源是 WCF 示例在超链接"http://go.microsoft.com/fwlink/?LinkId=142449"\t"_blank" http://go.microsoft.com/fwlink/?LinkId=142449。</span><span class="sxs-lookup"><span data-stu-id="751af-132">Building a BindingElement is an involved development exercise and the best source of reference for it is the WCF samples at  HYPERLINK "http://go.microsoft.com/fwlink/?LinkId=142449" \t "_blank" http://go.microsoft.com/fwlink/?LinkId=142449.</span></span> <span data-ttu-id="751af-133">若要创建自定义 BindingElement 你创建自 BindingElement 派生的类。</span><span class="sxs-lookup"><span data-stu-id="751af-133">To create a custom BindingElement you create a class that derives from BindingElement.</span></span> <span data-ttu-id="751af-134">新 BindingElement 将一定要处于新的程序集。</span><span class="sxs-lookup"><span data-stu-id="751af-134">A new BindingElement will have to be in a new assembly.</span></span> <span data-ttu-id="751af-135">此程序集必须安装到全局程序集缓存 (GAC) 的管理计算机 BizTalk 主机中，发送端口，并且接收位置的配置。</span><span class="sxs-lookup"><span data-stu-id="751af-135">This assembly must be installed into the Global Assembly Cache (GAC) of the administration computer where the BizTalk Host, send port, and receive location are configured.</span></span> <span data-ttu-id="751af-136">若要将自定义绑定与特定发送端口相关联或接收位置时，首先需要将其添加到\<bindingElementExtensions\>的同一台计算机上的 machine.config 文件的部分。</span><span class="sxs-lookup"><span data-stu-id="751af-136">To associate a custom binding with a specific send port or receive location, you first need to add it to the \<bindingElementExtensions\> section of the machine.config file on the same computer.</span></span>  
  
 <span data-ttu-id="751af-137">建立你然后可以显示所做的更改后 **传输属性配置** 对话框中，将绑定配置。</span><span class="sxs-lookup"><span data-stu-id="751af-137">After making that change you can then bring up the **Transport Properties Configuration** dialog box to configure the binding.</span></span>  
  
1.  <span data-ttu-id="751af-138">上 **绑定** 选项卡上，对于绑定类型，选择 **customBinding**。</span><span class="sxs-lookup"><span data-stu-id="751af-138">On the **Binding** tab, for Binding type, select **customBinding**.</span></span>  
  
2.  <span data-ttu-id="751af-139">在 **绑定** 窗格中，右键单击 **CustomBindingElement**, ，然后选择 **添加扩展**。</span><span class="sxs-lookup"><span data-stu-id="751af-139">In the **Binding** pane, right-click **CustomBindingElement**, and select **Add Extension**.</span></span>  
  
3.  <span data-ttu-id="751af-140">选择你在 machine.config 文件中指定的绑定元素，并根据需要配置绑定。</span><span class="sxs-lookup"><span data-stu-id="751af-140">Select the binding element you specified in the machine.config file and configure the binding as required.</span></span> <span data-ttu-id="751af-141">现在已准备好用于消息传输或接收。</span><span class="sxs-lookup"><span data-stu-id="751af-141">It is now ready to use for message transmission or receipt.</span></span>  
  
 <span data-ttu-id="751af-142">在这种方式添加后，BizTalk 会进行自定义绑定的非常有限的验证。</span><span class="sxs-lookup"><span data-stu-id="751af-142">BizTalk does very limited validation for a custom binding when it has been added in this manner.</span></span> <span data-ttu-id="751af-143">因此，务必确保按正确的顺序列出的绑定元素。</span><span class="sxs-lookup"><span data-stu-id="751af-143">Therefore, it is important to ensure the binding elements are listed in the correct order.</span></span> <span data-ttu-id="751af-144">在运行时第一次调用所需的绑定元素必须 CustomBindingElement 绑定树在对话框中底部。</span><span class="sxs-lookup"><span data-stu-id="751af-144">The binding element you want invoked first at runtime must be on the bottom of the CustomBindingElement binding tree in the dialog box.</span></span> <span data-ttu-id="751af-145">绑定元素的列表必须包含一个传输协议和该传输协议必须为列表的底部。</span><span class="sxs-lookup"><span data-stu-id="751af-145">The list of BindingElements must contain a Transport and that Transport must be at the bottom of the list.</span></span> <span data-ttu-id="751af-146">BindingElement 集还可能包含“编码器”。</span><span class="sxs-lookup"><span data-stu-id="751af-146">The set of BindingElements may also contain an Encoder.</span></span> <span data-ttu-id="751af-147">详细信息，请参阅 WCF 文档上绑定元素在[ http://go.microsoft.com/fwlink/?LinkId=142449 ](http://go.microsoft.com/fwlink/?LinkId=142449)。</span><span class="sxs-lookup"><span data-stu-id="751af-147">For more information, see the WCF documentation on binding elements at [http://go.microsoft.com/fwlink/?LinkId=142449](http://go.microsoft.com/fwlink/?LinkId=142449).</span></span>  
  
## <a name="what-is-a-wcf-custom-behavior-and-how-do-i-use-one-with-biztalk-server"></a><span data-ttu-id="751af-148">如何使用一个与 BizTalk Server 和 WCF 自定义行为是什么？</span><span class="sxs-lookup"><span data-stu-id="751af-148">What is a WCF custom behavior and how do I use one with BizTalk Server?</span></span>  
 <span data-ttu-id="751af-149">使用 WCF 消息通信机制的优势之一是通过使用自定义代码来扩展其服务的功能的机会。</span><span class="sxs-lookup"><span data-stu-id="751af-149">One of the advantages of using WCF as a message communication mechanism is the opportunity to extend the functionality of its services by using custom code.</span></span> <span data-ttu-id="751af-150">自定义行为扩展是一个将 WCF 与其他市场中的 Web 服务技术区分开来的功能。</span><span class="sxs-lookup"><span data-stu-id="751af-150">Custom behavior extensions are one of the features that differentiate WCF from other Web services technologies in the market.</span></span>  
  
 <span data-ttu-id="751af-151">没有在 WCF 消息截获和执行自定义处理一条消息到达其最终目标之前的流中的不同点。</span><span class="sxs-lookup"><span data-stu-id="751af-151">There are different points within the flow of a WCF message to intercept and execute custom processing before a message reaches its final destination.</span></span> <span data-ttu-id="751af-152">WCF 自定义行为扩展都是一个此类类型的截获机制，可用于扩展在不同的粒度级别的 WCF 服务或客户端功能。</span><span class="sxs-lookup"><span data-stu-id="751af-152">WCF custom behavior extensions are one such type of interception mechanism and can be used to extend WCF service or client functionality at different levels of granularity.</span></span> <span data-ttu-id="751af-153">在 WCF 服务和客户端级别可以存在自定义行为扩展。</span><span class="sxs-lookup"><span data-stu-id="751af-153">Custom behavior extensions can exist at both the WCF service and client levels.</span></span> <span data-ttu-id="751af-154">配置到 WCF 服务调用堆栈上的行为没有任何影响用于发起呼叫的通信绑定。</span><span class="sxs-lookup"><span data-stu-id="751af-154">Configuring a behavior on the call stack to a WCF service has no influence on the communication binding used to make the call.</span></span> <span data-ttu-id="751af-155">事实上，行为是对客户端通常不可见，因为它们不会显示在服务发布的元数据。</span><span class="sxs-lookup"><span data-stu-id="751af-155">In fact, behaviors are typically invisible to the client because they are not displayed in the metadata a service publishes.</span></span> <span data-ttu-id="751af-156">客户端通常具有不知道在对 WCF 操作的调用期间执行行为。</span><span class="sxs-lookup"><span data-stu-id="751af-156">The client typically has no idea that the behaviors are executing during a call to a WCF operation.</span></span>  
  
 <span data-ttu-id="751af-157">相比其他在 Web 应用程序之间通信的方式，在调用 WCF 服务中轻松实现自定义处理的能力是 WCF 为何是一个如此丰富的编程范例的主要原因之一。</span><span class="sxs-lookup"><span data-stu-id="751af-157">The ability to easily implement custom processing in a call to a WCF service is one of the main reasons why WCF is such a rich programming paradigm compared to other ways of communication between Web applications.</span></span> <span data-ttu-id="751af-158">此自定义处理几乎可以采取 Web 应用程序内扩展性要求规定的任何格式。</span><span class="sxs-lookup"><span data-stu-id="751af-158">This custom processing can take almost any form as dictated by extensibility requirements within a Web application.</span></span> <span data-ttu-id="751af-159">开发人员可以创建检查和验证服务配置的自定义扩展，或修改在 WCF 客户端和服务应用程序中的运行时行为。</span><span class="sxs-lookup"><span data-stu-id="751af-159">Developers can create custom extensions that inspect and validate service configuration or modify runtime behavior in WCF client and service applications.</span></span> <span data-ttu-id="751af-160">行为可以补充正常消息处理、 在处理过程中修改消息、 仔细检查特定配置条件和采取适当的措施，验证调用方的标识和可以将消息传递是否成功等。因为真正是一个自定义处理机制实现任何扩展性需要你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="751af-160">Behaviors can supplement normal message processing, modify the message during processing, scrutinize certain configuration criteria and take appropriate action, validate identities of the caller and pass the message on if it is successful, etc. Because it is truly a custom processing mechanism you implement whatever extensibility your application needs.</span></span>  
  
 <span data-ttu-id="751af-161">若要在 BizTalk Server 中使用 WCF 自定义行为将配置使用它 **行为** 接收位置或发送端口的 WCF 自定义或 WCF CustomIsolated 适配器的选项卡。</span><span class="sxs-lookup"><span data-stu-id="751af-161">To use a WCF custom behavior in BizTalk Server you will configure it by using the **Behavior** tab for the WCF-Custom or WCF-CustomIsolated adapter for a receive location or a send port.</span></span>