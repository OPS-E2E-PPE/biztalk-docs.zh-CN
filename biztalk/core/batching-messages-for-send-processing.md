---
title: 批处理消息发送处理 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 7d9115ec-13bc-41a8-8928-57b168c95af4
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e87600bec54679688fae5084af3b4a1bde9ca807
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
ms.locfileid: "22232453"
---
# <a name="batching-messages-for-send-processing"></a><span data-ttu-id="b8e50-102">对消息进行批处理的发送处理</span><span class="sxs-lookup"><span data-stu-id="b8e50-102">Batching Messages for Send Processing</span></span>
## <a name="send-adapter-batch-management"></a><span data-ttu-id="b8e50-103">发送适配器批的管理</span><span class="sxs-lookup"><span data-stu-id="b8e50-103">Send Adapter Batch Management</span></span>  
 <span data-ttu-id="b8e50-104">在发送端使用事务时，由 BizTalk Server 创建的用于发送到目标系统的相同事务在成功发送后，将用于删除相应消息。</span><span class="sxs-lookup"><span data-stu-id="b8e50-104">When using transactions on the send side, the same transaction created by BizTalk Server and used for sending to the target system is used for the corresponding message deletion once it has been sent successfully.</span></span> <span data-ttu-id="b8e50-105">如果其中有任何步骤失败，则事务将结束，在这种情况下将中止删除操作，数据仍保留在 BizTalk Server 中，而不在目标系统中。</span><span class="sxs-lookup"><span data-stu-id="b8e50-105">If anything fails, the transaction can be ended, in which case the deletion is aborted, and the data remains in BizTalk Server and not in the target system.</span></span> <span data-ttu-id="b8e50-106">这可以防止消息重复。</span><span class="sxs-lookup"><span data-stu-id="b8e50-106">This prevents duplication of messages.</span></span> <span data-ttu-id="b8e50-107">只有异步发送适配器才支持事务。</span><span class="sxs-lookup"><span data-stu-id="b8e50-107">Transactions are only supported for asynchronous send adapters.</span></span> <span data-ttu-id="b8e50-108">不应该将事务与同步发送适配器一起使用。</span><span class="sxs-lookup"><span data-stu-id="b8e50-108">You should not use transactions with synchronous send adapters.</span></span>  
  
 <span data-ttu-id="b8e50-109">但是适配器不能只结束事务，它还必须能够正确处理给出的消息状态。</span><span class="sxs-lookup"><span data-stu-id="b8e50-109">But the adapter cannot just end the transaction; it must also handle correctly the state of the messages it was given.</span></span> <span data-ttu-id="b8e50-110">具体而言，该适配器应调用方法**重新提交**， **MoveToNextTransport**，和**MoveToSuspendQ**适当地取决于重试计数和是否备份传输是可用的。</span><span class="sxs-lookup"><span data-stu-id="b8e50-110">Specifically, the adapter should call the methods **Resubmit**, **MoveToNextTransport**, and **MoveToSuspendQ** appropriately depending upon the retry count and whether a backup transport is available.</span></span>  
  
 <span data-ttu-id="b8e50-111">务必要放置**删除**和**SubmitResponse**一起使用同一个事务的批处理中的操作。</span><span class="sxs-lookup"><span data-stu-id="b8e50-111">It is important to place the **Delete** and **SubmitResponse** operations together in a batch that uses the same transaction.</span></span> <span data-ttu-id="b8e50-112">失败将通过结束事务来进行处理，以来确保数据仅向外部系统提交一次。</span><span class="sxs-lookup"><span data-stu-id="b8e50-112">Failure is handled by ending the transaction (to ensure that data is only submitted once to an external system).</span></span> <span data-ttu-id="b8e50-113">但你仍想要重新提交，或者调用**MoveToNextTransport**开机 BizTalk Server 消息。</span><span class="sxs-lookup"><span data-stu-id="b8e50-113">But you still want to resubmit or call **MoveToNextTransport** for the message back on BizTalk Server.</span></span> <span data-ttu-id="b8e50-114">为此，对于这些类型的操作，请使用单独的普通批（非事务批）。</span><span class="sxs-lookup"><span data-stu-id="b8e50-114">To do this, use a separate normal (non-transactional) batch for these types of operations.</span></span>  
  
 <span data-ttu-id="b8e50-115">下图显示了如何为响应消息使用单独的批。</span><span class="sxs-lookup"><span data-stu-id="b8e50-115">The following figure shows the use of separate batches for response messages.</span></span>  
  
 <span data-ttu-id="b8e50-116">![响应消息中使用单独的批](../core/media/eawp-seperatebatch.gif "EAWP_SeperateBatch")</span><span class="sxs-lookup"><span data-stu-id="b8e50-116">![Using a seperate batch for response messages](../core/media/eawp-seperatebatch.gif "EAWP_SeperateBatch")</span></span>  
  
## <a name="sorting-the-send-side-transactional-batches-by-endpoint"></a><span data-ttu-id="b8e50-117">按终结点对发送端事务批进行分类</span><span class="sxs-lookup"><span data-stu-id="b8e50-117">Sorting the Send-Side Transactional Batches by Endpoint</span></span>  
 <span data-ttu-id="b8e50-118">由 BizTalk Server 发送到适配器的消息批可以跨多个发送端口（或终结点）。</span><span class="sxs-lookup"><span data-stu-id="b8e50-118">Batches of messages sent by BizTalk Server to the adapter can span multiple send ports (or endpoints).</span></span> <span data-ttu-id="b8e50-119">因为适配器通常想要有为单个终结点的事务，适配器必须排序基于发送端口的消息 (**SPName**或**OutboundTransportLocation**)。</span><span class="sxs-lookup"><span data-stu-id="b8e50-119">Because the adapter typically wants to have a transaction to a single endpoint, the adapter must sort the messages based on send port (**SPName** or **OutboundTransportLocation**).</span></span> <span data-ttu-id="b8e50-120">通过执行此操作，适配器可以创建仅跨越特定发送端口的事务。</span><span class="sxs-lookup"><span data-stu-id="b8e50-120">By doing this, the adapter can create a transaction that spans only a particular send port.</span></span>  
  
 <span data-ttu-id="b8e50-121">例如，当 FTP 发送适配器接收一个来自 BizTalk Server 的消息批时，它得到的是一个混合的消息批，这些消息来自所有当前活动的 FTP 发送端口。</span><span class="sxs-lookup"><span data-stu-id="b8e50-121">For example, when an FTP send adapter receives a batch of messages from BizTalk Server, it gets a mixed batch of messages for all the currently active FTP send ports.</span></span> <span data-ttu-id="b8e50-122">发生这种情况的原因是 API 是基于单一的接口，这意味着只能加载单个 FTP 适配器，而不能每个发送端口都加载一个。</span><span class="sxs-lookup"><span data-stu-id="b8e50-122">This happens because the API is singleton based, meaning that only a single FTP adapter is loaded, not one per send port.</span></span>  
  
 <span data-ttu-id="b8e50-123">适配器必须首先将 BizTalk Server 传来的消息批分类为单独的批，即每个终结点一个批次。</span><span class="sxs-lookup"><span data-stu-id="b8e50-123">The adapter must first sort the batch of messages it was given by BizTalk Server into separate batches, one for each endpoint.</span></span> <span data-ttu-id="b8e50-124">然后它可以轮流处理每个终结点，并可以构造每个终结点的删除批。</span><span class="sxs-lookup"><span data-stu-id="b8e50-124">Then it can deal with each endpoint in turn and will probably construct delete batches for each endpoint.</span></span> <span data-ttu-id="b8e50-125">SDK 示例代码中的 BaseAdapter 可重用泛型类以同样的方式运行。</span><span class="sxs-lookup"><span data-stu-id="b8e50-125">The BaseAdapter generic reusable classes in the SDK sample code work in the same way.</span></span>  
  
## <a name="sorting-for-dynamic-send"></a><span data-ttu-id="b8e50-126">为动态发送分类</span><span class="sxs-lookup"><span data-stu-id="b8e50-126">Sorting for Dynamic Send</span></span>  
 <span data-ttu-id="b8e50-127">只要 BizTalk Server 业务流程在消息头和 URL 本身中提供足够的配置详细信息，它就可以将消息发送到尚未配置的端口。</span><span class="sxs-lookup"><span data-stu-id="b8e50-127">A BizTalk Server orchestration can send a message to a port that has not been configured as long as it provides sufficient configuration details in the message header and in the URL itself.</span></span> <span data-ttu-id="b8e50-128">因此 BizTalk Server 必须能够识别 URL 协议。</span><span class="sxs-lookup"><span data-stu-id="b8e50-128">BizTalk Server must recognize the protocol of the URL.</span></span>  
  
 <span data-ttu-id="b8e50-129">将消息分类时，应该谨慎建立定义终结点的内容。</span><span class="sxs-lookup"><span data-stu-id="b8e50-129">When sorting messages, you should take care to establish what defines an endpoint.</span></span> <span data-ttu-id="b8e50-130">这在动态发送的情况下更是如此。</span><span class="sxs-lookup"><span data-stu-id="b8e50-130">This is especially true in the case of a dynamic send.</span></span> <span data-ttu-id="b8e50-131">如果只是用 URI 定义终结点，问题就简单了。</span><span class="sxs-lookup"><span data-stu-id="b8e50-131">If only the URI defines the endpoint, then things are simple.</span></span> <span data-ttu-id="b8e50-132">但是，在 FTP 会话中，FTP 服务器可能使用用户名登录详细信息来定义真正的终结点。</span><span class="sxs-lookup"><span data-stu-id="b8e50-132">However, in an FTP session the user name logon details might be used by the FTP server to define the true endpoint.</span></span> <span data-ttu-id="b8e50-133">在这种情况下，如果适配器以不同的帐户登录，则它可能会被连接到不同的目录。</span><span class="sxs-lookup"><span data-stu-id="b8e50-133">In this case, if the adapter logs in as a different account, it may be connected to a different directory.</span></span>  
  
 <span data-ttu-id="b8e50-134">在某些情况下，true 终结点，直到才知道你具有运行企业单一登录 (SSO) 命令**ValidateAndRedeemTicket**。</span><span class="sxs-lookup"><span data-stu-id="b8e50-134">In some cases, the true endpoint is not known until you have run the Enterprise Single Sign-On (SSO) command **ValidateAndRedeemTicket**.</span></span>  
  
 <span data-ttu-id="b8e50-135">对于 MQSeries，是否决定使用事务是可配置的。</span><span class="sxs-lookup"><span data-stu-id="b8e50-135">In the case of MQSeries, the determination of whether to use transactions is configurable.</span></span> <span data-ttu-id="b8e50-136">在确定远程 COM+ 对象的结构和用途后，最好将事务性终结点看作是与非事务性终结点完全不同的终结点。</span><span class="sxs-lookup"><span data-stu-id="b8e50-136">Given the architecture and the use of a remote COM+ object, it is best to regard a transactional endpoint as distinct from a non-transactional endpoint.</span></span>  
  
 <span data-ttu-id="b8e50-137">总而言之，将消息分类到其单个终结点批中有时是一项非常重要的任务，可能会涉及到一些额外步骤，如考虑上下文值，甚至是考虑 SSO 的调用结果。</span><span class="sxs-lookup"><span data-stu-id="b8e50-137">To summarize, sorting messages into their single endpoint batches is sometimes a nontrivial task and may involve such extra steps as considering the context values and even the result of a call to SSO.</span></span>  
  
## <a name="sorting-for-static-send"></a><span data-ttu-id="b8e50-138">为静态发送分类</span><span class="sxs-lookup"><span data-stu-id="b8e50-138">Sorting for Static Send</span></span>  
 <span data-ttu-id="b8e50-139">如果终结点是静态配置的终结点，则在消息上下文中有一个叫作静态端口 ID (SPID) 的唯一 GUID。</span><span class="sxs-lookup"><span data-stu-id="b8e50-139">If the endpoint is a statically configured endpoint there is a unique GUID on the message context called the static port ID (SPID).</span></span> <span data-ttu-id="b8e50-140">此值可用于对终结点进行分类。</span><span class="sxs-lookup"><span data-stu-id="b8e50-140">This value can be used for sorting the endpoint.</span></span> <span data-ttu-id="b8e50-141">以下代码可用于检索该 GUID：</span><span class="sxs-lookup"><span data-stu-id="b8e50-141">The following code can be used to retrieve it:</span></span>  
  
```  
string spid = (string)message.Context.Read("SPID", "http://schemas.microsoft.com/BizTalk/2003/system-properties");  
```  
  
 <span data-ttu-id="b8e50-142">当考虑由基于 XML 架构定义 (XSD) 的配置框架引起的问题时，这是很有帮助的。</span><span class="sxs-lookup"><span data-stu-id="b8e50-142">This is helpful when you consider the problems introduced by the XML Schema Definition (XSD)-based configuration framework.</span></span> <span data-ttu-id="b8e50-143">在此框架中，有一个可能是终结点键一部分的属性隐藏在单个上下文属性的 XML 中。</span><span class="sxs-lookup"><span data-stu-id="b8e50-143">With this framework, you have a property that might be part of the endpoint key buried inside XML in a single context property.</span></span> <span data-ttu-id="b8e50-144">如果在该上下文中有 SPID，就可以使用它作为将批分类的一种方法。</span><span class="sxs-lookup"><span data-stu-id="b8e50-144">If you have a SPID on the context, you can use that as a way to sort the batch.</span></span> <span data-ttu-id="b8e50-145">否则就是在执行动态发送，需要构造一个用来将批分类的备用键。</span><span class="sxs-lookup"><span data-stu-id="b8e50-145">Otherwise you are doing a dynamic send and you need to construct an alternative key with which to sort the batch.</span></span>  
  
 <span data-ttu-id="b8e50-146">下图显示了如何按终结点对消息进行分类。</span><span class="sxs-lookup"><span data-stu-id="b8e50-146">The following figure shows message sorting by endpoint.</span></span>  
  
 <span data-ttu-id="b8e50-147">![终结点排序消息](../core/media/eawp-sortbatch.gif "EAWP_SortBatch")</span><span class="sxs-lookup"><span data-stu-id="b8e50-147">![Sorting messages by endpoint](../core/media/eawp-sortbatch.gif "EAWP_SortBatch")</span></span>  
  
 <span data-ttu-id="b8e50-148">请注意，消息的重试次数与批的成功与否无关。</span><span class="sxs-lookup"><span data-stu-id="b8e50-148">Remember that the retry count of a message is not aware of the success or failure of a batch.</span></span> <span data-ttu-id="b8e50-149">在发送端，消息批可能会由于批中的几个消息失败而失败。</span><span class="sxs-lookup"><span data-stu-id="b8e50-149">On the send side, a batch of messages may fail because a few messages in the batch have failed.</span></span> <span data-ttu-id="b8e50-150">适配器必须决定如何处理它接收到的每个消息。</span><span class="sxs-lookup"><span data-stu-id="b8e50-150">The adapter must make a determination for every message that it receives.</span></span> <span data-ttu-id="b8e50-151">在批失败的情况下，可以假定每个消息都被重新提交了。</span><span class="sxs-lookup"><span data-stu-id="b8e50-151">In the failed batch scenario, you might assume that every message is resubmitted.</span></span> <span data-ttu-id="b8e50-152">但是，如果失败批中的所有消息都重新提交了，则对于成功的消息，重试次数（由 BizTalk Server 引擎维护）也将不正确地递增，这是因为这些成功的消息恰好与失败的消息在同一批中。</span><span class="sxs-lookup"><span data-stu-id="b8e50-152">However, if all the messages in a failing batch are resubmitted, the retry count (which is maintained by the BizTalk Server engine) is incorrectly incremented even for the successful messages because they happen to be in the same batch as the failed messages.</span></span> <span data-ttu-id="b8e50-153">在这种情况下，适配器可以重新形成出站批，并针对外部系统重试成功的消息。</span><span class="sxs-lookup"><span data-stu-id="b8e50-153">In this case, an adapter could reform the outbound batch and retry the successful messages against the external system.</span></span>