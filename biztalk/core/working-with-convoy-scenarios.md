---
title: "使用队列方案 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 1028ab37-7ead-41a6-a186-53e5344d1a28
caps.latest.revision: "19"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 42f1c9931fe91b284c53a05c7868554c622306fb
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="working-with-convoy-scenarios"></a><span data-ttu-id="7b798-102">使用保护方案</span><span class="sxs-lookup"><span data-stu-id="7b798-102">Working with Convoy Scenarios</span></span>
<span data-ttu-id="7b798-103">A*队列*存在的任何时间都必须与相关多个单个消息，以实现所需的结果。</span><span class="sxs-lookup"><span data-stu-id="7b798-103">A *convoy* exists any time that multiple single messages must be related to achieve the required result.</span></span> <span data-ttu-id="7b798-104">有两种主要类型的保护： 顺序和并行。</span><span class="sxs-lookup"><span data-stu-id="7b798-104">There are two main types of convoys: sequential and parallel.</span></span>  
  
 <span data-ttu-id="7b798-105">在某些情况下，业务流程实例可能会同时收到一组相关消息。</span><span class="sxs-lookup"><span data-stu-id="7b798-105">Under certain conditions, an orchestration instance might receive a group of correlated messages all at the same time.</span></span> <span data-ttu-id="7b798-106">这时就会产生争用条件，必须从该组中选出一条消息，令其在该业务流程实例中初始化一个相关集，然后其他消息再关联到该业务流程实例。</span><span class="sxs-lookup"><span data-stu-id="7b798-106">In this situation, a race condition might occur, in which one of the messages in the group must initialize a correlation set in the orchestration instance before the other messages can be correlated to that orchestration instance.</span></span>  
  
 <span data-ttu-id="7b798-107">为了确保所有相关消息都由同一个业务流程实例接收，BizTalk Server 会检测出现争用条件的可能性，并将这些消息视为一个保护。</span><span class="sxs-lookup"><span data-stu-id="7b798-107">To ensure that all of the correlated messages are received by the same orchestration instance, BizTalk Server detects the potential for such a race condition and treats these messages as a convoy.</span></span> <span data-ttu-id="7b798-108">登记时，运行时会创建一个常规订阅，并将其标识为保护的组成部分。</span><span class="sxs-lookup"><span data-stu-id="7b798-108">At enlistment, the runtime creates a general subscription and identifies it as part of a convoy.</span></span> <span data-ttu-id="7b798-109">填写完此订阅后，消息引擎会根据预定义相关属性的值，创建一个临时订阅。</span><span class="sxs-lookup"><span data-stu-id="7b798-109">After filling this subscription, the messaging engine creates a temporary subscription based on the values in the predefined correlation properties.</span></span> <span data-ttu-id="7b798-110">此临时订阅称为*护航集*。</span><span class="sxs-lookup"><span data-stu-id="7b798-110">This temporary subscription is called a *convoy set*.</span></span> <span data-ttu-id="7b798-111">一个保护集就是一组在保护中使用的相关集。</span><span class="sxs-lookup"><span data-stu-id="7b798-111">A convoy set is a group of correlation sets that are used in a convoy.</span></span> <span data-ttu-id="7b798-112">系统会依据保护集，对所有匹配常规订阅的后续消息进行评价，匹配的消息被路由到一个现有端口。</span><span class="sxs-lookup"><span data-stu-id="7b798-112">All subsequent messages that match the general subscription are evaluated against the convoy set, and those that match are routed to an existing port.</span></span>  
  
## <a name="using-convoys-with-business-processes"></a><span data-ttu-id="7b798-113">在业务流程中使用保护</span><span class="sxs-lookup"><span data-stu-id="7b798-113">Using Convoys with Business Processes</span></span>  
 <span data-ttu-id="7b798-114">在业务流程中使用保护处理时，请注意以下事项：</span><span class="sxs-lookup"><span data-stu-id="7b798-114">Consider the following when using convoy processing with a business process:</span></span>  
  
-   <span data-ttu-id="7b798-115">A*相关集*是与消息路由到特定的业务流程用于特定值的属性的列表。</span><span class="sxs-lookup"><span data-stu-id="7b798-115">A *correlation set* is a list of properties with specific values that you use to route messages to a specific business process.</span></span> <span data-ttu-id="7b798-116">关联集上使用**接收**形状不能包含超过三个用于相关的属性。</span><span class="sxs-lookup"><span data-stu-id="7b798-116">The correlation set used on a **Receive** shape cannot contain more than three properties used for correlation.</span></span> <span data-ttu-id="7b798-117">这是因为这些值在数据库级别上进行标识和存储，而这种方式最多只支持三个参数。</span><span class="sxs-lookup"><span data-stu-id="7b798-117">This is because these values are identified and stored at the database level, which supports a maximum of three parameters.</span></span>  
  
-   <span data-ttu-id="7b798-118">并行保护和顺序保护可并存于同一个业务流程中，但相互之间不能共享任何相关集。</span><span class="sxs-lookup"><span data-stu-id="7b798-118">Parallel and sequential convoys can coexist in the same business process, but they cannot share any correlation sets with each other.</span></span> <span data-ttu-id="7b798-119">这是因为每个相关集只能属于一个保护。</span><span class="sxs-lookup"><span data-stu-id="7b798-119">This is because each correlation set can belong to only one convoy.</span></span>  
  
-   <span data-ttu-id="7b798-120">BizTalk Server 不支持队列处理，当你使用**启动 Orchestration**形状将设置到新的业务流程已初始化相关。</span><span class="sxs-lookup"><span data-stu-id="7b798-120">BizTalk Server does not support convoy processing when you use the **Start Orchestration** shape to pass an already-initialized correlation set into a new orchestration.</span></span> <span data-ttu-id="7b798-121">这是因为保护集是在数据库级别处理的，独立于已在运行的业务流程实例。</span><span class="sxs-lookup"><span data-stu-id="7b798-121">This is because convoy sets are handled at the database level, independent of already-running orchestration instances.</span></span>  
  
-   <span data-ttu-id="7b798-122">不能使用单个**接收**形状初始化将在单独的保护中使用的两个或多个关联集。</span><span class="sxs-lookup"><span data-stu-id="7b798-122">You cannot use a single **Receive** shape to initialize two or more correlation sets that will be used in separate convoys.</span></span> <span data-ttu-id="7b798-123">例如，假设接收 r1 为第一个保护初始化相关集 c1 和 c2，接收 r2 为第二个保护初始化 c1，接收 r3 为第三个保护初始化 c2。</span><span class="sxs-lookup"><span data-stu-id="7b798-123">For example, suppose that receive r1 initializes correlation sets c1 and c2 for the first convoy, receive r2 follows c1 for the second convoy, and receive r3 follows c2 for the third convoy.</span></span> <span data-ttu-id="7b798-124">设想中，第二个保护的保护集为 (c1, r2)，第三个保护的保护集为 (c2, r3)，它们都由 r1 初始化。</span><span class="sxs-lookup"><span data-stu-id="7b798-124">The intended convoy sets for the second convoy are c1, r2 and the intended convoy sets for the third convoy are c2, r3, which are all initialized by r1.</span></span> <span data-ttu-id="7b798-125">在这种情况下，业务流程引擎不会将它们视为保护。</span><span class="sxs-lookup"><span data-stu-id="7b798-125">In this case, the orchestration engine will not treat these as convoys.</span></span> <span data-ttu-id="7b798-126">在这个例子中，如果 r2 和 r3 均初始化 c1 (c1, r2, r3) 和 c2 (c2, r2, r3)，均仅初始化 c1 (c1, r2, r3) 或均仅初始化 c2 (c2, r2, r3)，则该保护方案将是有效的。</span><span class="sxs-lookup"><span data-stu-id="7b798-126">The example is a valid convoy scenario if both r2 and r3 follow both c1 and c2 (c1, r2, r3 and c2, r2, r3), both follow c1 only (c1, r2, r3), or both follow c2 only (c2, r2, r3).</span></span>  
  
## <a name="zombies"></a><span data-ttu-id="7b798-127">僵停</span><span class="sxs-lookup"><span data-stu-id="7b798-127">Zombies</span></span>  
 <span data-ttu-id="7b798-128">使用保护可能会引发称为僵停的“丢失”消息。</span><span class="sxs-lookup"><span data-stu-id="7b798-128">The use of convoys can result in "lost" messages called zombies.</span></span> <span data-ttu-id="7b798-129">如果正在运行的业务流程中的非激活接收订阅与 MessageBox 数据库中的消息相匹配，则 MessageBox 会将该消息传递给业务流程。</span><span class="sxs-lookup"><span data-stu-id="7b798-129">When a non-activating receive subscription in a running orchestration matches a message in the MessageBox database, then the MessageBox delivers the message to the orchestration.</span></span> <span data-ttu-id="7b798-130">由于 MessageBox 不了解业务流程内的业务逻辑，所以它只是简单地将所有匹配订阅的消息都传递给业务流程。</span><span class="sxs-lookup"><span data-stu-id="7b798-130">Because the MessageBox does not know the business logic inside the orchestration, it simply delivers to the orchestration all the messages that match the subscription.</span></span> <span data-ttu-id="7b798-131">如果在该业务流程的执行流已经传递了可处理消息的接收订阅后，又传送了匹配消息，则这些消息将会僵停。</span><span class="sxs-lookup"><span data-stu-id="7b798-131">If any of these messages are delivered when the orchestration execution flow has passed the receive subscriptions that can consume the messages, then such messages become zombies.</span></span>  
  
 <span data-ttu-id="7b798-132">产生僵停的一个例子是：在一个循环中，一个接收循环 17 次，却有 18 个与该循环中的接收订阅匹配的消息被传出。</span><span class="sxs-lookup"><span data-stu-id="7b798-132">An example of a situation that creates zombies is a receive inside a loop that iterates 17 times, but 18 messages are delivered that match the receive subscription in the loop.</span></span> <span data-ttu-id="7b798-133">（MessageBox 不知道该业务流程逻辑只处理 17 个消息。）由于该业务流程的执行流已经退出了循环，因此传出的第 18 个消息将不会被处理。</span><span class="sxs-lookup"><span data-stu-id="7b798-133">(The MessageBox does not know that the orchestration logic only handles 17 messages.) The 18th message delivered is not consumed by the orchestration because execution flow has already exited the loop.</span></span> <span data-ttu-id="7b798-134">该业务流程完成时，有丢弃的消息（僵停），这是不可恢复的，因为该业务流程实例已经完成了。</span><span class="sxs-lookup"><span data-stu-id="7b798-134">The orchestration is completed with discarded messages (zombies), which are not resumable because the orchestration instance has already completed.</span></span>  
  
 <span data-ttu-id="7b798-135">使用 Windows 管理规范 (WMI) 脚本来查询处于“已挂起-不可恢复”状态的实例，可以对僵停进行管理。</span><span class="sxs-lookup"><span data-stu-id="7b798-135">You can manage zombies by using a Windows Management Instrumentation (WMI) script to query the instances with the "Suspended-NonResumable" state.</span></span> <span data-ttu-id="7b798-136">此外，消息引擎还会向事件日志写入一条错误消息：“已完成，有消息被放弃”。</span><span class="sxs-lookup"><span data-stu-id="7b798-136">In addition, the messaging engine writes an error message, "Completed with discarded messages", to the event log.</span></span>  
  
 <span data-ttu-id="7b798-137">而且，如果顺序保护具有长期事务作用域，且该作用域有超时设置，则某些业务流程实例也将以“已挂起-不可恢复”状态结束。</span><span class="sxs-lookup"><span data-stu-id="7b798-137">Moreover, if you have a sequential convoy with a long-running transactional scope, and the scope has a time-out setting, some orchestration instances may end up in the "Suspended-NonResumable" state.</span></span> <span data-ttu-id="7b798-138">您也许已经注意到了输出消息数与“已挂起-不可恢复”实例数之和小于输入消息数。</span><span class="sxs-lookup"><span data-stu-id="7b798-138">You may also notice that the number of output messages plus the number of "Suspended-NonResumable" instances is less than the number of input messages.</span></span> <span data-ttu-id="7b798-139">这种行为是默认设置。</span><span class="sxs-lookup"><span data-stu-id="7b798-139">This behavior is by design.</span></span> <span data-ttu-id="7b798-140">发生超时异常时，代码将会转向异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="7b798-140">When a time-out exception happens, the code goes into the exception handler.</span></span> <span data-ttu-id="7b798-141">BizTalk Server 调用异常处理程序来处理该异常，其中包括处理僵停。</span><span class="sxs-lookup"><span data-stu-id="7b798-141">BizTalk Server calls the exception handler to let it handle the exception, including handling the zombies.</span></span> <span data-ttu-id="7b798-142">您可以使用异常处理程序中的发送端口，将僵停发送到一个目标，以进一步查看和处理。</span><span class="sxs-lookup"><span data-stu-id="7b798-142">You can use a send port in the exception handler to send the zombies to a destination for further review and processing.</span></span>  
  
 <span data-ttu-id="7b798-143">除保护外，其他方案也会产生僵停。</span><span class="sxs-lookup"><span data-stu-id="7b798-143">Scenarios other than convoys can also generate zombies.</span></span> <span data-ttu-id="7b798-144">例如，假设一个业务流程实例在等待来自业务处理流程的响应消息，由于某种原因，它接收到了两个匹配订阅的响应消息。</span><span class="sxs-lookup"><span data-stu-id="7b798-144">For example, suppose that an orchestration instance is expecting one response message from a business process, and for some reason, it receives two matching subscription response messages.</span></span> <span data-ttu-id="7b798-145">在这种情况下，第二个响应消息成为僵停消息。</span><span class="sxs-lookup"><span data-stu-id="7b798-145">In this case, the second response message becomes a zombie.</span></span> <span data-ttu-id="7b798-146">另一个示例是当你有**侦听**调整与**接收**形状一个分支和一个**延迟**在其他分支的形状。</span><span class="sxs-lookup"><span data-stu-id="7b798-146">Another example is when you have a **Listen** shape with a **Receive** shape at one branch and a **Delay** shape at the other branch.</span></span> <span data-ttu-id="7b798-147">如果消息到达的同时发生超时，则该消息成为僵停消息。</span><span class="sxs-lookup"><span data-stu-id="7b798-147">If a message arrives at the same time that the time-out occurs, the message becomes a zombie.</span></span>  
  
 <span data-ttu-id="7b798-148">有关如何管理僵尸的详细信息，请参阅**删除挂起的服务实例** [!INCLUDE[ui-guidance-developers-reference](../includes/ui-guidance-developers-reference.md)]。</span><span class="sxs-lookup"><span data-stu-id="7b798-148">For more information about how to manage zombies, see **Removing Suspended Service Instances** [!INCLUDE[ui-guidance-developers-reference](../includes/ui-guidance-developers-reference.md)].</span></span>
  
## <a name="next-steps"></a><span data-ttu-id="7b798-149">后续步骤</span><span class="sxs-lookup"><span data-stu-id="7b798-149">Next steps</span></span>
 [<span data-ttu-id="7b798-150">顺序保护</span><span class="sxs-lookup"><span data-stu-id="7b798-150">Sequential Convoys</span></span>](../core/sequential-convoys.md)  
  
 [<span data-ttu-id="7b798-151">并行的保护</span><span class="sxs-lookup"><span data-stu-id="7b798-151">Parallel Convoys</span></span>](../core/parallel-convoys.md)  
  
## <a name="see-also"></a><span data-ttu-id="7b798-152">另请参阅</span><span class="sxs-lookup"><span data-stu-id="7b798-152">See Also</span></span>  
 [<span data-ttu-id="7b798-153">在业务流程中使用相关性</span><span class="sxs-lookup"><span data-stu-id="7b798-153">Using Correlations in Orchestrations</span></span>](../core/using-correlations-in-orchestrations.md)