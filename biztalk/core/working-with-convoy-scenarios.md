---
title: 使用保护方案 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 1028ab37-7ead-41a6-a186-53e5344d1a28
caps.latest.revision: 19
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e3eb1e6656b6aa725cbc110030257df77657b631
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65258525"
---
# <a name="working-with-convoy-scenarios"></a><span data-ttu-id="41c63-102">使用保护方案</span><span class="sxs-lookup"><span data-stu-id="41c63-102">Working with Convoy Scenarios</span></span>
<span data-ttu-id="41c63-103">一个*保护*存在多个单独的消息必须起来才能达到所需的结果的任何时间。</span><span class="sxs-lookup"><span data-stu-id="41c63-103">A *convoy* exists any time that multiple single messages must be related to achieve the required result.</span></span> <span data-ttu-id="41c63-104">有两种主要类型的保护： 顺序和并行。</span><span class="sxs-lookup"><span data-stu-id="41c63-104">There are two main types of convoys: sequential and parallel.</span></span>  
  
 <span data-ttu-id="41c63-105">某些情况下，业务流程实例可能会全部在同一时间收到一组相关消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-105">Under certain conditions, an orchestration instance might receive a group of correlated messages all at the same time.</span></span> <span data-ttu-id="41c63-106">在此情况下，争用条件可能会出现，在其中一个组中的消息必须初始化中的相关集的业务流程实例之前其他消息再关联到该业务流程实例。</span><span class="sxs-lookup"><span data-stu-id="41c63-106">In this situation, a race condition might occur, in which one of the messages in the group must initialize a correlation set in the orchestration instance before the other messages can be correlated to that orchestration instance.</span></span>  
  
 <span data-ttu-id="41c63-107">若要确保由相同的业务流程实例收到所有相关的消息，BizTalk Server 检测到潜在的争用条件，并将这些消息视为一个保护。</span><span class="sxs-lookup"><span data-stu-id="41c63-107">To ensure that all of the correlated messages are received by the same orchestration instance, BizTalk Server detects the potential for such a race condition and treats these messages as a convoy.</span></span> <span data-ttu-id="41c63-108">登记时，运行时创建一个常规订阅和其标识为保护的组成部分。</span><span class="sxs-lookup"><span data-stu-id="41c63-108">At enlistment, the runtime creates a general subscription and identifies it as part of a convoy.</span></span> <span data-ttu-id="41c63-109">后填写完此订阅，消息引擎创建一个临时订阅中预定义的相关属性的值。</span><span class="sxs-lookup"><span data-stu-id="41c63-109">After filling this subscription, the messaging engine creates a temporary subscription based on the values in the predefined correlation properties.</span></span> <span data-ttu-id="41c63-110">此临时订阅称为*护航集*。</span><span class="sxs-lookup"><span data-stu-id="41c63-110">This temporary subscription is called a *convoy set*.</span></span> <span data-ttu-id="41c63-111">保护集就是一组在保护中使用的相关集。</span><span class="sxs-lookup"><span data-stu-id="41c63-111">A convoy set is a group of correlation sets that are used in a convoy.</span></span> <span data-ttu-id="41c63-112">与常规订阅匹配的所有后续消息根据保护集进行计算并与匹配的路由到现有的端口。</span><span class="sxs-lookup"><span data-stu-id="41c63-112">All subsequent messages that match the general subscription are evaluated against the convoy set, and those that match are routed to an existing port.</span></span>  
  
## <a name="using-convoys-with-business-processes"></a><span data-ttu-id="41c63-113">业务流程中使用保护</span><span class="sxs-lookup"><span data-stu-id="41c63-113">Using Convoys with Business Processes</span></span>  
 <span data-ttu-id="41c63-114">使用保护处理业务流程时，请考虑以下方法：</span><span class="sxs-lookup"><span data-stu-id="41c63-114">Consider the following when using convoy processing with a business process:</span></span>  
  
-   <span data-ttu-id="41c63-115">一个*相关集*是具有将消息路由到特定业务流程使用的特定值的属性的列表。</span><span class="sxs-lookup"><span data-stu-id="41c63-115">A *correlation set* is a list of properties with specific values that you use to route messages to a specific business process.</span></span> <span data-ttu-id="41c63-116">使用上的相关集**接收**形状不能包含三个以上用于相关的属性。</span><span class="sxs-lookup"><span data-stu-id="41c63-116">The correlation set used on a **Receive** shape cannot contain more than three properties used for correlation.</span></span> <span data-ttu-id="41c63-117">这是因为这些值进行标识和存储在数据库级别，支持最多三个参数。</span><span class="sxs-lookup"><span data-stu-id="41c63-117">This is because these values are identified and stored at the database level, which supports a maximum of three parameters.</span></span>  
  
-   <span data-ttu-id="41c63-118">并行和顺序保护可以共存于同一业务流程，但它们不能彼此共享任何相关集。</span><span class="sxs-lookup"><span data-stu-id="41c63-118">Parallel and sequential convoys can coexist in the same business process, but they cannot share any correlation sets with each other.</span></span> <span data-ttu-id="41c63-119">这是因为每个相关集只能属于一个保护。</span><span class="sxs-lookup"><span data-stu-id="41c63-119">This is because each correlation set can belong to only one convoy.</span></span>  
  
-   <span data-ttu-id="41c63-120">BizTalk Server 不支持保护处理时使用**启动业务流程**形状以将传递到新的业务流程设置已初始化的相关。</span><span class="sxs-lookup"><span data-stu-id="41c63-120">BizTalk Server does not support convoy processing when you use the **Start Orchestration** shape to pass an already-initialized correlation set into a new orchestration.</span></span> <span data-ttu-id="41c63-121">这是因为保护集在数据库级别，独立于已运行的业务流程实例的处理。</span><span class="sxs-lookup"><span data-stu-id="41c63-121">This is because convoy sets are handled at the database level, independent of already-running orchestration instances.</span></span>  
  
-   <span data-ttu-id="41c63-122">不能使用单个**接收**形状来初始化将不同保护中使用的两个或多个相关集。</span><span class="sxs-lookup"><span data-stu-id="41c63-122">You cannot use a single **Receive** shape to initialize two or more correlation sets that will be used in separate convoys.</span></span> <span data-ttu-id="41c63-123">例如，假设接收 r1 初始化相关集 c1 和 c2 的第一个保护接收 r2 为第二个保护，如下所示 c1，接收 r3 为第三个保护如下所示 c2。</span><span class="sxs-lookup"><span data-stu-id="41c63-123">For example, suppose that receive r1 initializes correlation sets c1 and c2 for the first convoy, receive r2 follows c1 for the second convoy, and receive r3 follows c2 for the third convoy.</span></span> <span data-ttu-id="41c63-124">第二个保护的保护集 c1，r2 和第三个保护的保护集是 c2，r3，都由 r1 初始化。</span><span class="sxs-lookup"><span data-stu-id="41c63-124">The intended convoy sets for the second convoy are c1, r2 and the intended convoy sets for the third convoy are c2, r3, which are all initialized by r1.</span></span> <span data-ttu-id="41c63-125">在这种情况下，业务流程引擎不会将它们视为保护。</span><span class="sxs-lookup"><span data-stu-id="41c63-125">In this case, the orchestration engine will not treat these as convoys.</span></span> <span data-ttu-id="41c63-126">该示例是一个有效的保护方案，如果 r2 和 r3 遵循 c1 和 c2 (c1，r2，r3 和 c2，r2，r3)，二者均遵循 c1 唯一 (c1，r2，r3)，或二者均遵循 c2 唯一 (c2，r2，r3)。</span><span class="sxs-lookup"><span data-stu-id="41c63-126">The example is a valid convoy scenario if both r2 and r3 follow both c1 and c2 (c1, r2, r3 and c2, r2, r3), both follow c1 only (c1, r2, r3), or both follow c2 only (c2, r2, r3).</span></span>  
  
## <a name="zombies"></a><span data-ttu-id="41c63-127">僵停</span><span class="sxs-lookup"><span data-stu-id="41c63-127">Zombies</span></span>  
 <span data-ttu-id="41c63-128">使用保护可以导致称为僵停的"丢失"消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-128">The use of convoys can result in "lost" messages called zombies.</span></span> <span data-ttu-id="41c63-129">非激活接收时正在运行的业务流程中的订阅与 MessageBox 数据库中的消息相匹配，则 MessageBox 的消息传递到业务流程。</span><span class="sxs-lookup"><span data-stu-id="41c63-129">When a non-activating receive subscription in a running orchestration matches a message in the MessageBox database, then the MessageBox delivers the message to the orchestration.</span></span> <span data-ttu-id="41c63-130">由于 MessageBox 不知道该业务流程内部的业务逻辑，它只是提供了到业务流程与订阅匹配的所有消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-130">Because the MessageBox does not know the business logic inside the orchestration, it simply delivers to the orchestration all the messages that match the subscription.</span></span> <span data-ttu-id="41c63-131">如果任何这些消息传递的是业务流程执行流已经传递接收订阅后，可以使用消息时，此类消息成为僵停。</span><span class="sxs-lookup"><span data-stu-id="41c63-131">If any of these messages are delivered when the orchestration execution flow has passed the receive subscriptions that can consume the messages, then such messages become zombies.</span></span>  
  
 <span data-ttu-id="41c63-132">产生僵停的情况下的一个示例是接收循环 17 次循环内的，但 18 的消息传送的匹配中循环的接收订阅。</span><span class="sxs-lookup"><span data-stu-id="41c63-132">An example of a situation that creates zombies is a receive inside a loop that iterates 17 times, but 18 messages are delivered that match the receive subscription in the loop.</span></span> <span data-ttu-id="41c63-133">（MessageBox 不知道的业务流程逻辑只处理 17 个消息。）第 18 的消息传递未被业务流程，因为执行流已经退出循环。</span><span class="sxs-lookup"><span data-stu-id="41c63-133">(The MessageBox does not know that the orchestration logic only handles 17 messages.) The 18th message delivered is not consumed by the orchestration because execution flow has already exited the loop.</span></span> <span data-ttu-id="41c63-134">业务流程已完成并且丢弃消息 （僵停），这是因为已经完成业务流程实例不可恢复。</span><span class="sxs-lookup"><span data-stu-id="41c63-134">The orchestration is completed with discarded messages (zombies), which are not resumable because the orchestration instance has already completed.</span></span>  
  
 <span data-ttu-id="41c63-135">可以使用 Windows Management Instrumentation (WMI) 脚本来查询了"已挂起-不可恢复"状态的实例管理僵停。</span><span class="sxs-lookup"><span data-stu-id="41c63-135">You can manage zombies by using a Windows Management Instrumentation (WMI) script to query the instances with the "Suspended-NonResumable" state.</span></span> <span data-ttu-id="41c63-136">此外，消息引擎将写入错误消息，"已完成有消息被放弃"，该事件的日志。</span><span class="sxs-lookup"><span data-stu-id="41c63-136">In addition, the messaging engine writes an error message, "Completed with discarded messages", to the event log.</span></span>  
  
 <span data-ttu-id="41c63-137">此外，如果顺序保护具有长时间运行事务作用域，并且该作用域具有超时设置，某些业务流程实例最终可能处于"已挂起-不可恢复"状态。</span><span class="sxs-lookup"><span data-stu-id="41c63-137">Moreover, if you have a sequential convoy with a long-running transactional scope, and the scope has a time-out setting, some orchestration instances may end up in the "Suspended-NonResumable" state.</span></span> <span data-ttu-id="41c63-138">您可能还注意到其中的输出消息的数量加"已挂起-不可恢复"实例数小于输入消息数。</span><span class="sxs-lookup"><span data-stu-id="41c63-138">You may also notice that the number of output messages plus the number of "Suspended-NonResumable" instances is less than the number of input messages.</span></span> <span data-ttu-id="41c63-139">这种行为是默认设置。</span><span class="sxs-lookup"><span data-stu-id="41c63-139">This behavior is by design.</span></span> <span data-ttu-id="41c63-140">在超时异常情况下，代码将进入异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="41c63-140">When a time-out exception happens, the code goes into the exception handler.</span></span> <span data-ttu-id="41c63-141">BizTalk Server 调用异常处理程序，以使其处理的异常，包括处理僵停。</span><span class="sxs-lookup"><span data-stu-id="41c63-141">BizTalk Server calls the exception handler to let it handle the exception, including handling the zombies.</span></span> <span data-ttu-id="41c63-142">可以使用异常处理程序中的发送端口将僵停发送到目标以进一步查看和处理。</span><span class="sxs-lookup"><span data-stu-id="41c63-142">You can use a send port in the exception handler to send the zombies to a destination for further review and processing.</span></span>  
  
 <span data-ttu-id="41c63-143">保护以外的方案还可以生成僵停。</span><span class="sxs-lookup"><span data-stu-id="41c63-143">Scenarios other than convoys can also generate zombies.</span></span> <span data-ttu-id="41c63-144">例如，假设业务流程实例需要一个响应消息从业务流程自动运行，由于某种原因，它接收两个匹配的订阅的响应消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-144">For example, suppose that an orchestration instance is expecting one response message from a business process, and for some reason, it receives two matching subscription response messages.</span></span> <span data-ttu-id="41c63-145">在这种情况下，第二个响应消息成为僵停消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-145">In this case, the second response message becomes a zombie.</span></span> <span data-ttu-id="41c63-146">另一个示例是，有时**侦听**形状和**接收**在一个分支的形状和一个**延迟**形状在其他分支。</span><span class="sxs-lookup"><span data-stu-id="41c63-146">Another example is when you have a **Listen** shape with a **Receive** shape at one branch and a **Delay** shape at the other branch.</span></span> <span data-ttu-id="41c63-147">如果一条消息到达时同时发生超时的时候，该消息成为僵停消息。</span><span class="sxs-lookup"><span data-stu-id="41c63-147">If a message arrives at the same time that the time-out occurs, the message becomes a zombie.</span></span>  
  
 <span data-ttu-id="41c63-148">有关如何管理僵停的详细信息，请参阅**删除挂起的服务实例** [!INCLUDE[ui-guidance-developers-reference](../includes/ui-guidance-developers-reference.md)]。</span><span class="sxs-lookup"><span data-stu-id="41c63-148">For more information about how to manage zombies, see **Removing Suspended Service Instances** [!INCLUDE[ui-guidance-developers-reference](../includes/ui-guidance-developers-reference.md)].</span></span>
  
## <a name="next-steps"></a><span data-ttu-id="41c63-149">后续步骤</span><span class="sxs-lookup"><span data-stu-id="41c63-149">Next steps</span></span>
 [<span data-ttu-id="41c63-150">顺序保护</span><span class="sxs-lookup"><span data-stu-id="41c63-150">Sequential Convoys</span></span>](../core/sequential-convoys.md)  
  
 [<span data-ttu-id="41c63-151">并行保护</span><span class="sxs-lookup"><span data-stu-id="41c63-151">Parallel Convoys</span></span>](../core/parallel-convoys.md)  
  
## <a name="see-also"></a><span data-ttu-id="41c63-152">请参阅</span><span class="sxs-lookup"><span data-stu-id="41c63-152">See Also</span></span>  
 [<span data-ttu-id="41c63-153">在业务流程中使用关联</span><span class="sxs-lookup"><span data-stu-id="41c63-153">Using Correlations in Orchestrations</span></span>](../core/using-correlations-in-orchestrations.md)