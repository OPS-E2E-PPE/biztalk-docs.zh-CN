---
title: 设计你的适配器的提示 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 93c59efc2ae811827cd0cb1cf4763485b675f4ea
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
ms.locfileid: "22279861"
---
# <a name="tips-for-designing-your-adapter"></a><span data-ttu-id="28475-102">设计适配器的提示</span><span class="sxs-lookup"><span data-stu-id="28475-102">Tips for Designing Your Adapter</span></span>
<span data-ttu-id="28475-103">本部分包含适配器开发人员在设计适配器时所发现的技巧。</span><span class="sxs-lookup"><span data-stu-id="28475-103">This section contains hints and tips that adapter developers have learned while designing adapters.</span></span>  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a><span data-ttu-id="28475-104">处理程序属性用作默认配置时应为字符串</span><span class="sxs-lookup"><span data-stu-id="28475-104">Handler Properties Should Be Strings if Used as Default Configurations</span></span>  
 <span data-ttu-id="28475-105">似乎具吸引力，若要使用 XSD 生成的处理程序属性页上的属性，为默认值为其**位置**属性因为未设置值**位置**运行时自动使用设置处理程序中的值。</span><span class="sxs-lookup"><span data-stu-id="28475-105">It seems attractive to use the properties on the XSD-generated handler property sheet as defaults for their **Location** properties because if the value is not set in **Location** the runtime automatically uses the value set in the handler.</span></span> <span data-ttu-id="28475-106">但是有几个问题使这个想法没有多大意义。</span><span class="sxs-lookup"><span data-stu-id="28475-106">But there are several issues that make this less useful.</span></span>  
  
 <span data-ttu-id="28475-107">问题在于不知道提供给运行时的值是否会被重写。</span><span class="sxs-lookup"><span data-stu-id="28475-107">The problem comes with not knowing whether the value presented to the runtime is to be overridden or not.</span></span> <span data-ttu-id="28475-108">为此，通常为值定义 NULL 概念，然后针对该值运行测试。</span><span class="sxs-lookup"><span data-stu-id="28475-108">The typical way of doing this is to have some notion of NULL defined for values and then run a test against that value.</span></span> <span data-ttu-id="28475-109">在 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中使用基于 XSD 的属性表的问题是仅针对字符串支持 NULL。</span><span class="sxs-lookup"><span data-stu-id="28475-109">The problem when using the XSD-based property sheets in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is that NULL is only supported for strings.</span></span> <span data-ttu-id="28475-110">即使您希望适配器通过使用此 NULL 测试来得到默认设置并且愿意将适配器限制为字符串类型，它所显示的用户界面也非常别扭。</span><span class="sxs-lookup"><span data-stu-id="28475-110">Even if you want your adapter to have default settings through the use of this NULL test and are willing to restrict the adapter to string types, it is still exposed to a very odd piece of user interface.</span></span>  
  
 <span data-ttu-id="28475-111">XSD 生成的属性表仅支持返回为 NULL 的属性的设置，请右键单击该属性，此时**废除？** 出现上下文菜单和该属性可以设置为 NULL。</span><span class="sxs-lookup"><span data-stu-id="28475-111">The XSD-generated property sheets only support the setting of a property back to NULL by right-clicking the property, at which point a **nullify?** context menu appears and the property can be set to NULL.</span></span> <span data-ttu-id="28475-112">屏幕上不会显示任何信息以指示属性是否为 NULL。</span><span class="sxs-lookup"><span data-stu-id="28475-112">There is no visual feedback as to whether a property is NULL.</span></span>  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a><span data-ttu-id="28475-113">实现架构生成向导的注意事项</span><span class="sxs-lookup"><span data-stu-id="28475-113">Considerations for Implementing Schema Generation Wizards</span></span>  
 <span data-ttu-id="28475-114">程序员喜欢针对强类型对象模型编写代码。</span><span class="sxs-lookup"><span data-stu-id="28475-114">Programmers like to code against strongly typed object models.</span></span> <span data-ttu-id="28475-115">在代码中操作 XML 乍看起来比较笨拙，而且容易出错。</span><span class="sxs-lookup"><span data-stu-id="28475-115">Manipulating XML in code can at first seem awkward and prone to error.</span></span> <span data-ttu-id="28475-116">不过，通过一些技巧并巧妙使用 .NET Framework 提供的支持可以在很大程度上简化问题。</span><span class="sxs-lookup"><span data-stu-id="28475-116">But some tricks and smart use of the support offered by the .NET Framework can dramatically simplify matters.</span></span>  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a><span data-ttu-id="28475-117">请勿使用字符串串联来创建 XML 文档</span><span class="sxs-lookup"><span data-stu-id="28475-117">Do not create XML documents with string concatenation</span></span>  
 <span data-ttu-id="28475-118">使用 XML 时最严重的错误之一就是试图通过字符串串联和打印内存中的语句来生成 XML。</span><span class="sxs-lookup"><span data-stu-id="28475-118">One of the worst mistakes to make with XML is to try and generate it from string concatenation and print statements in memory.</span></span> <span data-ttu-id="28475-119">这会消耗大量 CPU 时间和内存。</span><span class="sxs-lookup"><span data-stu-id="28475-119">This consumes large amounts of CPU time and memory.</span></span> <span data-ttu-id="28475-120">即使对于最基本的 XML 代码段，使用诸如 XmlWriter 或文档对象模型 (DOM) 等工具都会简化操作。</span><span class="sxs-lookup"><span data-stu-id="28475-120">Even for the most trivial XML snippet, it is easier to use a tool like XmlWriter or the Document Object Model (DOM).</span></span> <span data-ttu-id="28475-121">如果您使用 XmlWriter，请勿使用“写入后读取”写功能，因为编写器会丢失文档的状态。</span><span class="sxs-lookup"><span data-stu-id="28475-121">If you are using XmlWriter, do not use the raw write capability, because the writer loses the state of the document.</span></span>  
  
 <span data-ttu-id="28475-122">在运行时，由于与 DOM 相关的大量内存消耗问题，XmlWriter 比 XML DOM 优先级高。</span><span class="sxs-lookup"><span data-stu-id="28475-122">At run time, XmlWriter is preferred over the XML DOM because of high memory consumption issues associated with the DOM.</span></span> <span data-ttu-id="28475-123">但是在配置或设计时，这很可能就不是个问题了。</span><span class="sxs-lookup"><span data-stu-id="28475-123">However, at configuration or design time this will most likely not be an issue.</span></span> <span data-ttu-id="28475-124">使用 DOM 可以更好地使用 XPATH 查询，这是个有用的附加工具。</span><span class="sxs-lookup"><span data-stu-id="28475-124">Using the DOM facilitates the use of XPATH queries, which can be a useful additional tool.</span></span>  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a><span data-ttu-id="28475-125">考虑将 XML 文档的主干定义为资源</span><span class="sxs-lookup"><span data-stu-id="28475-125">Consider defining the skeleton of your XML document as a resource</span></span>  
 <span data-ttu-id="28475-126">如果要通过设计工具生成很大的 XML 文档并且生成的文档始终具有相同的基本结构，则可以考虑将整个主干 XML 文件作为项目中的资源，以便在需要编辑时对其进行更改。</span><span class="sxs-lookup"><span data-stu-id="28475-126">If you are generating a large XML document from a design tool and that generated document always follows the same basic structure, consider placing the whole skeletal XML file as a resource in the project to allow making changes when you need to edit it.</span></span>  
  
 <span data-ttu-id="28475-127">将代码加载到 DOM 中，然后为文档的主干添加枝叶，方法是使用 XPATH 挑选要添加内容的节点。</span><span class="sxs-lookup"><span data-stu-id="28475-127">Load the code into a DOM and then add the necessary flesh to the bones of the document by using XPATH to pick out the node you want to add it to.</span></span> <span data-ttu-id="28475-128">在本示例中，您将创建 Web Services 描述语言 (WSDL) 文件。</span><span class="sxs-lookup"><span data-stu-id="28475-128">In this case, you are creating a Web Services Description Language (WSDL) file.</span></span> <span data-ttu-id="28475-129">该向导在资源中存储主干 WSDL 文件，并添加生成的 XML 架构定义 (XSD) 子级部分。</span><span class="sxs-lookup"><span data-stu-id="28475-129">The wizard stores the skeletal WSDL file in a resource and adds the generated XML Schema Definition (XSD) child parts.</span></span> <span data-ttu-id="28475-130">它使用具有 xpath 的 selectNode 来查找正确的父级。</span><span class="sxs-lookup"><span data-stu-id="28475-130">It uses selectNode with an xpath to find the right parent.</span></span> <span data-ttu-id="28475-131">这是用户界面代码，所以性能不是问题并且生成的实现方法清楚、功能强大并且可维护。</span><span class="sxs-lookup"><span data-stu-id="28475-131">This is user interface code, so performance is not an issue, and the resulting implementation is clean, robust, and maintainable.</span></span>  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a><span data-ttu-id="28475-132">考虑将处理步骤置于 BizTalk 管道中</span><span class="sxs-lookup"><span data-stu-id="28475-132">Consider Placing Processing Steps in the BizTalk Pipeline</span></span>  
 <span data-ttu-id="28475-133">通常情况下，Microsoft 生成的适配器会将基于消息格式的处理过程从适配器中移出，然后移入 BizTalk 管道中。</span><span class="sxs-lookup"><span data-stu-id="28475-133">In general the adapters built at Microsoft move message format-based processing out of the adapter and into the BizTalk pipeline.</span></span> <span data-ttu-id="28475-134">结构化非 XML 数据源的适配器就是一个很好的示例。</span><span class="sxs-lookup"><span data-stu-id="28475-134">A good example is an adapter to a structured but non-XML data source.</span></span>  
  
 <span data-ttu-id="28475-135">在这种情况下，适配器仅获取数据，而 BizTalk 管道则用于分析该数据并将其转换为 XML 中的等效数据。</span><span class="sxs-lookup"><span data-stu-id="28475-135">In this case, the adapter only gets the data and the BizTalk pipeline is used to parse it and convert it into an XML equivalent.</span></span> <span data-ttu-id="28475-136">优点是管道组件自身成为结构中可重复使用的部分。</span><span class="sxs-lookup"><span data-stu-id="28475-136">The benefit is that the pipeline component itself becomes a reusable piece of the architecture.</span></span>  
  
## <a name="make-adapter-behavior-configurable"></a><span data-ttu-id="28475-137">使适配器行为可配置</span><span class="sxs-lookup"><span data-stu-id="28475-137">Make Adapter Behavior Configurable</span></span>  
 <span data-ttu-id="28475-138">从 MQSeries 适配器测试版程序中学到的经验之一是：不是所有的客户都会满意同一个行为。</span><span class="sxs-lookup"><span data-stu-id="28475-138">One of the lessons learned from the MQSeries adapter beta program was that not all customers were happy with the same behavior.</span></span> <span data-ttu-id="28475-139">当涉及处理错误和排序时，更是如此。</span><span class="sxs-lookup"><span data-stu-id="28475-139">This was especially true when it came to handling errors and ordering.</span></span> <span data-ttu-id="28475-140">解决方法是使行为成为可配置的。</span><span class="sxs-lookup"><span data-stu-id="28475-140">The solution was to make the behavior configurable.</span></span> <span data-ttu-id="28475-141">您可以指定适配器是否支持排序，失败是否被移到挂起队列，或它们是否会导致适配器停止处理并禁用其自身。</span><span class="sxs-lookup"><span data-stu-id="28475-141">You can specify whether the adapter is to support ordering, whether failures are moved to the Suspended queue, or whether they cause the adapter to stop processing and disable itself.</span></span> <span data-ttu-id="28475-142">当客户需要在 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 外部编写复杂的业务流程或脚本来达到同一结果时，编写可配置的行为可以在很大程度上减少客户的工作量。</span><span class="sxs-lookup"><span data-stu-id="28475-142">Making such behaviors configurable can significantly simplify customers' lives when they would need to write complex orchestrations or scripts external to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to achieve the same result.</span></span>  
  
## <a name="support-correlation-with-message-queues"></a><span data-ttu-id="28475-143">支持与消息队列相关联</span><span class="sxs-lookup"><span data-stu-id="28475-143">Support Correlation with Message Queues</span></span>  
 <span data-ttu-id="28475-144">很多消息传送平台支持消息标头的相关 ID 的概念，以支持应用程序级别的请求-响应方案。</span><span class="sxs-lookup"><span data-stu-id="28475-144">Many messaging platforms support the notion of a correlation ID in the message header to support an application-level request-response scenario.</span></span> <span data-ttu-id="28475-145">示例包括 MQSeries、MSMQ 和 SQL Service Broker。</span><span class="sxs-lookup"><span data-stu-id="28475-145">Examples include MQSeries, MSMQ, and SQL Service Broker.</span></span> <span data-ttu-id="28475-146">将外部消息传送系统的请求-响应模式映射到 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中的发送-响应适配器，这看起来很有吸引力。</span><span class="sxs-lookup"><span data-stu-id="28475-146">It would seem attractive to map the request-response pattern of the external messaging system to a send-response adapter in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="28475-147">但是，由于存在事务，此操作没有任何意义。</span><span class="sxs-lookup"><span data-stu-id="28475-147">However this does not make sense because of where the transactions live.</span></span> <span data-ttu-id="28475-148">具体而言，向外部消息传送系统发送数据时需要事务性提交，然后队列的另一端才可以看到数据。</span><span class="sxs-lookup"><span data-stu-id="28475-148">Specifically, a send to the external messaging system requires a transactional commit before the other end of the queue sees the data.</span></span> <span data-ttu-id="28475-149">接收也必须是单独的事务。</span><span class="sxs-lookup"><span data-stu-id="28475-149">The receive must also be a separate transaction.</span></span>  
  
 <span data-ttu-id="28475-150">[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] 中的解决方案将执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="28475-150">The solution in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is to:</span></span>  
  
-   <span data-ttu-id="28475-151">在业务流程中使用相关集</span><span class="sxs-lookup"><span data-stu-id="28475-151">Use correlation sets in orchestration</span></span>  
  
-   <span data-ttu-id="28475-152">配置两个单独的端口： 一个用于发送，一个用于接收</span><span class="sxs-lookup"><span data-stu-id="28475-152">Configure two separate ports: one for the send and one for the receive</span></span>  
  
 <span data-ttu-id="28475-153">在简单的情形中，业务流程按适配器指定与消息有关的相关 ID。</span><span class="sxs-lookup"><span data-stu-id="28475-153">In a simple case the orchestration specifies the correlation ID that is associated with the message by the adapter.</span></span> <span data-ttu-id="28475-154">它作为消息的上下文属性传递给适配器。</span><span class="sxs-lookup"><span data-stu-id="28475-154">This is passed to the adapter as a context property on the message.</span></span> <span data-ttu-id="28475-155">在更复杂的情况下，该应用场景要求外部消息传递系统分配的 id。</span><span class="sxs-lookup"><span data-stu-id="28475-155">In a more complex case, the scenario calls for the external messaging system to allocate the ID.</span></span> <span data-ttu-id="28475-156">在这种情况下它可以被传递回从发送端口到响应消息的业务流程。</span><span class="sxs-lookup"><span data-stu-id="28475-156">In this case it can be passed back from the send port to the orchestration with a response message.</span></span> <span data-ttu-id="28475-157">此响应消息只是传回 ID，并不是真正的消息响应。</span><span class="sxs-lookup"><span data-stu-id="28475-157">This response message is just to pass back the ID and is not the true message response.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28475-158">在业务流程引擎中有一个争用条件，可能会显示消息的真正响应而不显示发送端口的 ID 响应。</span><span class="sxs-lookup"><span data-stu-id="28475-158">There is a race condition in the orchestration engine such that the true response to the message could win against the ID response from the send.</span></span> <span data-ttu-id="28475-159">此争用条件必须在业务流程自身中处理。</span><span class="sxs-lookup"><span data-stu-id="28475-159">This race condition must be handled in the orchestration itself.</span></span>