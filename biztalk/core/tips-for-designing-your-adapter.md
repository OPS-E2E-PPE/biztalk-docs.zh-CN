---
title: 设计您的适配器的提示 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 0bb60988-4e48-4654-9cf4-512dd7c97239
caps.latest.revision: 9
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: d7bbbde2d18aa2c51b3e5331b9028abb0b0332ce
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65399481"
---
# <a name="tips-for-designing-your-adapter"></a><span data-ttu-id="85a26-102">设计您的适配器的提示</span><span class="sxs-lookup"><span data-stu-id="85a26-102">Tips for Designing Your Adapter</span></span>
<span data-ttu-id="85a26-103">本部分包含提示和适配器开发人员已经学会设计适配器时的提示。</span><span class="sxs-lookup"><span data-stu-id="85a26-103">This section contains hints and tips that adapter developers have learned while designing adapters.</span></span>  
  
## <a name="handler-properties-should-be-strings-if-used-as-default-configurations"></a><span data-ttu-id="85a26-104">处理程序属性应为字符串，如果用作默认配置</span><span class="sxs-lookup"><span data-stu-id="85a26-104">Handler Properties Should Be Strings if Used as Default Configurations</span></span>  
 <span data-ttu-id="85a26-105">它看起来很有吸引力的默认值为使用 XSD 生成的处理程序属性表的属性及其**位置**属性因为未设置值**位置**运行时自动使用处理程序中设置的值。</span><span class="sxs-lookup"><span data-stu-id="85a26-105">It seems attractive to use the properties on the XSD-generated handler property sheet as defaults for their **Location** properties because if the value is not set in **Location** the runtime automatically uses the value set in the handler.</span></span> <span data-ttu-id="85a26-106">但有几个问题使这个想法很有用。</span><span class="sxs-lookup"><span data-stu-id="85a26-106">But there are several issues that make this less useful.</span></span>  
  
 <span data-ttu-id="85a26-107">问题在于不知道提供给运行时的值是否重写。</span><span class="sxs-lookup"><span data-stu-id="85a26-107">The problem comes with not knowing whether the value presented to the runtime is to be overridden or not.</span></span> <span data-ttu-id="85a26-108">执行此操作的典型方法是为值定义 NULL 概念，然后针对该值运行测试。</span><span class="sxs-lookup"><span data-stu-id="85a26-108">The typical way of doing this is to have some notion of NULL defined for values and then run a test against that value.</span></span> <span data-ttu-id="85a26-109">问题时使用基于 XSD 的属性表中[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]是仅针对字符串支持 NULL。</span><span class="sxs-lookup"><span data-stu-id="85a26-109">The problem when using the XSD-based property sheets in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is that NULL is only supported for strings.</span></span> <span data-ttu-id="85a26-110">即使您希望适配器具有默认设置通过使用此 NULL 测试并且愿意将适配器限制为字符串类型，它仍暴露于非常别扭的用户界面。</span><span class="sxs-lookup"><span data-stu-id="85a26-110">Even if you want your adapter to have default settings through the use of this NULL test and are willing to restrict the adapter to string types, it is still exposed to a very odd piece of user interface.</span></span>  
  
 <span data-ttu-id="85a26-111">XSD 生成的属性表仅支持回 NULL 属性的设置，请右键单击该属性，此时**置空？** 出现上下文菜单和属性可以设置为 NULL。</span><span class="sxs-lookup"><span data-stu-id="85a26-111">The XSD-generated property sheets only support the setting of a property back to NULL by right-clicking the property, at which point a **nullify?** context menu appears and the property can be set to NULL.</span></span> <span data-ttu-id="85a26-112">一个属性是 NULL 没有可视反馈。</span><span class="sxs-lookup"><span data-stu-id="85a26-112">There is no visual feedback as to whether a property is NULL.</span></span>  
  
## <a name="considerations-for-implementing-schema-generation-wizards"></a><span data-ttu-id="85a26-113">有关实现架构生成向导的注意事项</span><span class="sxs-lookup"><span data-stu-id="85a26-113">Considerations for Implementing Schema Generation Wizards</span></span>  
 <span data-ttu-id="85a26-114">程序员喜欢针对强类型化的对象模型编写代码。</span><span class="sxs-lookup"><span data-stu-id="85a26-114">Programmers like to code against strongly typed object models.</span></span> <span data-ttu-id="85a26-115">在代码中操作 XML 乍看起来比较笨拙，而且容易出错。</span><span class="sxs-lookup"><span data-stu-id="85a26-115">Manipulating XML in code can at first seem awkward and prone to error.</span></span> <span data-ttu-id="85a26-116">但一些技巧并巧妙使用.NET Framework 提供的支持可以极大地简化问题。</span><span class="sxs-lookup"><span data-stu-id="85a26-116">But some tricks and smart use of the support offered by the .NET Framework can dramatically simplify matters.</span></span>  
  
#### <a name="do-not-create-xml-documents-with-string-concatenation"></a><span data-ttu-id="85a26-117">不要使用字符串串联创建 XML 文档</span><span class="sxs-lookup"><span data-stu-id="85a26-117">Do not create XML documents with string concatenation</span></span>  
 <span data-ttu-id="85a26-118">其中一个最严重的错误，以使与 XML 是尝试并生成从字符串串联和打印内存中的语句。</span><span class="sxs-lookup"><span data-stu-id="85a26-118">One of the worst mistakes to make with XML is to try and generate it from string concatenation and print statements in memory.</span></span> <span data-ttu-id="85a26-119">这会消耗大量的 CPU 时间和内存。</span><span class="sxs-lookup"><span data-stu-id="85a26-119">This consumes large amounts of CPU time and memory.</span></span> <span data-ttu-id="85a26-120">即使对于最简单的 XML 代码段，它是更轻松地将 XmlWriter 或文档对象模型 (DOM) 之类的工具。</span><span class="sxs-lookup"><span data-stu-id="85a26-120">Even for the most trivial XML snippet, it is easier to use a tool like XmlWriter or the Document Object Model (DOM).</span></span> <span data-ttu-id="85a26-121">如果使用 XmlWriter，不使用原始的写功能，因为编写器会丢失文档的状态。</span><span class="sxs-lookup"><span data-stu-id="85a26-121">If you are using XmlWriter, do not use the raw write capability, because the writer loses the state of the document.</span></span>  
  
 <span data-ttu-id="85a26-122">在运行时，XmlWriter 比 XML DOM 由于与 DOM 相关联的高内存消耗问题</span><span class="sxs-lookup"><span data-stu-id="85a26-122">At run time, XmlWriter is preferred over the XML DOM because of high memory consumption issues associated with the DOM.</span></span> <span data-ttu-id="85a26-123">但是，在配置或设计时这很可能不会出现问题。</span><span class="sxs-lookup"><span data-stu-id="85a26-123">However, at configuration or design time this will most likely not be an issue.</span></span> <span data-ttu-id="85a26-124">使用 DOM 便于使用 XPATH 查询，可以是有用的附加工具。</span><span class="sxs-lookup"><span data-stu-id="85a26-124">Using the DOM facilitates the use of XPATH queries, which can be a useful additional tool.</span></span>  
  
#### <a name="consider-defining-the-skeleton-of-your-xml-document-as-a-resource"></a><span data-ttu-id="85a26-125">请考虑将 XML 文档的主干定义为资源</span><span class="sxs-lookup"><span data-stu-id="85a26-125">Consider defining the skeleton of your XML document as a resource</span></span>  
 <span data-ttu-id="85a26-126">如果从设计工具生成大型 XML 文档并生成的文档始终遵循相同的基本结构，请考虑为要允许进行更改，当您需要对其进行编辑时的项目中的资源将整个主干 XML 文件。</span><span class="sxs-lookup"><span data-stu-id="85a26-126">If you are generating a large XML document from a design tool and that generated document always follows the same basic structure, consider placing the whole skeletal XML file as a resource in the project to allow making changes when you need to edit it.</span></span>  
  
 <span data-ttu-id="85a26-127">将代码加载到 DOM 中，然后到为文档的主干添加枝叶，通过使用 XPATH 挑选出你想要将其添加到的节点。</span><span class="sxs-lookup"><span data-stu-id="85a26-127">Load the code into a DOM and then add the necessary flesh to the bones of the document by using XPATH to pick out the node you want to add it to.</span></span> <span data-ttu-id="85a26-128">在这种情况下，创建 Web 服务描述语言 (WSDL) 文件。</span><span class="sxs-lookup"><span data-stu-id="85a26-128">In this case, you are creating a Web Services Description Language (WSDL) file.</span></span> <span data-ttu-id="85a26-129">该向导在资源中存储主干 WSDL 文件，并添加生成的 XML 架构定义 (XSD) 子级部分。</span><span class="sxs-lookup"><span data-stu-id="85a26-129">The wizard stores the skeletal WSDL file in a resource and adds the generated XML Schema Definition (XSD) child parts.</span></span> <span data-ttu-id="85a26-130">它使用具有 xpath 的 selectNode 来查找正确的父级。</span><span class="sxs-lookup"><span data-stu-id="85a26-130">It uses selectNode with an xpath to find the right parent.</span></span> <span data-ttu-id="85a26-131">这是用户界面代码，因此性能不是问题，并且生成的实现是干净、 可靠且易于维护。</span><span class="sxs-lookup"><span data-stu-id="85a26-131">This is user interface code, so performance is not an issue, and the resulting implementation is clean, robust, and maintainable.</span></span>  
  
## <a name="consider-placing-processing-steps-in-the-biztalk-pipeline"></a><span data-ttu-id="85a26-132">考虑将处理步骤置于 BizTalk 管道</span><span class="sxs-lookup"><span data-stu-id="85a26-132">Consider Placing Processing Steps in the BizTalk Pipeline</span></span>  
 <span data-ttu-id="85a26-133">一般情况下生成的 Microsoft 适配器移动消息格式基于处理与适配器和 BizTalk 管道。</span><span class="sxs-lookup"><span data-stu-id="85a26-133">In general the adapters built at Microsoft move message format-based processing out of the adapter and into the BizTalk pipeline.</span></span> <span data-ttu-id="85a26-134">一个典型示例是结构化，但非 XML 数据源的适配器。</span><span class="sxs-lookup"><span data-stu-id="85a26-134">A good example is an adapter to a structured but non-XML data source.</span></span>  
  
 <span data-ttu-id="85a26-135">在这种情况下，适配器仅获取数据并使用 BizTalk 管道对其进行分析并将其转换为等效的 XML。</span><span class="sxs-lookup"><span data-stu-id="85a26-135">In this case, the adapter only gets the data and the BizTalk pipeline is used to parse it and convert it into an XML equivalent.</span></span> <span data-ttu-id="85a26-136">优点是管道组件本身变得可重复使用一种体系结构。</span><span class="sxs-lookup"><span data-stu-id="85a26-136">The benefit is that the pipeline component itself becomes a reusable piece of the architecture.</span></span>  
  
## <a name="make-adapter-behavior-configurable"></a><span data-ttu-id="85a26-137">使适配器行为可配置</span><span class="sxs-lookup"><span data-stu-id="85a26-137">Make Adapter Behavior Configurable</span></span>  
 <span data-ttu-id="85a26-138">从 MQSeries 适配器测试版程序中学到的经验之一是不是所有的客户很乐意使用相同的行为。</span><span class="sxs-lookup"><span data-stu-id="85a26-138">One of the lessons learned from the MQSeries adapter beta program was that not all customers were happy with the same behavior.</span></span> <span data-ttu-id="85a26-139">当涉及处理错误和排序时更是如此。</span><span class="sxs-lookup"><span data-stu-id="85a26-139">This was especially true when it came to handling errors and ordering.</span></span> <span data-ttu-id="85a26-140">解决方法是使行为成为可配置。</span><span class="sxs-lookup"><span data-stu-id="85a26-140">The solution was to make the behavior configurable.</span></span> <span data-ttu-id="85a26-141">您可以指定适配器是否支持排序，失败是否被移至挂起队列中，或它们是否会导致适配器停止处理并禁用其自身。</span><span class="sxs-lookup"><span data-stu-id="85a26-141">You can specify whether the adapter is to support ordering, whether failures are moved to the Suspended queue, or whether they cause the adapter to stop processing and disable itself.</span></span> <span data-ttu-id="85a26-142">此类行为可配置可以显著减少客户的工作量时将需要编写复杂的业务流程或脚本外部的[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]来实现相同的结果。</span><span class="sxs-lookup"><span data-stu-id="85a26-142">Making such behaviors configurable can significantly simplify customers' lives when they would need to write complex orchestrations or scripts external to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to achieve the same result.</span></span>  
  
## <a name="support-correlation-with-message-queues"></a><span data-ttu-id="85a26-143">支持与消息队列相关联</span><span class="sxs-lookup"><span data-stu-id="85a26-143">Support Correlation with Message Queues</span></span>  
 <span data-ttu-id="85a26-144">许多消息传送平台支持消息标头，以支持应用程序级别请求-响应方案中的相关 ID 的概念。</span><span class="sxs-lookup"><span data-stu-id="85a26-144">Many messaging platforms support the notion of a correlation ID in the message header to support an application-level request-response scenario.</span></span> <span data-ttu-id="85a26-145">示例包括 MQSeries、 MSMQ 和 SQL Service Broker。</span><span class="sxs-lookup"><span data-stu-id="85a26-145">Examples include MQSeries, MSMQ, and SQL Service Broker.</span></span> <span data-ttu-id="85a26-146">这看起来很有吸引力的外部消息传送系统的请求-响应模式映射到中的发送-响应适配器[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="85a26-146">It would seem attractive to map the request-response pattern of the external messaging system to a send-response adapter in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="85a26-147">但这不会由于所在事务不会有用。</span><span class="sxs-lookup"><span data-stu-id="85a26-147">However this does not make sense because of where the transactions live.</span></span> <span data-ttu-id="85a26-148">具体而言，发送到外部消息传送系统需要事务性提交之前的另一端的队列看到的数据。</span><span class="sxs-lookup"><span data-stu-id="85a26-148">Specifically, a send to the external messaging system requires a transactional commit before the other end of the queue sees the data.</span></span> <span data-ttu-id="85a26-149">接收也必须在单独的事务。</span><span class="sxs-lookup"><span data-stu-id="85a26-149">The receive must also be a separate transaction.</span></span>  
  
 <span data-ttu-id="85a26-150">中的解决方案[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]是：</span><span class="sxs-lookup"><span data-stu-id="85a26-150">The solution in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] is to:</span></span>  
  
- <span data-ttu-id="85a26-151">在业务流程中使用相关集</span><span class="sxs-lookup"><span data-stu-id="85a26-151">Use correlation sets in orchestration</span></span>  
  
- <span data-ttu-id="85a26-152">配置两个单独的端口： 一个用于发送和接收</span><span class="sxs-lookup"><span data-stu-id="85a26-152">Configure two separate ports: one for the send and one for the receive</span></span>  
  
  <span data-ttu-id="85a26-153">在简单的示例业务流程指定适配器与消息关联的相关 ID。</span><span class="sxs-lookup"><span data-stu-id="85a26-153">In a simple case the orchestration specifies the correlation ID that is associated with the message by the adapter.</span></span> <span data-ttu-id="85a26-154">这是作为传递到适配器上下文属性对消息。</span><span class="sxs-lookup"><span data-stu-id="85a26-154">This is passed to the adapter as a context property on the message.</span></span> <span data-ttu-id="85a26-155">在更复杂的情况下，该方案调用外部消息传送系统分配 id。</span><span class="sxs-lookup"><span data-stu-id="85a26-155">In a more complex case, the scenario calls for the external messaging system to allocate the ID.</span></span> <span data-ttu-id="85a26-156">在这种情况下它可以传递从发送端口业务流程并带有响应消息。</span><span class="sxs-lookup"><span data-stu-id="85a26-156">In this case it can be passed back from the send port to the orchestration with a response message.</span></span> <span data-ttu-id="85a26-157">此响应消息只是传回 ID，并不是真正的消息响应。</span><span class="sxs-lookup"><span data-stu-id="85a26-157">This response message is just to pass back the ID and is not the true message response.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="85a26-158">争用条件中没有业务流程引擎，以便该消息的真正响应有可能赢取显示发送的 ID 响应。</span><span class="sxs-lookup"><span data-stu-id="85a26-158">There is a race condition in the orchestration engine such that the true response to the message could win against the ID response from the send.</span></span> <span data-ttu-id="85a26-159">必须在业务流程本身中处理此争用条件。</span><span class="sxs-lookup"><span data-stu-id="85a26-159">This race condition must be handled in the orchestration itself.</span></span>