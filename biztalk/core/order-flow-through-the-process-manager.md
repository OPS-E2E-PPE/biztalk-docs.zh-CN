---
title: "顺序流通过进程管理器 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- process management solution tutorial, processing
- processing, processing logic
ms.assetid: e2b51eff-44b5-440f-a7d1-0872543e5f27
caps.latest.revision: "30"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 8556bce43ba4a951d0045d22f76d4bd222fcd8f2
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="order-flow-through-the-process-manager"></a><span data-ttu-id="a3b10-102">顺序流通过进程管理器</span><span class="sxs-lookup"><span data-stu-id="a3b10-102">Order Flow through the Process Manager</span></span>
<span data-ttu-id="a3b10-103">本部分介绍如何南广视频订购过程管理器， **OrderManager**业务流程、 进程订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-103">This section describes how the Southridge Video order process manager, the **OrderManager** orchestration, processes orders.</span></span> <span data-ttu-id="a3b10-104">本部分将跟踪一份新订单在业务流程中的处理过程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-104">This section follows a new order through the orchestration.</span></span> <span data-ttu-id="a3b10-105">本部分还讨论了业务流程如何处理对订单的更新。</span><span class="sxs-lookup"><span data-stu-id="a3b10-105">The section also discusses how the orchestration handles updates to orders.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3b10-106">业务流程管理器解决方案只包含一个流程管理器，尽管该解决方案已编写为可以使用多种类型的管理器。</span><span class="sxs-lookup"><span data-stu-id="a3b10-106">The business process manager solution includes only one process manager although it is written so that it can use more than one type of manager.</span></span>  
  
 <span data-ttu-id="a3b10-107">**OrderManager** orchestration 协调实现业务流程来处理顺序的从属业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-107">The **OrderManager** orchestration coordinates subordinate orchestrations that implement the business process to handle the order.</span></span> <span data-ttu-id="a3b10-108">**OrderManager**发送的顺序通过两个阶段，结合使用，验证订单、 将信息发送到设备组、 将顺序发送到通过远程处理组件订单系统和更新的订单历史记录。</span><span class="sxs-lookup"><span data-stu-id="a3b10-108">The **OrderManager** sends the order through two stages which, combined, validate the order, send the information to the facilities group, send the order to the order system through remoting components, and update the order history.</span></span> <span data-ttu-id="a3b10-109">你可以添加、 删除或修改这些阶段，而无需更改**OrderManager**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-109">You can add, delete, or modify these stages without having to change the **OrderManager**.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3b10-110">由于的大小和作用域**OrderManager**业务流程，你可能想要阅读此部分与 Microsoft Visual Studio 中打开业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-110">Because of the size and scope of the **OrderManager** orchestration, you may want to read this section with the orchestration open in Microsoft Visual Studio.</span></span>  
  
## <a name="order-manager-structure"></a><span data-ttu-id="a3b10-111">顺序 Manager 结构</span><span class="sxs-lookup"><span data-stu-id="a3b10-111">Order Manager Structure</span></span>  
 <span data-ttu-id="a3b10-112">**OrderManager** orchestration 开头激活业务流程的接收形状。</span><span class="sxs-lookup"><span data-stu-id="a3b10-112">The **OrderManager** orchestration begins with a receive shape that activates the orchestration.</span></span> <span data-ttu-id="a3b10-113">下图显示的一般结构**OrderManager**业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-113">The following diagram shows the general structure of the **OrderManager** orchestration.</span></span>  
  
 <span data-ttu-id="a3b10-114">![阻止关系图的顺序管理器](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")</span><span class="sxs-lookup"><span data-stu-id="a3b10-114">![Block Diagram of Order Manager](../core/media/ordermanagerblockdiagram.gif "OrderManagerBlockDiagram")</span></span>  
  
 <span data-ttu-id="a3b10-115">第一个接收形状将通向两个主要分支。</span><span class="sxs-lookup"><span data-stu-id="a3b10-115">The first receive shape leads to two main branches.</span></span> <span data-ttu-id="a3b10-116">一个分支（右侧的分支）用于处理新订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-116">One branch, the right one, processes new orders.</span></span> <span data-ttu-id="a3b10-117">而左侧的分支则处理订单取消。</span><span class="sxs-lookup"><span data-stu-id="a3b10-117">The left branch, handles order cancellations.</span></span> <span data-ttu-id="a3b10-118">它接受用户输入，因为它有可能**OrderManager**已完成订单后接收的顺序取消。</span><span class="sxs-lookup"><span data-stu-id="a3b10-118">Because it accepts user input, it is possible for the **OrderManager** to receive an order cancellation after an order has already completed.</span></span> <span data-ttu-id="a3b10-119">这就是左侧主要分支所要处理的情况。</span><span class="sxs-lookup"><span data-stu-id="a3b10-119">This is the case the left main branch handles.</span></span> <span data-ttu-id="a3b10-120">该分支通过设置用于终止处理操作的标志以及向事件日志添加警告，来处理单个取消。</span><span class="sxs-lookup"><span data-stu-id="a3b10-120">The branch handles the isolated cancellation by setting flags for terminating processing and by adding a warning to the event log.</span></span> <span data-ttu-id="a3b10-121">业务流程将处理正在右侧分支内处理订单时到达的订单取消。</span><span class="sxs-lookup"><span data-stu-id="a3b10-121">The orchestration handles order cancellations that arrive while an order is being processed inside the right-hand branch.</span></span>  
  
 <span data-ttu-id="a3b10-122">订单处理分支执行某种初始化操作，然后进入两个嵌套的循环。</span><span class="sxs-lookup"><span data-stu-id="a3b10-122">The order processing branch does some initialization and then enters two nested loops.</span></span> <span data-ttu-id="a3b10-123">外部循环对订单处理中的每个阶段都会运行一次。</span><span class="sxs-lookup"><span data-stu-id="a3b10-123">The outer loop runs once for each stage in the order processing.</span></span> <span data-ttu-id="a3b10-124">而内部循环则在阶段正进行时运行。</span><span class="sxs-lookup"><span data-stu-id="a3b10-124">The inner loop runs while the stage is processing.</span></span> <span data-ttu-id="a3b10-125">订单管理器还将侦听内部循环中对订单的可能更新。</span><span class="sxs-lookup"><span data-stu-id="a3b10-125">The order manager also listens for possible updates to the order inside the inner loop.</span></span> <span data-ttu-id="a3b10-126">循环终止之后，订单管理器将发送完成消息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-126">After the loops terminate, the order manager sends a completion message.</span></span>  
  
 <span data-ttu-id="a3b10-127">订单处理阶段使用动态、 自助关联的端口进行通信回**OrderManager**业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-127">The order processing stages use dynamic, self-correlating ports to communicate back to the **OrderManager** orchestration.</span></span> <span data-ttu-id="a3b10-128">这简化了相关的**OrderManager**与阶段实例，因为它不需要使用相关集。</span><span class="sxs-lookup"><span data-stu-id="a3b10-128">This simplifies correlation of the **OrderManager** with the stage instances because it eliminates the need to use a correlation set.</span></span> <span data-ttu-id="a3b10-129">有关自相关端口的详细信息，请参阅[端口绑定](../core/port-bindings.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-129">For more information about self-correlating ports, see [Port Bindings](../core/port-bindings.md).</span></span>  
  
## <a name="receiving-orders"></a><span data-ttu-id="a3b10-130">接收订单</span><span class="sxs-lookup"><span data-stu-id="a3b10-130">Receiving Orders</span></span>  
 <span data-ttu-id="a3b10-131">**OrderManager**接收订单消息从**OrderBroker**通过 orchestration **FromBrokerPort**端口。</span><span class="sxs-lookup"><span data-stu-id="a3b10-131">The **OrderManager** receives order messages from the **OrderBroker** orchestration through the **FromBrokerPort** port.</span></span> <span data-ttu-id="a3b10-132">此端口是直接绑定到 MessageBox 数据库。</span><span class="sxs-lookup"><span data-stu-id="a3b10-132">This port is bound directly to the MessageBox database.</span></span> <span data-ttu-id="a3b10-133">业务流程具有两个**接收**形状连接到端口： 一个用于新订单，另一个用于更新订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-133">The orchestration has two **Receive** shapes connected to the port: one for new orders and one for updated orders.</span></span>  
  
 <span data-ttu-id="a3b10-134">**OrderManger**确定哪些消息根据筛选器表达式的过程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-134">The **OrderManger** determines which messages to process based on a filter expression.</span></span> <span data-ttu-id="a3b10-135">筛选表达式消息状态字段和顺序管理器类型字段中，在测试值**OrderMgrType**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-135">The filter expression tests the value in the message status field and the order manager type field, **OrderMgrType**.</span></span> <span data-ttu-id="a3b10-136">如果状态字段值等于已接受，和**OrderMgrType**是 CABLEORDER，顺序是新的和计划用于此进程管理器。</span><span class="sxs-lookup"><span data-stu-id="a3b10-136">If the status field is equal to ACCEPTED, and the **OrderMgrType** is CABLEORDER, the order is new and intended for this process manager.</span></span>  
  
 <span data-ttu-id="a3b10-137">新订单将激活新的业务流程实例。</span><span class="sxs-lookup"><span data-stu-id="a3b10-137">The new order activates a new instance of the orchestration.</span></span> <span data-ttu-id="a3b10-138">**OrderManager**下一步检查的类型中的请求**决策**形状。</span><span class="sxs-lookup"><span data-stu-id="a3b10-138">The **OrderManager** next checks the type of the request in a **Decision** shape.</span></span> <span data-ttu-id="a3b10-139">如果该类型为“终止”，则业务流程将执行左侧分支，并终止订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-139">If the type is Terminate, the orchestration executes the left-hand branch and terminates the order.</span></span> <span data-ttu-id="a3b10-140">否则，业务流程将继续处理该订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-140">Otherwise, the orchestration proceeds with processing the order.</span></span> <span data-ttu-id="a3b10-141">请注意，这包括侦听与此特定订单相关的随后的消息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-141">Notice that this includes listening for subsequent messages related to this particular order.</span></span>  
  
## <a name="initialization-for-new-orders"></a><span data-ttu-id="a3b10-142">初始化的新订单</span><span class="sxs-lookup"><span data-stu-id="a3b10-142">Initialization for New Orders</span></span>  
 <span data-ttu-id="a3b10-143">后**OrderManager** orchestration 接收初始消息，并开始主右侧分支时，它获取其配置信息**SSOConfigStore**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-143">After the **OrderManager** orchestration receives an initial message and begins the main right-hand branch, it gets its configuration information from the **SSOConfigStore**.</span></span> <span data-ttu-id="a3b10-144">这是通过单一实例对象中定义**实用工具**程序集。</span><span class="sxs-lookup"><span data-stu-id="a3b10-144">It does this through a singleton object defined in the **Utilities** assembly.</span></span> <span data-ttu-id="a3b10-145">配置值都是该对象的属性。</span><span class="sxs-lookup"><span data-stu-id="a3b10-145">The configuration values are properties of the object.</span></span> <span data-ttu-id="a3b10-146">对象管理的配置值类似于面向服务的体系结构解决方案的本地缓存。</span><span class="sxs-lookup"><span data-stu-id="a3b10-146">The object manages a local cache of the configuration values similar to the Service Oriented Architecture solution.</span></span> <span data-ttu-id="a3b10-147">有关单一实例对象的详细信息，请参阅[业务流程管理解决方案中有效使用 SSO](../core/using-sso-efficiently-in-the-business-process-management-solution.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-147">For more information about the singleton object, see [Using SSO Efficiently in the Business Process Management Solution](../core/using-sso-efficiently-in-the-business-process-management-solution.md).</span></span>  
  
 <span data-ttu-id="a3b10-148">面向服务的解决方案，业务流程管理解决方案使用密钥存储，因为它是每次安装 BizTalk 时，存在类似 SSO 缓存的配置信息，以便值尚不可用，并且它可以保护数据库连接字符串和密码等信息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-148">Like the Service Oriented solution, the Business Process Management solution uses the secret store because it is present whenever BizTalk is installed, SSO caches the configuration information so that the values are readily available, and it can protect information such as database connection strings and passwords.</span></span> <span data-ttu-id="a3b10-149">对于所有这些原因，机密存储将是一个好的配置信息，即使上单一登录没有用于管理连接到后端应用程序。</span><span class="sxs-lookup"><span data-stu-id="a3b10-149">For all of these reasons, the secret store would be a good place for the configuration information even if Single Sign-On weren't being used for managing connections to the backend applications.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3b10-150">业务流程在开始处理前将检索配置信息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-150">The orchestration retrieves configuration information before starting processing.</span></span> <span data-ttu-id="a3b10-151">这可确保业务流程在冻结并随后解冻后，仍然使用同一配置。</span><span class="sxs-lookup"><span data-stu-id="a3b10-151">This ensures the orchestration uses the same configuration if it is dehydrated and, later, rehydrated.</span></span> <span data-ttu-id="a3b10-152">有关冻结的详细信息，请参阅[Orchestration 冻结和 Rehydration](../core/orchestration-dehydration-and-rehydration.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-152">For more information about dehydration, see [Orchestration Dehydration and Rehydration](../core/orchestration-dehydration-and-rehydration.md).</span></span>  
  
 <span data-ttu-id="a3b10-153">顺序管理器使用从配置数据的一个值： **TotalStages**，处理过程的顺序中的各个阶段的总数。</span><span class="sxs-lookup"><span data-stu-id="a3b10-153">The order manager uses one value from the configuration data: **TotalStages**, the total number of stages in the order handling process.</span></span> <span data-ttu-id="a3b10-154">管理器将此值分配给局部变量， **numStages**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-154">The manager assigns this value to a local variable, **numStages**.</span></span> <span data-ttu-id="a3b10-155">它还将设置连接到外部循环中，两个多个变量**阶段**和**停止**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-155">It also sets two more variables connected to the outer loop, **stage** and **stop**.</span></span> <span data-ttu-id="a3b10-156">**阶段**表示的当前阶段，它是外部循环; 的计数器**停止**停止值。</span><span class="sxs-lookup"><span data-stu-id="a3b10-156">The **stage** indicates the current stage and is the counter for the outer loop; **stop** the stopping value.</span></span>  
  
 <span data-ttu-id="a3b10-157">最后，该管理器设置**orderStatus**变量已启动并进入外部处理循环。</span><span class="sxs-lookup"><span data-stu-id="a3b10-157">Finally, the manager sets the **orderStatus** variable to STARTED and enters the outer processing loop.</span></span>  
  
## <a name="new-order-processing-loops"></a><span data-ttu-id="a3b10-158">新的顺序处理循环</span><span class="sxs-lookup"><span data-stu-id="a3b10-158">New Order Processing Loops</span></span>  
 <span data-ttu-id="a3b10-159">外部循环的值作为长时间运行**阶段**变量小于的值**numStages**变量。</span><span class="sxs-lookup"><span data-stu-id="a3b10-159">The outer loop runs as long as the value of the **stage** variable is less than the value of the **numStages** variable.</span></span> <span data-ttu-id="a3b10-160">外部循环驱动器的每个阶段的处理。</span><span class="sxs-lookup"><span data-stu-id="a3b10-160">The outer loops drives the processing for each stage.</span></span> <span data-ttu-id="a3b10-161">内部循环运行处理程序，但前提是仍在处理某一阶段。</span><span class="sxs-lookup"><span data-stu-id="a3b10-161">The inner loop runs so long as a stage is still being processed.</span></span> <span data-ttu-id="a3b10-162">它还会侦听顺序可能发生的更改。</span><span class="sxs-lookup"><span data-stu-id="a3b10-162">It also listens for possible changes to the order.</span></span>  
  
### <a name="outer-loop"></a><span data-ttu-id="a3b10-163">外部循环</span><span class="sxs-lookup"><span data-stu-id="a3b10-163">Outer Loop</span></span>  
 <span data-ttu-id="a3b10-164">业务流程首先外部循环分配收到的消息 (**NewOrderMgrMsg**) 给一个变量， **OrderMgrMsg**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-164">The orchestration begins the outer loop by assigning the received message (**NewOrderMgrMsg**) to a variable, **OrderMgrMsg**.</span></span> <span data-ttu-id="a3b10-165">然后，它将阶段和状态复制到消息的路由部分。</span><span class="sxs-lookup"><span data-stu-id="a3b10-165">It then copies the stage and status to the routing part of the message.</span></span> <span data-ttu-id="a3b10-166">业务流程还设置寄信人地址的地址将邮件中**StageCompletionPort**:</span><span class="sxs-lookup"><span data-stu-id="a3b10-166">The orchestration also sets the return address in the message to the address of the **StageCompletionPort**:</span></span>  
  
```  
OrderMgrMsg.RoutingPart.OrderMgrReturnAddress =   
       StageCompletionPort(Microsoft.XLANGs.BaseTypes.Address);  
```  
  
 <span data-ttu-id="a3b10-167">然后，业务流程将发送到的顺序**StagePort**，请求-响应端口。</span><span class="sxs-lookup"><span data-stu-id="a3b10-167">The orchestration then sends the order to the **StagePort**, a solicit-response port.</span></span> <span data-ttu-id="a3b10-168">随后，业务流程将等待来自已启动订单处理的阶段的确认。</span><span class="sxs-lookup"><span data-stu-id="a3b10-168">The orchestration then waits for an acknowledgement from the stage that order processing has started.</span></span> <span data-ttu-id="a3b10-169">阶段发送**OrderAck**消息启动处理订单时。</span><span class="sxs-lookup"><span data-stu-id="a3b10-169">The stage sends an **OrderAck** message when it starts processing the order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3b10-170">**OrderAck**消息是由.NET 类，而不是架构解决方案中的多个之一。</span><span class="sxs-lookup"><span data-stu-id="a3b10-170">The **OrderAck** message is one of several in the solution defined by .NET classes rather than a schema.</span></span> <span data-ttu-id="a3b10-171">有关使用.NET 类来定义消息的详细信息，请参阅[在用户代码中构造消息](../core/constructing-messages-in-user-code.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-171">For more information about using .NET classes to define messages, see [Constructing Messages in User Code](../core/constructing-messages-in-user-code.md).</span></span>  
  
 <span data-ttu-id="a3b10-172">当业务流程收到确认时，它将分配到阶段**currentStage**变量，并输入内部循环。</span><span class="sxs-lookup"><span data-stu-id="a3b10-172">When the orchestration receives the acknowledgement, it assigns the stage to the **currentStage** variable and enters the inner loop.</span></span>  
  
### <a name="inner-loop"></a><span data-ttu-id="a3b10-173">内部循环</span><span class="sxs-lookup"><span data-stu-id="a3b10-173">Inner Loop</span></span>  
 <span data-ttu-id="a3b10-174">内部循环将一直运行长达**currentStage**变量等于**阶段**变量; 即，只要正在处理的当前阶段。</span><span class="sxs-lookup"><span data-stu-id="a3b10-174">The inner loop runs as long as the **currentStage** variable is equal to the **stage** variable; that is, as long as the current stage is being processed.</span></span> <span data-ttu-id="a3b10-175">循环的正文是**侦听**有三个形状**接收**形状。</span><span class="sxs-lookup"><span data-stu-id="a3b10-175">The body of the loop is a **Listen** shape with three **Receive** shapes.</span></span> <span data-ttu-id="a3b10-176">业务流程中的最左侧形状**顺序请求**，是在下一部分中所述的顺序更新机制的一部分。</span><span class="sxs-lookup"><span data-stu-id="a3b10-176">The leftmost shape in the orchestration, **Order Request**, is part of the order update mechanism, described in the next section.</span></span>  
  
 <span data-ttu-id="a3b10-177">当一个订单处理阶段完成的情况下，它将消息发送到**StageCompletion**端口**OrderManager**业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-177">When an order processing stage finishes, it sends a message to the **StageCompletion** port of the **OrderManager** orchestration.</span></span> <span data-ttu-id="a3b10-178">如果由于错误突然终止阶段，则将发送**TerminatedMessage**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-178">If the stage abruptly terminates due to an error, it sends a **TerminatedMessage**.</span></span> <span data-ttu-id="a3b10-179">在这种情况下， **OrderManager**引发异常。</span><span class="sxs-lookup"><span data-stu-id="a3b10-179">In this case, the **OrderManager** throws an exception.</span></span> <span data-ttu-id="a3b10-180">最外面的异常处理程序捕捉异常并将发送到错误消息**OperatorPort**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-180">The outermost exception handler catches the exception and sends an error message to the **OperatorPort**.</span></span>  
  
 <span data-ttu-id="a3b10-181">如果阶段发送**OrderMgrMsg**、 **OrderManager**增量**阶段**变量。</span><span class="sxs-lookup"><span data-stu-id="a3b10-181">If the stage sends an **OrderMgrMsg**, the **OrderManager** increments the **stage** variable.</span></span> <span data-ttu-id="a3b10-182">如果有多个阶段 （阶段小于或等于到 numStages），业务流程设置订单状态**OrderMgrMsg**到 STAGE_n_COMPLETED 其中 n 是数的当前阶段。</span><span class="sxs-lookup"><span data-stu-id="a3b10-182">If there are more stages (stage less than or equal to numStages), the orchestrations sets the order status in **OrderMgrMsg** to STAGE_n_COMPLETED where n is the number of the current stage.</span></span> <span data-ttu-id="a3b10-183">如果没有其他阶段，则业务流程将订单状态设置为 COMPLETED，并退出这两个循环。</span><span class="sxs-lookup"><span data-stu-id="a3b10-183">If there are no more stages, it sets the order status to COMPLETED and exits both loops.</span></span>  
  
## <a name="order-updates"></a><span data-ttu-id="a3b10-184">订单更新</span><span class="sxs-lookup"><span data-stu-id="a3b10-184">Order Updates</span></span>  
 <span data-ttu-id="a3b10-185">**OrderManager** orchestration 侦听的内部处理循环内的订单更新。</span><span class="sxs-lookup"><span data-stu-id="a3b10-185">The **OrderManager** orchestration listens for order updates inside the inner processing loop.</span></span> <span data-ttu-id="a3b10-186">请注意，**接收**调整该为此，使用**OrderRequest**，还使用**FromBrokerPort**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-186">Notice that the **Receive** shape it uses for this, **OrderRequest**, also uses the **FromBrokerPort**.</span></span> <span data-ttu-id="a3b10-187">如果在循环中同一端口上使用第二个接收形状，并将其与相关集进行组合，则会形成通用 BizTalk Server 模式：保护模式。</span><span class="sxs-lookup"><span data-stu-id="a3b10-187">The use of a second receive shape on the same port inside a loop, combined with correlation sets, forms a common BizTalk Server pattern, the convoy pattern.</span></span> <span data-ttu-id="a3b10-188">使用保护模式可确保同一业务流程实例处理与特定操作连接的第一条及其后续消息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-188">You use the convoy pattern to ensure that the same instance of an orchestration processes the first and subsequent messages connected with a particular operation.</span></span>  
  
 <span data-ttu-id="a3b10-189">在订单管理器收到连接到订单的第一条消息后，它将初始化两个相关集。</span><span class="sxs-lookup"><span data-stu-id="a3b10-189">When the order manager receives the first message connected to an order, it initializes two correlation sets.</span></span> <span data-ttu-id="a3b10-190">首先， **OrderCorrelation**，使用客户 ID (**CustID**) 和订单 ID (**OrderID**)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-190">The first, **OrderCorrelation**, uses the customer ID (**CustID**) and order ID (**OrderID**).</span></span> <span data-ttu-id="a3b10-191">订单管理器与订单处理阶段共享此相关。</span><span class="sxs-lookup"><span data-stu-id="a3b10-191">The order manager shares this correlation with the order processing stages.</span></span> <span data-ttu-id="a3b10-192">第二个相关是队列相关**OrderConvoyCorrelation**，它使用订单状态 (**状态**) 除了客户 ID 和订单 id。</span><span class="sxs-lookup"><span data-stu-id="a3b10-192">The second correlation is the convoy correlation, **OrderConvoyCorrelation**, which uses the order status (**Status**) in addition to the customer ID and order ID.</span></span> <span data-ttu-id="a3b10-193">**OrderRequestReceive**调整使用**OrderConvoyCorrelation**作为以下相关设置。</span><span class="sxs-lookup"><span data-stu-id="a3b10-193">The **OrderRequestReceive** shape uses **OrderConvoyCorrelation** as a Following Correlation Set.</span></span> <span data-ttu-id="a3b10-194">按此方式设置相关集可确保处理特定订单的订单管理器实例能够接收任何更改。</span><span class="sxs-lookup"><span data-stu-id="a3b10-194">Setting the correlation set up this way ensures that the instance of the order manager working on a particular order receives any changes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a3b10-195">请回忆一下，相关集是用于确定消息是否属于给定业务流程实例的消息属性的分组。</span><span class="sxs-lookup"><span data-stu-id="a3b10-195">Recall that a correlation set is a grouping of message properties used to determine whether or not a message belongs to a given instance of an orchestration.</span></span> <span data-ttu-id="a3b10-196">有关详细信息，请参阅[在业务流程中使用相关性](../core/using-correlations-in-orchestrations.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-196">For more information, see [Using Correlations in Orchestrations](../core/using-correlations-in-orchestrations.md).</span></span>  
  
 <span data-ttu-id="a3b10-197">当**OrderManager**接收后续消息的订单时，它首先测试的请求的类型。</span><span class="sxs-lookup"><span data-stu-id="a3b10-197">When the **OrderManager** receives a subsequent message for an order, it first tests the type of request.</span></span> <span data-ttu-id="a3b10-198">如果请求类型为 TERMINATE，则决策形状将执行终止分支。</span><span class="sxs-lookup"><span data-stu-id="a3b10-198">If the request type is TERMINATE, the Decision shape executes the terminate branch.</span></span> <span data-ttu-id="a3b10-199">否则，业务流程将测试新消息，以查看它是否是更新消息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-199">Otherwise, the orchestration tests the new message to see if it is an update.</span></span> <span data-ttu-id="a3b10-200">更新消息具有更高版本的序列号 (**SeqNum**) 与原始请求。</span><span class="sxs-lookup"><span data-stu-id="a3b10-200">An update message has a higher sequence number (**SeqNum**) than the original request.</span></span> <span data-ttu-id="a3b10-201">如果新消息的序列号更高，则业务流程将对新消息启动订单处理。</span><span class="sxs-lookup"><span data-stu-id="a3b10-201">If the new message's sequence number is higher, the orchestration starts the order processing over with the new message.</span></span> <span data-ttu-id="a3b10-202">如果原始消息和更新消息具有相同或更低的序列号，则说明存在序列错误。</span><span class="sxs-lookup"><span data-stu-id="a3b10-202">If the original and update message have the same or a lower sequence number, there is a sequence error.</span></span> <span data-ttu-id="a3b10-203">如果序列号相等，则更新消息为重复订单，并将标记为重复错误。</span><span class="sxs-lookup"><span data-stu-id="a3b10-203">If the sequence numbers are equal, it is a duplicate order and flagged as a duplicate error.</span></span>  
  
 <span data-ttu-id="a3b10-204">有关详细信息**SeqNum**，请参阅[密钥消息和字段](../core/key-messages-and-fields.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-204">For more information about **SeqNum**, see [Key Messages and Fields](../core/key-messages-and-fields.md).</span></span>  
  
## <a name="final-steps"></a><span data-ttu-id="a3b10-205">最后的步骤</span><span class="sxs-lookup"><span data-stu-id="a3b10-205">Final Steps</span></span>  
 <span data-ttu-id="a3b10-206">退出循环之后, 的顺序管理器将的答复地址分配给了动态端口**CSRCompletionPort**。</span><span class="sxs-lookup"><span data-stu-id="a3b10-206">After exiting the loops, the order manager assigns the reply address to the dynamic port **CSRCompletionPort**.</span></span> <span data-ttu-id="a3b10-207">然后，管理器将构造完成状态消息，并发送该消息，然后测试是否存在错误。</span><span class="sxs-lookup"><span data-stu-id="a3b10-207">The manager then constructs the completion status message, sends it, and then tests if there was an error.</span></span> <span data-ttu-id="a3b10-208">若有错误，则业务流程将执行终止形状；否则，将正常结束。</span><span class="sxs-lookup"><span data-stu-id="a3b10-208">If there was an error, the orchestration exectues a Terminate shape; otherwise, it simply ends.</span></span>  
  
## <a name="coordinating-with-the-stages"></a><span data-ttu-id="a3b10-209">与阶段协作</span><span class="sxs-lookup"><span data-stu-id="a3b10-209">Coordinating with the Stages</span></span>  
 <span data-ttu-id="a3b10-210">这两个**OrderBroker**业务流程和第二个处理阶段业务流程 (**CableOrder2**) 历史记录数据库中创建条目。</span><span class="sxs-lookup"><span data-stu-id="a3b10-210">Both the **OrderBroker** orchestration and the second processing stage orchestration (**CableOrder2**) make entries in the history database.</span></span> <span data-ttu-id="a3b10-211">CableOrder2 业务流程更新输入的历史记录信息**OrderBroker**业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-211">The CableOrder2 orchestration updates the history information entered by the **OrderBroker** orchestration.</span></span> <span data-ttu-id="a3b10-212">为了确保在要更新的数据库中没有条目**OrderBroker**使用它的数据库使用的端口上传递通知。</span><span class="sxs-lookup"><span data-stu-id="a3b10-212">In order to ensure there is an entry in the database to update, the **OrderBroker** uses delivery notification on the port it uses for the database.</span></span>  
  
 <span data-ttu-id="a3b10-213">配置映射**OrderBroker**将历史记录数据库的端口发送到包含两个端口的发送端口组-一个用于测试配置端口 (**HistoryInsert 测试 SP**)，一个用于常规配置 (**HistoryInsert SP**)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-213">Configuration maps the **OrderBroker** send port for the history database to a send port group containing two ports—one port for the test configuration (**HistoryInsert-Test-SP**), one for the regular configuration (**HistoryInsert-SP**).</span></span> <span data-ttu-id="a3b10-214">如果将该组中的两个端口都保持活动状态，则解决方案将同时向这两个端口发送消息。</span><span class="sxs-lookup"><span data-stu-id="a3b10-214">If you leave both ports in the group active, the solution sends messages on both ports.</span></span> <span data-ttu-id="a3b10-215">因而，该解决方案将请求两个送达通知，但仅处理其中一个通知。</span><span class="sxs-lookup"><span data-stu-id="a3b10-215">It thus requests two delivery notifications but processes only one.</span></span>  
  
 <span data-ttu-id="a3b10-216">若要避免这种情况下，取消登记测试端口 (**HistoryInsert 测试 SP**)，或停止应用程序的测试版本。</span><span class="sxs-lookup"><span data-stu-id="a3b10-216">To avoid this situation, unenlist the test port (**HistoryInsert-Test-SP**), or stop the test version of the application.</span></span> <span data-ttu-id="a3b10-217">有关传递通知的详细信息，请参阅[使用确认](../core/using-acknowledgments.md)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-217">For more information about delivery notification, see [Using Acknowledgments](../core/using-acknowledgments.md).</span></span>  
  
## <a name="errors-and-routing-repaired-messagesdesign-choices"></a><span data-ttu-id="a3b10-218">错误和路由修复消息 — 设计选择</span><span class="sxs-lookup"><span data-stu-id="a3b10-218">Errors and Routing Repaired Messages—Design Choices</span></span>  
 <span data-ttu-id="a3b10-219">异常处理程序业务流程和业务流程由订单处理阶段使用一个错误处理业务流程 (**ErrorHandlerOrch**) 路由修复错误订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-219">The exception handler orchestration and orchestrations used by the order processing stages use an error handling orchestration (**ErrorHandlerOrch**) to route bad orders for repair.</span></span> <span data-ttu-id="a3b10-220">在设计中，假设有一个部门或组需要以所需格式修复订单。</span><span class="sxs-lookup"><span data-stu-id="a3b10-220">The design supposes that there is a department or group that will fix the order in the form needed.</span></span> <span data-ttu-id="a3b10-221">不通过顺序 broker 业务流程已重新提交的修复后的顺序 (**OrderBroker**)。</span><span class="sxs-lookup"><span data-stu-id="a3b10-221">The repaired order is not resubmitted through the order broker orchestration (**OrderBroker**).</span></span> <span data-ttu-id="a3b10-222">而是将规范化的订单以其规范化格式进行修复。</span><span class="sxs-lookup"><span data-stu-id="a3b10-222">Rather, the normalized order is repaired in its normalized form.</span></span> <span data-ttu-id="a3b10-223">当前设计的解决方案具有处理程序业务流程，该业务流程可以将错误消息路由回原始订单的源。</span><span class="sxs-lookup"><span data-stu-id="a3b10-223">The current design of the solution has the handler orchestration route the error message back to the source of the original order.</span></span> <span data-ttu-id="a3b10-224">但是，修复的订单必须路由到错误处理程序业务流程上的 MSMQ 端口。</span><span class="sxs-lookup"><span data-stu-id="a3b10-224">Repaired orders, however, have to be routed to an MSMQ port on the error handler orchestration.</span></span> <span data-ttu-id="a3b10-225">（解决方案的测试版本使用文件夹。）然后，错误处理程序将修复的消息返回到发起调用的业务流程。</span><span class="sxs-lookup"><span data-stu-id="a3b10-225">(The test version of the solution uses a file folder.) The error handler then returns the repaired message to the calling orchestration.</span></span>  
  
 <span data-ttu-id="a3b10-226">此解决方案之所以使用该设计是因为 OrderBroker 会对订单消息进行重要验证和规范化。</span><span class="sxs-lookup"><span data-stu-id="a3b10-226">This solution uses this design, because the order broker does significant validation and normalization of the order message.</span></span> <span data-ttu-id="a3b10-227">从而，需要修复的订单消息也会采用规范化格式。</span><span class="sxs-lookup"><span data-stu-id="a3b10-227">In turn, the order message requiring repair is also in the normalized form.</span></span> <span data-ttu-id="a3b10-228">如果保持消息的规范化格式，则无需处理消息的已提交格式与规范化格式之间的差异问题。</span><span class="sxs-lookup"><span data-stu-id="a3b10-228">Maintaining the normalized form of the message prevents having to work around the difference between the submitted and normalized forms of the messages.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a3b10-229">另请参阅</span><span class="sxs-lookup"><span data-stu-id="a3b10-229">See Also</span></span>  
 <span data-ttu-id="a3b10-230">[过程管理器逻辑](../core/process-manager-logic.md) </span><span class="sxs-lookup"><span data-stu-id="a3b10-230">[Process Manager Logic](../core/process-manager-logic.md) </span></span>  
 [<span data-ttu-id="a3b10-231">关键信息和字段</span><span class="sxs-lookup"><span data-stu-id="a3b10-231">Key Messages and Fields</span></span>](../core/key-messages-and-fields.md)