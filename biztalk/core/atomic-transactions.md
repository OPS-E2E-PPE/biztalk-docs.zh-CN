---
title: 原子事务 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- atomic transactions
- scopes, examples
- transactions, orchestrations
- orchestrations, transactions
- transactions, isolation levels
- transactions, ACID concept
- transactions, examples
- transactions, atomic
- scopes, transactions
- scopes
ms.assetid: 5030e1fd-943f-42bc-9296-4f315bd5f733
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 79512ead7a9ec91fe1558643fa66747e6674eee6
ms.sourcegitcommit: d27732e569b0897361dfaebca8352aa97bb7efe1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/10/2019
ms.locfileid: "65530696"
---
# <a name="atomic-transactions"></a>原子事务
BizTalk 业务流程可以用于运行不同部分的工作，按照事务的传统 ACID 概念。 工作，在执行时，这些离散的或原子单元将业务流程从一个一致的状态移到新的、 一致和持久的状态独立于其他工作单位。 这通常是通过使用**作用域**构造，它封装的使用事务性语义的工作单元。 此外可以为无需使用一个原子事务的作用域定义整个业务流程。 作用域，但是，不能标记为事务性的除非业务流程本身标记为长期或原子事务类型。 原子事务保证，任何部分更新自动发生故障时在过程中回滚事务的更新，并将删除事务的影响 (除外的任何.NET 调用中所做的效果事务）。 BizTalk 业务流程中的原子事务是类似于分布式的事务处理协调器 (DTC) 事务，因为它们生存期通常较短并且具有四个"ACID"属性 （原子性、 一致性、 隔离和持续性）：  
  
- **原子性**  
  
   一个事务就表示原子工作单元。 要么执行事务内的所有修改，要么不都执行任何所做的修改。  
  
- **一致性**  
  
   在提交时，事务必须保留在系统中的数据的完整性。 如果事务是该事务开始前内部一致的数据库上执行数据修改，数据库仍必须在内部一致提交事务时。 确保此属性是很大程度上应用程序开发人员的责任。  
  
- **隔离**  
  
   由并发事务所做的修改必须与其他并发事务所做的修改隔离。 并发运行的隔离级别事务执行的修改将保持内部数据库一致性，如果按顺序运行事务的样子。  
  
- **持续性**  
  
   提交事务后，所有修改都都永久就地默认情况下在系统中。 即使系统发生故障，持久保存所做的修改。  
  
  使用 BizTalk 业务流程中的原子事务支持以下隔离级别：  
  
- **已提交读**  
  
   正在读取数据以避免脏读，但可以结束该事务，从而导致不可重复读取或幻像数据之前更改数据时保持共享的锁。  
  
- **可重复读**  
  
   在查询中，从而阻止其他用户更新的数据所使用的所有数据上放置锁。 这防止了不可重复读取，但有仍有可能产生幻像行。  
  
- **可序列化**  
  
   防止其他用户更新或将行插入到数据库，在事务完成之前放置范围锁。  
  
  BizTalk Server 确保原子事务内的状态变化 — 例如对变量、 消息和对象的修改 — 仅在事务提交后在原子事务的作用域外可见。 中间状态的变化是独立于业务流程的其他部分。  
  
> [!NOTE]
>  如果某一原子事务包含**接收**形状**发送**形状，或**启动业务流程**形状，则相应操作不会发生之前事务已提交。  
  
 如果需要完整的 ACID 属性的数据 — 例如，当数据必须是独立于其他事务，必须以独占方式使用原子事务。  
  
 当某一原子事务失败时，所有状态将重都置，如同业务流程实例永远不会进入该作用域。 该规则 BizTalk 具有原子事务是所有变量 （而不仅仅是本地的范围） 都参与该事务。 所有不可序列化的变量和使用原子事务中的消息应声明为作用域; 的本地否则，编译器将产生"变量...未标记为可序列化"错误。 所有原子作用域被认为"同步"和业务流程编译器将提供对冗余的使用，一条警告，如果确实同步的关键字用于原子作用域。 共享数据的同步扩展从直到成功完成 （包括范围的结束时的状态持久化） 的作用域范围的开始或完成的异常处理程序 （如果出错）。 同步域不会扩展到补偿处理程序。  
  
 原子事务可以与该业务流程将停止事务并且实例的点就将挂起超时值相关联。 如果原子事务包含接收形状、 发送形状或启动业务流程形状，则相应操作之前不会发生提交该事务。  
  
 原子事务重试时用户故意引发**RetryTransactionException**或者如果**PersistenceException**在原子事务尝试提交时引发。 例如，在原子事务是分布式的 DTC 事务和一些其他参与者的一部分，停止该事务的事务时，可能发生后一种。 同样，如果在事务正尝试提交的时存在数据库连接问题，则也可能**PersistenceException**引发。 如果发生这种情况有的原子作用域**重试 = True**，则它将重试最多 21 次。 每次重试之间的延迟为 2 秒默认情况下 （但这是可修改）。 21 次重试已经耗尽，如果仍无法提交事务后，则挂起整个业务流程实例。 可以手动恢复，并且它将重新开始，使用新的计数器，从冲突原子作用域的开头。  
  
> [!NOTE]
>  仅**RetryTransactionException**并**PersistenceException**可能会导致原子作用域以重试。 在原子作用域中引发的任何其他异常不会导致它重试，即使**重试**属性设置为**True**。 每个两个连续重试之间的两个 2 秒的默认延迟可以通过使用公共属性上重写**RetryTransactionException** （如果这是用于导致重试的异常）。  
  
 原子作用域具有对嵌套其他事务不能嵌套其他事务或包括的限制**捕获的异常**块。  
  
## <a name="dtc-transactions"></a>DTC 事务  
 尽管原子事务在行为上类似 DTC 事务，它们不是显式默认的 DTC 事务。 您可以显式使它们 DTC 事务，前提是用在事务中任何对象是 COM + 对象是从 System.EnterpriseServices.ServicedComponents，派生和隔离级别事务组件之间达成一致。  
  
> [!NOTE]
>  原子事务不能包含任何其他事务，也不能包含异常处理程序。  
  
> [!NOTE]
>  原子事务不能包含匹配的发送和接收操作 — 的是，请求-响应对或发送和接收的使用同一相关集。  
  
## <a name="non-serializable-objects"></a>非可序列化对象  
 如果你想要使用业务流程中的非可序列化对象，则必须使用它仅在原子事务内。 使用此类原子事务外的对象数据丢失的风险时由引擎保持在业务流程。  
  
> [!CAUTION]
>  每个原子作用域表示持久化点，这意味着业务流程的状态保存到每个持久化点上的数据库。 广泛使用原子作用域将增加业务流程中的延迟。 而不是使用以创建非可序列化对象的原子作用域，则可以使用静态方法调用不要求原子作用域，因此无需持久化点。  
  
## <a name="see-also"></a>请参阅  
 [使用原子事务的方案](../core/scenarios-using-atomic-transactions.md)   
 [长时间运行的事务](../core/long-running-transactions.md)