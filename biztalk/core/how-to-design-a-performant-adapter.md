---
title: 如何设计优异的适配器 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 3cffe98459213d04e0746ed2ec125c7e704684ff
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65338497"
---
# <a name="how-to-design-a-performant-adapter"></a><span data-ttu-id="b3346-102">如何设计优异的适配器</span><span class="sxs-lookup"><span data-stu-id="b3346-102">How to Design a Performant Adapter</span></span>
<span data-ttu-id="b3346-103">出于性能考虑所有适配器应都是识别批的关于提交消息批、 传输批和通常在批处理中执行对消息的操作。</span><span class="sxs-lookup"><span data-stu-id="b3346-103">For performance purposes all adapters should be batch-aware with regard to submitting batches of messages, transmitting batches, and generally performing operations on messages in batches.</span></span> <span data-ttu-id="b3346-104">适配器应该尝试公开可配置与性能相关的属性，例如批处理或批处理中，也可配置从适配器的设计时用户界面的字节数的大小。</span><span class="sxs-lookup"><span data-stu-id="b3346-104">Adapters should try to expose configurable performance-related attributes, such as the size of batches or the number of bytes in a batch, that are configurable from the adapter's design-time user interface.</span></span>  
  
 <span data-ttu-id="b3346-105">前面曾提到，发送适配器应该始终执行非阻止发送，以避免降低发送主机的性能。</span><span class="sxs-lookup"><span data-stu-id="b3346-105">As mentioned earlier, send adapters should always perform non-blocking sends to avoid degrading the performance of the send host.</span></span> <span data-ttu-id="b3346-106">不建议进一步阻止消息引擎 Api。</span><span class="sxs-lookup"><span data-stu-id="b3346-106">Further blocking of Messaging Engine APIs is not recommended.</span></span>  
  
 <span data-ttu-id="b3346-107">写入和读取消息上下文中会影响运行时性能。</span><span class="sxs-lookup"><span data-stu-id="b3346-107">Writing to and reading from the message context affects run-time performance.</span></span> <span data-ttu-id="b3346-108">一般情况下，适配器应避免读取、 写入和升级数目过多的消息上下文属性。</span><span class="sxs-lookup"><span data-stu-id="b3346-108">In general, adapters should avoid reading, writing, and promoting excessive numbers of message-context properties.</span></span> <span data-ttu-id="b3346-109">由于在运行时每个升级的属性发生订阅评估升级属性创建额外的性能消耗。</span><span class="sxs-lookup"><span data-stu-id="b3346-109">Promoting properties creates an additional performance drain because of the subscription evaluation that occurs on each promoted property at run time.</span></span> <span data-ttu-id="b3346-110">但是，适配器需要升级大量属性，以显著影响性能。</span><span class="sxs-lookup"><span data-stu-id="b3346-110">However, an adapter would need to promote a huge number of properties to noticeably impact performance.</span></span> <span data-ttu-id="b3346-111">仍最好将升级需要升级属性。</span><span class="sxs-lookup"><span data-stu-id="b3346-111">Still it is a good practice to promote only those properties that are required to be promoted.</span></span>  
  
## <a name="throttle-send-and-receive"></a><span data-ttu-id="b3346-112">阻止发送和接收</span><span class="sxs-lookup"><span data-stu-id="b3346-112">Throttle Send and Receive</span></span>  
 <span data-ttu-id="b3346-113">当 BizTalk 引擎上的负载超过配置的阈值时，该引擎将阻止适配器和业务流程，以确保获得最佳性能。</span><span class="sxs-lookup"><span data-stu-id="b3346-113">When the load on the BizTalk engine exceeds the configured threshold, the engine throttles adapters and orchestrations to ensure optimum performance.</span></span> <span data-ttu-id="b3346-114">在接收端，该引擎的工作负荷超过给定的阈值，适配器的调用时**IBTTransportBatch.Done**被阻止，直到负载降低足够。</span><span class="sxs-lookup"><span data-stu-id="b3346-114">On the receive side, when the workload on the engine exceeds a given threshold, the adapter's call to **IBTTransportBatch.Done** is blocked until the load has decreased sufficiently.</span></span> <span data-ttu-id="b3346-115">这会强制提交到引擎中的新工作可用引擎时的适配器。</span><span class="sxs-lookup"><span data-stu-id="b3346-115">This forces the adapter to submit new work into the engine only when the engine is available.</span></span> <span data-ttu-id="b3346-116">在发送端时在引擎阻止适配器发送出站消息引擎不传递新消息直到其负载减少要传输。</span><span class="sxs-lookup"><span data-stu-id="b3346-116">On the send side, when the engine is throttling adapters sending outbound messages, the engine does not deliver new messages to be transmitted until its load is reduced.</span></span>  
  
 <span data-ttu-id="b3346-117">出于这些原因，该适配器不需要关心的限制，除非它是必需的例如，以限制到后端系统的连接数。</span><span class="sxs-lookup"><span data-stu-id="b3346-117">For these reasons, the adapter does not need to be concerned with throttling unless it is required, for example, to limit the number of connections to a back-end system.</span></span> <span data-ttu-id="b3346-118">对于这些类型的情况下，该引擎和适配器框架都不提供任何支持。</span><span class="sxs-lookup"><span data-stu-id="b3346-118">For these types of scenarios, neither the engine nor the Adapter Framework provides any support.</span></span>  
  
 <span data-ttu-id="b3346-119">您可以处理限制从几种方法，具体取决于是否控制适配器的源代码中的自定义发送适配器发送的消息数。</span><span class="sxs-lookup"><span data-stu-id="b3346-119">You can handle throttling the number of messages sent from a custom send adapter in several ways depending on whether you control the source code for the adapter.</span></span>  
  
### <a name="send-side-throttling-improves-performance"></a><span data-ttu-id="b3346-120">发送端阻止提高性能</span><span class="sxs-lookup"><span data-stu-id="b3346-120">Send-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="b3346-121">如果您控制适配器的源代码，您可以通过试探法确定的最大想要在任何时候发送队列中的消息数。</span><span class="sxs-lookup"><span data-stu-id="b3346-121">If you control the source code for the adapter, you can determine from heuristics the maximum number of messages that you want to have in the queue to send at any time.</span></span> <span data-ttu-id="b3346-122">当消息引擎调用`TransmitMessage`方法，并传递新消息的发送适配器中，可以选择或者阻止线程，或者查看队列中的消息数是否大于您以前确定的最大值。</span><span class="sxs-lookup"><span data-stu-id="b3346-122">When the Messaging Engine calls the `TransmitMessage` method and passes the send adapter a new message, you can choose to either block the thread or check to see if the number of messages in the queue is larger than the maximum value you determined previously.</span></span> <span data-ttu-id="b3346-123">如果已超过最大消息数，则可以使用`Resubmit`方法到消息引擎该消息重新提交。</span><span class="sxs-lookup"><span data-stu-id="b3346-123">If the maximum number of messages has been exceeded, you can use the `Resubmit` method to resubmit the message to the Messaging Engine.</span></span> <span data-ttu-id="b3346-124">请注意，是否适配器是同步的该消息可能已被阻止。</span><span class="sxs-lookup"><span data-stu-id="b3346-124">Note that if the adapter is synchronous, the message would already be blocked.</span></span>  
  
 <span data-ttu-id="b3346-125">如果您不控制适配器的源代码，可以通过更改来更改已排队消息数**Highwatermark**在 BizTalk 管理数据库的 Adm_serviceclass 表中的值。</span><span class="sxs-lookup"><span data-stu-id="b3346-125">If you do not control the source code for the adapter, you can change the number of queued messages by changing the **Highwatermark** value in the Adm_serviceclass table in the BizTalk Management database.</span></span> <span data-ttu-id="b3346-126">最大值**Highwatermark**属性为 200。</span><span class="sxs-lookup"><span data-stu-id="b3346-126">The maximum value for the **Highwatermark** property is 200.</span></span> <span data-ttu-id="b3346-127">此外可以更改的值**的低水印**属性设置为较小的值。</span><span class="sxs-lookup"><span data-stu-id="b3346-127">You can also change the value for the **Lowwatermark** property to a smaller value.</span></span>  
  
 <span data-ttu-id="b3346-128">请记住的值**Highwatermark**异步适配器的消息引擎已提供给适配器的消息数的帐户的属性。</span><span class="sxs-lookup"><span data-stu-id="b3346-128">Remember that the value of the **Highwatermark** property for asynchronous adapters accounts for the number of messages that the Messaging Engine has given to the adapter.</span></span> <span data-ttu-id="b3346-129">消息引擎将其传递给通过适配器`TransmitMessage`方法，这些消息可能仍处于传输过程中，例如，如果适配器未进行相应地调用`DeleteMessage`， `Resubmit`， `MoveToNextTransport`或[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="b3346-129">The Messaging Engine passes them to the adapter through the `TransmitMessage` method, These messages can be still outstanding in their transmission—for example, if the adapter has not made a corresponding call to the `DeleteMessage`, `Resubmit`, `MoveToNextTransport`, or [Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx) methods.</span></span> <span data-ttu-id="b3346-130">对于异步适配器**Highwatermark**属性仅占消息引擎已传递到由适配器使用的消息数**TransmitMessage**方法因为此调用进行同步处理，阻止调用消息引擎线程。</span><span class="sxs-lookup"><span data-stu-id="b3346-130">For synchronous adapters, the **Highwatermark** property only accounts for the number of messages the Messaging Engine has passed to the adapter by using the **TransmitMessage** method because this call processes synchronously, blocking the calling Messaging Engine thread.</span></span>  
  
 <span data-ttu-id="b3346-131">如果你正在编写一种协议，本质上是一个发送适配器 （如 HTTP、 FTP 或双向 SOAP） 本质上缓慢，请考虑以下：</span><span class="sxs-lookup"><span data-stu-id="b3346-131">If you are writing a send adapter for a protocol that is inherently slow in nature (such as HTTP, FTP, or two-way SOAP), consider the following:</span></span>  
  
- <span data-ttu-id="b3346-132">此类适配器可能会收到传输的消息从 BizTalk 消息引擎更快于它传送。</span><span class="sxs-lookup"><span data-stu-id="b3346-132">Such an adapter might receive messages for transmission from the BizTalk Messaging Engine faster than it can transmit them.</span></span> <span data-ttu-id="b3346-133">这种差异会导致在不同级别的问题。</span><span class="sxs-lookup"><span data-stu-id="b3346-133">This discrepancy causes problems at various levels.</span></span> <span data-ttu-id="b3346-134">传输的消息保留在内存中并且占用虚拟内存，整个系统变慢。</span><span class="sxs-lookup"><span data-stu-id="b3346-134">The messages under transmission remain in memory and take up the virtual memory, slowing down the entire system.</span></span>  
  
- <span data-ttu-id="b3346-135">适配器可能会占用特定于协议的资源。</span><span class="sxs-lookup"><span data-stu-id="b3346-135">The adapter might take up protocol-specific resources.</span></span> <span data-ttu-id="b3346-136">例如，它可能打开太多并发连接到服务器，可能会中断远程服务器。</span><span class="sxs-lookup"><span data-stu-id="b3346-136">For example, it might open too many concurrent connections to the server, which could disrupt the remote server.</span></span>  
  
- <span data-ttu-id="b3346-137">该适配器可能会影响其他适配器。</span><span class="sxs-lookup"><span data-stu-id="b3346-137">The adapter might affect other adapters.</span></span> <span data-ttu-id="b3346-138">例如，如果为特定适配器排队等候太多的消息，消息引擎将停止在该进程中其他发送适配器向发出请求。</span><span class="sxs-lookup"><span data-stu-id="b3346-138">For example, if too many messages queue up for a particular adapter, the Messaging Engine stops issuing requests to other send adapters in that process.</span></span>  
  
  <span data-ttu-id="b3346-139">一种解决方案是将慢速和快速适配器放在不同的 BizTalk 主机并通过使用"高水位"和"低水位"设置控制的消息数。</span><span class="sxs-lookup"><span data-stu-id="b3346-139">A solution is to put the slow and fast adapters in separate BizTalk Hosts and control the number of messages by using the "High Watermark" and "Low Watermark" settings.</span></span>  
  
### <a name="receive-side-throttling-improves-performance"></a><span data-ttu-id="b3346-140">接收端阻止提高性能</span><span class="sxs-lookup"><span data-stu-id="b3346-140">Receive-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="b3346-141">在许多情况下在其中接收适配器接收消息快于其余系统处理消息的速率。</span><span class="sxs-lookup"><span data-stu-id="b3346-141">There are numerous situations in which a receive adapter receives messages faster than the rate at which the rest of the system can process the messages.</span></span> <span data-ttu-id="b3346-142">这种情况发生时，将开始积压在 MessageBox 数据库。</span><span class="sxs-lookup"><span data-stu-id="b3346-142">When such a situation occurs, the MessageBox database becomes backlogged.</span></span> <span data-ttu-id="b3346-143">在此情况下，整个系统的性能都会显著下降。</span><span class="sxs-lookup"><span data-stu-id="b3346-143">When this happens, the performance of the whole system drops dramatically.</span></span>  
  
 <span data-ttu-id="b3346-144">如果发生这种情况与您的适配器，可以使用以下方法之一来降低接收适配器的速度：</span><span class="sxs-lookup"><span data-stu-id="b3346-144">If this is happening with your adapter, you can use one of the following techniques to reduce the speed of the receive adapter:</span></span>  
  
- <span data-ttu-id="b3346-145">减少消息引擎线程池大小。</span><span class="sxs-lookup"><span data-stu-id="b3346-145">Reduce the Messaging Engine thread pool size.</span></span> <span data-ttu-id="b3346-146">您可以控制消息引擎用于将消息发布到 MessageBox 中的线程数。</span><span class="sxs-lookup"><span data-stu-id="b3346-146">You can control the number of threads that the Messaging Engine uses to publish messages into the MessageBox.</span></span> <span data-ttu-id="b3346-147">通过减少线程数，您将降低接收适配器到 MessageBox 中接收消息的速率。</span><span class="sxs-lookup"><span data-stu-id="b3346-147">By reducing the number of threads, you reduce the rate at which the receive adapter receives messages into the MessageBox.</span></span> <span data-ttu-id="b3346-148">此设置只需为完成的主机相对应的适配器的接收处理程序。</span><span class="sxs-lookup"><span data-stu-id="b3346-148">This setting only needs to be done for the host corresponding to the receive handler for the adapter.</span></span> <span data-ttu-id="b3346-149">您不应设置此主机相对应的适配器的发送处理程序的除非你想要发送适配器也变慢。</span><span class="sxs-lookup"><span data-stu-id="b3346-149">You should not set this for the host corresponding to the send handler for the adapter, unless you want to slow down the send adapter as well.</span></span>  
  
- <span data-ttu-id="b3346-150">减少适配器的批大小。</span><span class="sxs-lookup"><span data-stu-id="b3346-150">Reduce the adapter batch size.</span></span> <span data-ttu-id="b3346-151">大多数快速的接收适配器将消息发布到 MessageBox 中的批处理。</span><span class="sxs-lookup"><span data-stu-id="b3346-151">Most fast receive adapters publish messages to the MessageBox in batches.</span></span> <span data-ttu-id="b3346-152">这些批的大小是通常可在接收位置属性页中配置。</span><span class="sxs-lookup"><span data-stu-id="b3346-152">The size of these batches is usually configurable in the receive location property page.</span></span> <span data-ttu-id="b3346-153">通过减小批大小可以减少进入系统的消息的整体吞吐量。</span><span class="sxs-lookup"><span data-stu-id="b3346-153">By decreasing the batch size you can decrease the overall throughput of messages coming into the system.</span></span>  
  
- <span data-ttu-id="b3346-154">更改其他特定于适配器的设置。</span><span class="sxs-lookup"><span data-stu-id="b3346-154">Change other adapter-specific settings.</span></span> <span data-ttu-id="b3346-155">完成前两个步骤后，可以尝试调整其他适配器参数以便进一步降低吞吐量。</span><span class="sxs-lookup"><span data-stu-id="b3346-155">After you complete the two previous steps, you can try adjusting other adapter parameters to further decrease throughput.</span></span> <span data-ttu-id="b3346-156">某些适配器公开可用于降低吞吐量的内部参数。</span><span class="sxs-lookup"><span data-stu-id="b3346-156">Some adapters expose internal parameters that can be used to decrease throughput.</span></span> <span data-ttu-id="b3346-157">例如，MQSeries 适配器具有设置为"按序送达"。</span><span class="sxs-lookup"><span data-stu-id="b3346-157">For example, the MQSeries adapter has a setting for “Ordered Delivery.”</span></span> <span data-ttu-id="b3346-158">指定按序的送达的适配器将发布一批消息，等待它完成，以及后发布下一批。</span><span class="sxs-lookup"><span data-stu-id="b3346-158">Ordered Delivery specifies that the adapter will publish a batch of messages, wait for it to complete, and then publish the next batch.</span></span> <span data-ttu-id="b3346-159">通过启用此设置，可以从接收适配器实质上是删除所有的并行性。</span><span class="sxs-lookup"><span data-stu-id="b3346-159">By enabling this setting, you essentially remove all parallelism from the receive adapter.</span></span> <span data-ttu-id="b3346-160">相反，在另一种方法中调整这些参数可用来增加一个接收适配器的接收速率。</span><span class="sxs-lookup"><span data-stu-id="b3346-160">Conversely, tuning the parameters in the opposite way can be used to increase the receiving rate of a receive adapter.</span></span>  
  
  <span data-ttu-id="b3346-161">适配器可以提交到传输代理需要作为任何数目的批。</span><span class="sxs-lookup"><span data-stu-id="b3346-161">An adapter can submit as many batches as required to the transport proxy.</span></span> <span data-ttu-id="b3346-162">当系统负荷极高，先调用**完成**方法**IBTTransportBatch**接口将阻止消息，直到所需的资源被释放到系统。</span><span class="sxs-lookup"><span data-stu-id="b3346-162">When the system is heavily stressed, a call to the **Done** method of the **IBTTransportBatch** interface will block the message until the required resources are released to the system.</span></span>  
  
## <a name="plan-for-asynchronous-receive-and-send"></a><span data-ttu-id="b3346-163">规划异步接收和发送</span><span class="sxs-lookup"><span data-stu-id="b3346-163">Plan for Asynchronous Receive and Send</span></span>  
 <span data-ttu-id="b3346-164">BizTalk Server 消息 Api 具有的丰富支持异步编程。</span><span class="sxs-lookup"><span data-stu-id="b3346-164">The BizTalk Server messaging APIs have rich support for asynchronous programming.</span></span> <span data-ttu-id="b3346-165">如果你想要编写可伸缩适配器，计划从一开始使用异步模型，因为异步模型提供更好的并发。</span><span class="sxs-lookup"><span data-stu-id="b3346-165">If you want to write a scalable adapter, plan on using the asynchronous model from the start because the asynchronous model provides better concurrency.</span></span>  
  
 <span data-ttu-id="b3346-166">在接收端，适配器提交一批消息到 BizTalk 消息引擎时 (通过调用**ibttransportbatch:: Done**)，消息引擎使用其内部线程池的工作进行排队并立即返回。</span><span class="sxs-lookup"><span data-stu-id="b3346-166">On the receive side, when an adapter submits a batch of messages to the BizTalk Messaging Engine (by calling **IBTTransportBatch::Done**), the Messaging Engine queues up the work using its internal thread pool and returns immediately.</span></span> <span data-ttu-id="b3346-167">引擎处理上一个单独的线程，保持适配器可以免费从其源中读取多个消息并将其提交而无需等待以前的消息处理完成的消息。</span><span class="sxs-lookup"><span data-stu-id="b3346-167">The engine processes the messages on a separate thread, leaving the adapter free to read more messages from its source and submit them without waiting for the previous message processing to complete.</span></span>  
  
 <span data-ttu-id="b3346-168">在发送端，您的适配器可以是异步或同步。</span><span class="sxs-lookup"><span data-stu-id="b3346-168">On the send side, your adapter can be either asynchronous or synchronous.</span></span> <span data-ttu-id="b3346-169">但是，如果您的协议支持异步操作，应使用这种支持编写可伸缩适配器。</span><span class="sxs-lookup"><span data-stu-id="b3346-169">However, if your protocol supports asynchronous operations, you should use this support to write a scalable adapter.</span></span> <span data-ttu-id="b3346-170">例如，File 和 HTTP 发送适配器是完全异步的它们执行非常少的阻塞/同步操作。</span><span class="sxs-lookup"><span data-stu-id="b3346-170">For example, File and HTTP send adapters are fully asynchronous and they perform very few blocking/synchronous operations.</span></span>  
  
 <span data-ttu-id="b3346-171">异步操作确保消息引擎和您的适配器将继续执行并行其各自的工作并不互相等待正常消息处理。</span><span class="sxs-lookup"><span data-stu-id="b3346-171">Asynchronous operations ensure that both the Messaging Engine and your adapter will continue to do their respective work in parallel and not wait on each other for normal message processing.</span></span>  
  
## <a name="use-batching-to-improve-performance"></a><span data-ttu-id="b3346-172">使用批处理以提高性能</span><span class="sxs-lookup"><span data-stu-id="b3346-172">Use Batching to Improve Performance</span></span>  
 <span data-ttu-id="b3346-173">批处理是用于编写可伸缩适配器的最佳起点。</span><span class="sxs-lookup"><span data-stu-id="b3346-173">Batching is the best starting point for writing a scalable adapter.</span></span> <span data-ttu-id="b3346-174">这是发送方和接收端适配器，则返回 true。</span><span class="sxs-lookup"><span data-stu-id="b3346-174">This is true for both send-side and receive-side adapters.</span></span> <span data-ttu-id="b3346-175">即使您的适配器是非事务性的每个批也都通过 BizTalk Server 中的数据库事务。</span><span class="sxs-lookup"><span data-stu-id="b3346-175">Every batch goes through a database transaction within BizTalk Server even if your adapter is nontransactional.</span></span> <span data-ttu-id="b3346-176">由于没有与每个事务相关联的固定的延迟，应尝试通过组合多个到单个批处理操作的事务数量降至最低。</span><span class="sxs-lookup"><span data-stu-id="b3346-176">Because there is a fixed delay associated with each transaction, you should try to minimize the number of transactions by combining more than one operation into a single batch.</span></span>  
  
## <a name="do-not-starve-the-net-thread-pool"></a><span data-ttu-id="b3346-177">不影响虚拟.NET 线程池</span><span class="sxs-lookup"><span data-stu-id="b3346-177">Do Not Starve the .NET Thread Pool</span></span>  
 <span data-ttu-id="b3346-178">编写 BizTalk 适配器是练习编写.NET 运行时代码;编写.NET 运行时代码也一定有助于练习异步编程。</span><span class="sxs-lookup"><span data-stu-id="b3346-178">Writing BizTalk adapters is an exercise in writing .NET runtime code; writing .NET runtime code is invariably an exercise in asynchronous programming.</span></span>  
  
 <span data-ttu-id="b3346-179">耗尽.NET 线程池在.NET 中，所有异步编程的风险，它是对 BizTalk 适配器程序员来说，若要避免尤为重要。</span><span class="sxs-lookup"><span data-stu-id="b3346-179">Starving the .NET thread pool is a risk to all asynchronous programming in .NET, and it is particularly important for the BizTalk adapter programmer to avoid.</span></span>  
  
 <span data-ttu-id="b3346-180">.NET 线程池是受到限制但全面共享资源。</span><span class="sxs-lookup"><span data-stu-id="b3346-180">The .NET thread pool is a limited but widely shared resource.</span></span> <span data-ttu-id="b3346-181">很容易地编写代码，使用.NET 线程池线程之一并保留很长时间，阻止从正在执行其他工作项。</span><span class="sxs-lookup"><span data-stu-id="b3346-181">It is easy to write code that uses one of the .NET thread pool threads and holds onto it for long time, blocking other work items from being executed.</span></span>  
  
 <span data-ttu-id="b3346-182">您每次使用**BeginInvoke**或使用一个计时器，使用.NET 线程池线程。</span><span class="sxs-lookup"><span data-stu-id="b3346-182">Whenever you use **BeginInvoke** or use a timer, you are using a .NET thread pool thread.</span></span> <span data-ttu-id="b3346-183">如果有多个部分的工作要做 （例如将复制从 MQSeries 消息到 BizTalk Server 中），你应执行一个工作项 （一批消息到 BizTalk Server 中），然后重新排队在线程池中是否存在更多工作要做。</span><span class="sxs-lookup"><span data-stu-id="b3346-183">If you have multiple pieces of work to do (for example copying messages out of MQSeries into BizTalk Server), you should execute one work item (one batch of messages into BizTalk Server) and then requeue in the thread pool if there is more work to do.</span></span> <span data-ttu-id="b3346-184">永远不会进入`while`线程上的循环。</span><span class="sxs-lookup"><span data-stu-id="b3346-184">Never sit in a `while` loop on the thread.</span></span>  
  
 <span data-ttu-id="b3346-185">具体而言，这意味着替换`while`通过重复调用循环**BeginInvoke**。</span><span class="sxs-lookup"><span data-stu-id="b3346-185">In concrete terms this means replacing `while` loops with repeated calls to **BeginInvoke**.</span></span> <span data-ttu-id="b3346-186">此简单的更改可以显著改善响应能力和整个实现横向扩展功能。</span><span class="sxs-lookup"><span data-stu-id="b3346-186">This simple change can dramatically improve the responsiveness and scale-out ability for the whole implementation.</span></span>  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a><span data-ttu-id="b3346-187">如果限制批大小时，请选择正确的度量</span><span class="sxs-lookup"><span data-stu-id="b3346-187">Choose the Right Measurement When Limiting Batch Size</span></span>  
 <span data-ttu-id="b3346-188">如果您要提交到 BizTalk Server 批中的消息，不限制批处理大小仅基于消息计数。</span><span class="sxs-lookup"><span data-stu-id="b3346-188">If you are submitting messages to BizTalk Server in batches, do not limit the batch size based only on the message count.</span></span> <span data-ttu-id="b3346-189">请考虑会发生什么情况配置适配器时进行批处理只基于消息计数：如果批大小为 2，并且适配器获取的四个消息分别，大小为 4 KB，8 KB，1 MB 和 5 MB 将是第一批大小的 12 KB 的文件和第二个批处理将的大小为 6 MB。</span><span class="sxs-lookup"><span data-stu-id="b3346-189">Consider what happens when an adapter has been configured to batch based only on message count: If the batch size is two and the adapter gets four messages of size 4 KB, 8 KB, 1 MB, and 5MB respectively, the first batch will be of size 12 KB, and the second batch will be of size 6 MB.</span></span>  
  
 <span data-ttu-id="b3346-190">BizTalk 消息引擎按顺序处理单个批次中的所有消息，因为第二个批处理在此示例中将速度远远低于第一批进行处理。</span><span class="sxs-lookup"><span data-stu-id="b3346-190">Because the BizTalk Messaging Engine processes all messages in a single batch sequentially, the second batch in this example will be processed much more slowly than the first batch.</span></span> <span data-ttu-id="b3346-191">这将大幅降低吞吐量。</span><span class="sxs-lookup"><span data-stu-id="b3346-191">This is effectively reducing throughput.</span></span> <span data-ttu-id="b3346-192">更好的方法来解决此问题是进行批处理基于消息计数和批处理 （即，批大小以字节为单位） 中的总字节数。</span><span class="sxs-lookup"><span data-stu-id="b3346-192">A better way to handle this problem is to batch based on both message count and total bytes in the batch (that is, batch size in bytes).</span></span> <span data-ttu-id="b3346-193">没有针对总字节数的神奇数字。</span><span class="sxs-lookup"><span data-stu-id="b3346-193">There is no magic number for total bytes.</span></span> <span data-ttu-id="b3346-194">但是，在正常处理方案中，如果批大小超过 1 mb 以内，你将开始看到不佳的并发性和吞吐量。</span><span class="sxs-lookup"><span data-stu-id="b3346-194">However, in a normal processing scenario, if the batch size exceeds 1 MB, you will start seeing poor concurrency and throughput.</span></span>  
  
 <span data-ttu-id="b3346-195">适配器通常是消息不可知的他们不知道在生产环境中的消息的大小。</span><span class="sxs-lookup"><span data-stu-id="b3346-195">Generally adapters are message agnostic and they do not know the size of the messages in the production environment.</span></span> <span data-ttu-id="b3346-196">传入消息的大小很可能差别很大。</span><span class="sxs-lookup"><span data-stu-id="b3346-196">The sizes of the incoming messages are likely to vary significantly.</span></span> <span data-ttu-id="b3346-197">因此，始终使用消息计数和总字节数来生成批。</span><span class="sxs-lookup"><span data-stu-id="b3346-197">Because of this, always use message count and total bytes to build the batch.</span></span>