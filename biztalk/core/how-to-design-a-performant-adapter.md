---
title: 如何设计优异的适配器 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 3cffe98459213d04e0746ed2ec125c7e704684ff
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65338497"
---
# <a name="how-to-design-a-performant-adapter"></a>如何设计优异的适配器
出于性能考虑所有适配器应都是识别批的关于提交消息批、 传输批和通常在批处理中执行对消息的操作。 适配器应该尝试公开可配置与性能相关的属性，例如批处理或批处理中，也可配置从适配器的设计时用户界面的字节数的大小。  
  
 前面曾提到，发送适配器应该始终执行非阻止发送，以避免降低发送主机的性能。 不建议进一步阻止消息引擎 Api。  
  
 写入和读取消息上下文中会影响运行时性能。 一般情况下，适配器应避免读取、 写入和升级数目过多的消息上下文属性。 由于在运行时每个升级的属性发生订阅评估升级属性创建额外的性能消耗。 但是，适配器需要升级大量属性，以显著影响性能。 仍最好将升级需要升级属性。  
  
## <a name="throttle-send-and-receive"></a>阻止发送和接收  
 当 BizTalk 引擎上的负载超过配置的阈值时，该引擎将阻止适配器和业务流程，以确保获得最佳性能。 在接收端，该引擎的工作负荷超过给定的阈值，适配器的调用时**IBTTransportBatch.Done**被阻止，直到负载降低足够。 这会强制提交到引擎中的新工作可用引擎时的适配器。 在发送端时在引擎阻止适配器发送出站消息引擎不传递新消息直到其负载减少要传输。  
  
 出于这些原因，该适配器不需要关心的限制，除非它是必需的例如，以限制到后端系统的连接数。 对于这些类型的情况下，该引擎和适配器框架都不提供任何支持。  
  
 您可以处理限制从几种方法，具体取决于是否控制适配器的源代码中的自定义发送适配器发送的消息数。  
  
### <a name="send-side-throttling-improves-performance"></a>发送端阻止提高性能  
 如果您控制适配器的源代码，您可以通过试探法确定的最大想要在任何时候发送队列中的消息数。 当消息引擎调用`TransmitMessage`方法，并传递新消息的发送适配器中，可以选择或者阻止线程，或者查看队列中的消息数是否大于您以前确定的最大值。 如果已超过最大消息数，则可以使用`Resubmit`方法到消息引擎该消息重新提交。 请注意，是否适配器是同步的该消息可能已被阻止。  
  
 如果您不控制适配器的源代码，可以通过更改来更改已排队消息数**Highwatermark**在 BizTalk 管理数据库的 Adm_serviceclass 表中的值。 最大值**Highwatermark**属性为 200。 此外可以更改的值**的低水印**属性设置为较小的值。  
  
 请记住的值**Highwatermark**异步适配器的消息引擎已提供给适配器的消息数的帐户的属性。 消息引擎将其传递给通过适配器`TransmitMessage`方法，这些消息可能仍处于传输过程中，例如，如果适配器未进行相应地调用`DeleteMessage`， `Resubmit`， `MoveToNextTransport`或[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)方法。 对于异步适配器**Highwatermark**属性仅占消息引擎已传递到由适配器使用的消息数**TransmitMessage**方法因为此调用进行同步处理，阻止调用消息引擎线程。  
  
 如果你正在编写一种协议，本质上是一个发送适配器 （如 HTTP、 FTP 或双向 SOAP） 本质上缓慢，请考虑以下：  
  
- 此类适配器可能会收到传输的消息从 BizTalk 消息引擎更快于它传送。 这种差异会导致在不同级别的问题。 传输的消息保留在内存中并且占用虚拟内存，整个系统变慢。  
  
- 适配器可能会占用特定于协议的资源。 例如，它可能打开太多并发连接到服务器，可能会中断远程服务器。  
  
- 该适配器可能会影响其他适配器。 例如，如果为特定适配器排队等候太多的消息，消息引擎将停止在该进程中其他发送适配器向发出请求。  
  
  一种解决方案是将慢速和快速适配器放在不同的 BizTalk 主机并通过使用"高水位"和"低水位"设置控制的消息数。  
  
### <a name="receive-side-throttling-improves-performance"></a>接收端阻止提高性能  
 在许多情况下在其中接收适配器接收消息快于其余系统处理消息的速率。 这种情况发生时，将开始积压在 MessageBox 数据库。 在此情况下，整个系统的性能都会显著下降。  
  
 如果发生这种情况与您的适配器，可以使用以下方法之一来降低接收适配器的速度：  
  
- 减少消息引擎线程池大小。 您可以控制消息引擎用于将消息发布到 MessageBox 中的线程数。 通过减少线程数，您将降低接收适配器到 MessageBox 中接收消息的速率。 此设置只需为完成的主机相对应的适配器的接收处理程序。 您不应设置此主机相对应的适配器的发送处理程序的除非你想要发送适配器也变慢。  
  
- 减少适配器的批大小。 大多数快速的接收适配器将消息发布到 MessageBox 中的批处理。 这些批的大小是通常可在接收位置属性页中配置。 通过减小批大小可以减少进入系统的消息的整体吞吐量。  
  
- 更改其他特定于适配器的设置。 完成前两个步骤后，可以尝试调整其他适配器参数以便进一步降低吞吐量。 某些适配器公开可用于降低吞吐量的内部参数。 例如，MQSeries 适配器具有设置为"按序送达"。 指定按序的送达的适配器将发布一批消息，等待它完成，以及后发布下一批。 通过启用此设置，可以从接收适配器实质上是删除所有的并行性。 相反，在另一种方法中调整这些参数可用来增加一个接收适配器的接收速率。  
  
  适配器可以提交到传输代理需要作为任何数目的批。 当系统负荷极高，先调用**完成**方法**IBTTransportBatch**接口将阻止消息，直到所需的资源被释放到系统。  
  
## <a name="plan-for-asynchronous-receive-and-send"></a>规划异步接收和发送  
 BizTalk Server 消息 Api 具有的丰富支持异步编程。 如果你想要编写可伸缩适配器，计划从一开始使用异步模型，因为异步模型提供更好的并发。  
  
 在接收端，适配器提交一批消息到 BizTalk 消息引擎时 (通过调用**ibttransportbatch:: Done**)，消息引擎使用其内部线程池的工作进行排队并立即返回。 引擎处理上一个单独的线程，保持适配器可以免费从其源中读取多个消息并将其提交而无需等待以前的消息处理完成的消息。  
  
 在发送端，您的适配器可以是异步或同步。 但是，如果您的协议支持异步操作，应使用这种支持编写可伸缩适配器。 例如，File 和 HTTP 发送适配器是完全异步的它们执行非常少的阻塞/同步操作。  
  
 异步操作确保消息引擎和您的适配器将继续执行并行其各自的工作并不互相等待正常消息处理。  
  
## <a name="use-batching-to-improve-performance"></a>使用批处理以提高性能  
 批处理是用于编写可伸缩适配器的最佳起点。 这是发送方和接收端适配器，则返回 true。 即使您的适配器是非事务性的每个批也都通过 BizTalk Server 中的数据库事务。 由于没有与每个事务相关联的固定的延迟，应尝试通过组合多个到单个批处理操作的事务数量降至最低。  
  
## <a name="do-not-starve-the-net-thread-pool"></a>不影响虚拟.NET 线程池  
 编写 BizTalk 适配器是练习编写.NET 运行时代码;编写.NET 运行时代码也一定有助于练习异步编程。  
  
 耗尽.NET 线程池在.NET 中，所有异步编程的风险，它是对 BizTalk 适配器程序员来说，若要避免尤为重要。  
  
 .NET 线程池是受到限制但全面共享资源。 很容易地编写代码，使用.NET 线程池线程之一并保留很长时间，阻止从正在执行其他工作项。  
  
 您每次使用**BeginInvoke**或使用一个计时器，使用.NET 线程池线程。 如果有多个部分的工作要做 （例如将复制从 MQSeries 消息到 BizTalk Server 中），你应执行一个工作项 （一批消息到 BizTalk Server 中），然后重新排队在线程池中是否存在更多工作要做。 永远不会进入`while`线程上的循环。  
  
 具体而言，这意味着替换`while`通过重复调用循环**BeginInvoke**。 此简单的更改可以显著改善响应能力和整个实现横向扩展功能。  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a>如果限制批大小时，请选择正确的度量  
 如果您要提交到 BizTalk Server 批中的消息，不限制批处理大小仅基于消息计数。 请考虑会发生什么情况配置适配器时进行批处理只基于消息计数：如果批大小为 2，并且适配器获取的四个消息分别，大小为 4 KB，8 KB，1 MB 和 5 MB 将是第一批大小的 12 KB 的文件和第二个批处理将的大小为 6 MB。  
  
 BizTalk 消息引擎按顺序处理单个批次中的所有消息，因为第二个批处理在此示例中将速度远远低于第一批进行处理。 这将大幅降低吞吐量。 更好的方法来解决此问题是进行批处理基于消息计数和批处理 （即，批大小以字节为单位） 中的总字节数。 没有针对总字节数的神奇数字。 但是，在正常处理方案中，如果批大小超过 1 mb 以内，你将开始看到不佳的并发性和吞吐量。  
  
 适配器通常是消息不可知的他们不知道在生产环境中的消息的大小。 传入消息的大小很可能差别很大。 因此，始终使用消息计数和总字节数来生成批。