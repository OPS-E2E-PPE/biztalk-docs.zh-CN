---
title: 如何设计优异的适配器 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: b5a1f338-fd7c-41c8-a181-8da8b293c4cc
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 4175732cc9896789a0a101cc6e8f6f028d19dc3b
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/27/2018
ms.locfileid: "36970238"
---
# <a name="how-to-design-a-performant-adapter"></a><span data-ttu-id="ab95b-102">如何设计优异的适配器</span><span class="sxs-lookup"><span data-stu-id="ab95b-102">How to Design a Performant Adapter</span></span>
<span data-ttu-id="ab95b-103">出于性能方面的考虑，在提交消息批、传输批和对批中消息执行一般性操作等方面，所有适配器都应该是识别批的。</span><span class="sxs-lookup"><span data-stu-id="ab95b-103">For performance purposes all adapters should be batch-aware with regard to submitting batches of messages, transmitting batches, and generally performing operations on messages in batches.</span></span> <span data-ttu-id="ab95b-104">适配器应该尝试公开与性能相关的可配置属性，例如批的大小或批中的字节数，从适配器的设计时用户界面可以配置这些属性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-104">Adapters should try to expose configurable performance-related attributes, such as the size of batches or the number of bytes in a batch, that are configurable from the adapter's design-time user interface.</span></span>  
  
 <span data-ttu-id="ab95b-105">如前所述，发送适配器应该始终执行非阻止发送，以避免降低发送主机的性能。</span><span class="sxs-lookup"><span data-stu-id="ab95b-105">As mentioned earlier, send adapters should always perform non-blocking sends to avoid degrading the performance of the send host.</span></span> <span data-ttu-id="ab95b-106">不建议进一步阻止消息引擎 API。</span><span class="sxs-lookup"><span data-stu-id="ab95b-106">Further blocking of Messaging Engine APIs is not recommended.</span></span>  
  
 <span data-ttu-id="ab95b-107">无论是写入还是读取消息上下文，都会影响运行时性能。</span><span class="sxs-lookup"><span data-stu-id="ab95b-107">Writing to and reading from the message context affects run-time performance.</span></span> <span data-ttu-id="ab95b-108">一般而言，适配器应避免读取、写入和升级数目过多的消息上下文属性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-108">In general, adapters should avoid reading, writing, and promoting excessive numbers of message-context properties.</span></span> <span data-ttu-id="ab95b-109">由于在运行时在每个升级的属性上都会发生订阅评估，因此升级属性将造成额外的性能消耗。</span><span class="sxs-lookup"><span data-stu-id="ab95b-109">Promoting properties creates an additional performance drain because of the subscription evaluation that occurs on each promoted property at run time.</span></span> <span data-ttu-id="ab95b-110">但是，适配器可能会需要升级大量属性，这将显著影响性能。</span><span class="sxs-lookup"><span data-stu-id="ab95b-110">However, an adapter would need to promote a huge number of properties to noticeably impact performance.</span></span> <span data-ttu-id="ab95b-111">此时，仍最好只升级确实需要升级的那些属性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-111">Still it is a good practice to promote only those properties that are required to be promoted.</span></span>  
  
## <a name="throttle-send-and-receive"></a><span data-ttu-id="ab95b-112">阻止发送和接收</span><span class="sxs-lookup"><span data-stu-id="ab95b-112">Throttle Send and Receive</span></span>  
 <span data-ttu-id="ab95b-113">在 BizTalk 引擎上的负载超出了已配置的阈值时，该引擎将阻止适配器和业务流程，以便确保提供最佳性能。</span><span class="sxs-lookup"><span data-stu-id="ab95b-113">When the load on the BizTalk engine exceeds the configured threshold, the engine throttles adapters and orchestrations to ensure optimum performance.</span></span> <span data-ttu-id="ab95b-114">在接收端，该引擎的工作负荷超过给定的阈值，适配器的调用时**IBTTransportBatch.Done**被阻止，直到负载降低足够。</span><span class="sxs-lookup"><span data-stu-id="ab95b-114">On the receive side, when the workload on the engine exceeds a given threshold, the adapter's call to **IBTTransportBatch.Done** is blocked until the load has decreased sufficiently.</span></span> <span data-ttu-id="ab95b-115">这强制适配器只有在引擎可用时才将新工作提交到该引擎。</span><span class="sxs-lookup"><span data-stu-id="ab95b-115">This forces the adapter to submit new work into the engine only when the engine is available.</span></span> <span data-ttu-id="ab95b-116">在发送端，在引擎阻止适配器发送出站消息时，该引擎在负载减轻前不会发送要传输的新消息。</span><span class="sxs-lookup"><span data-stu-id="ab95b-116">On the send side, when the engine is throttling adapters sending outbound messages, the engine does not deliver new messages to be transmitted until its load is reduced.</span></span>  
  
 <span data-ttu-id="ab95b-117">出于上述原因，除非特别要求（例如，要限制与后端系统的连接数），否则，适配器无需考虑阻止问题。</span><span class="sxs-lookup"><span data-stu-id="ab95b-117">For these reasons, the adapter does not need to be concerned with throttling unless it is required, for example, to limit the number of connections to a back-end system.</span></span> <span data-ttu-id="ab95b-118">对于这些类型的情况，引擎和适配器框架均不提供任何支持。</span><span class="sxs-lookup"><span data-stu-id="ab95b-118">For these types of scenarios, neither the engine nor the Adapter Framework provides any support.</span></span>  
  
 <span data-ttu-id="ab95b-119">您可以根据是否控制适配器的源代码，通过几种方式阻止从自定义发送适配器发送的消息数目。</span><span class="sxs-lookup"><span data-stu-id="ab95b-119">You can handle throttling the number of messages sent from a custom send adapter in several ways depending on whether you control the source code for the adapter.</span></span>  
  
### <a name="send-side-throttling-improves-performance"></a><span data-ttu-id="ab95b-120">发送端阻止提高性能</span><span class="sxs-lookup"><span data-stu-id="ab95b-120">Send-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="ab95b-121">如果您控制适配器的源代码，则可以通过试探法确定您在队列中随时要发送的消息的最大数目。</span><span class="sxs-lookup"><span data-stu-id="ab95b-121">If you control the source code for the adapter, you can determine from heuristics the maximum number of messages that you want to have in the queue to send at any time.</span></span> <span data-ttu-id="ab95b-122">当消息引擎调用`TransmitMessage`方法，并传递新消息的发送适配器中，可以选择或者阻止线程，或者查看队列中的消息数是否大于您以前确定的最大值。</span><span class="sxs-lookup"><span data-stu-id="ab95b-122">When the Messaging Engine calls the `TransmitMessage` method and passes the send adapter a new message, you can choose to either block the thread or check to see if the number of messages in the queue is larger than the maximum value you determined previously.</span></span> <span data-ttu-id="ab95b-123">如果已超过最大消息数，则可以使用`Resubmit`方法到消息引擎该消息重新提交。</span><span class="sxs-lookup"><span data-stu-id="ab95b-123">If the maximum number of messages has been exceeded, you can use the `Resubmit` method to resubmit the message to the Messaging Engine.</span></span> <span data-ttu-id="ab95b-124">请注意，如果适配器是同步的，则该消息可能已被阻止。</span><span class="sxs-lookup"><span data-stu-id="ab95b-124">Note that if the adapter is synchronous, the message would already be blocked.</span></span>  
  
 <span data-ttu-id="ab95b-125">如果您不控制适配器的源代码，可以通过更改来更改已排队消息数**Highwatermark**在 BizTalk 管理数据库的 Adm_serviceclass 表中的值。</span><span class="sxs-lookup"><span data-stu-id="ab95b-125">If you do not control the source code for the adapter, you can change the number of queued messages by changing the **Highwatermark** value in the Adm_serviceclass table in the BizTalk Management database.</span></span> <span data-ttu-id="ab95b-126">最大值**Highwatermark**属性为 200。</span><span class="sxs-lookup"><span data-stu-id="ab95b-126">The maximum value for the **Highwatermark** property is 200.</span></span> <span data-ttu-id="ab95b-127">此外可以更改的值**的低水印**属性设置为较小的值。</span><span class="sxs-lookup"><span data-stu-id="ab95b-127">You can also change the value for the **Lowwatermark** property to a smaller value.</span></span>  
  
 <span data-ttu-id="ab95b-128">请记住的值**Highwatermark**异步适配器的消息引擎已提供给适配器的消息数的帐户的属性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-128">Remember that the value of the **Highwatermark** property for asynchronous adapters accounts for the number of messages that the Messaging Engine has given to the adapter.</span></span> <span data-ttu-id="ab95b-129">消息引擎将其传递给通过适配器`TransmitMessage`方法，这些消息可能仍处于传输过程中，例如，如果适配器未进行相应地调用`DeleteMessage`， `Resubmit`， `MoveToNextTransport`或[Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx)方法。</span><span class="sxs-lookup"><span data-stu-id="ab95b-129">The Messaging Engine passes them to the adapter through the `TransmitMessage` method, These messages can be still outstanding in their transmission—for example, if the adapter has not made a corresponding call to the `DeleteMessage`, `Resubmit`, `MoveToNextTransport`, or [Microsoft.BizTalk.TransportProxy.Interop.BatchOperationType.MoveToSuspendQ](http://msdn.microsoft.com/library/microsoft.biztalk.transportproxy.interop.batchoperationtype.aspx) methods.</span></span> <span data-ttu-id="ab95b-130">对于异步适配器**Highwatermark**属性仅占消息引擎已传递到由适配器使用的消息数**TransmitMessage**方法因为此调用进行同步处理，阻止调用消息引擎线程。</span><span class="sxs-lookup"><span data-stu-id="ab95b-130">For synchronous adapters, the **Highwatermark** property only accounts for the number of messages the Messaging Engine has passed to the adapter by using the **TransmitMessage** method because this call processes synchronously, blocking the calling Messaging Engine thread.</span></span>  
  
 <span data-ttu-id="ab95b-131">如果您在为本质上速度就较慢的协议（例如 HTTP、FTP 或双向 SOAP）编写发送适配器，请考虑以下方面：</span><span class="sxs-lookup"><span data-stu-id="ab95b-131">If you are writing a send adapter for a protocol that is inherently slow in nature (such as HTTP, FTP, or two-way SOAP), consider the following:</span></span>  
  
- <span data-ttu-id="ab95b-132">此类适配器接收从 BizTalk 消息引擎传输的消息速度可能快于它传送消息的速度。</span><span class="sxs-lookup"><span data-stu-id="ab95b-132">Such an adapter might receive messages for transmission from the BizTalk Messaging Engine faster than it can transmit them.</span></span> <span data-ttu-id="ab95b-133">这一差异会导致不同层面的问题。</span><span class="sxs-lookup"><span data-stu-id="ab95b-133">This discrepancy causes problems at various levels.</span></span> <span data-ttu-id="ab95b-134">传输中的消息仍保留在内存中并且占用虚拟内存，这将减慢整个系统的速度。</span><span class="sxs-lookup"><span data-stu-id="ab95b-134">The messages under transmission remain in memory and take up the virtual memory, slowing down the entire system.</span></span>  
  
- <span data-ttu-id="ab95b-135">适配器可能会占用特定于协议的资源。</span><span class="sxs-lookup"><span data-stu-id="ab95b-135">The adapter might take up protocol-specific resources.</span></span> <span data-ttu-id="ab95b-136">例如，可能会打开过多与服务器的并行连接，从而可能导致远程服务器崩溃。</span><span class="sxs-lookup"><span data-stu-id="ab95b-136">For example, it might open too many concurrent connections to the server, which could disrupt the remote server.</span></span>  
  
- <span data-ttu-id="ab95b-137">该适配器可能会影响其他适配器。</span><span class="sxs-lookup"><span data-stu-id="ab95b-137">The adapter might affect other adapters.</span></span> <span data-ttu-id="ab95b-138">例如，如果过多的消息为特定适配器排队，则消息引擎会停止发出对该进程中其他发送适配器的请求。</span><span class="sxs-lookup"><span data-stu-id="ab95b-138">For example, if too many messages queue up for a particular adapter, the Messaging Engine stops issuing requests to other send adapters in that process.</span></span>  
  
  <span data-ttu-id="ab95b-139">解决方法是将慢速和快速适配器放置于不同的 BizTalk 主机中，并且通过使用“高水位”和“低水位”设置控制消息的数目。</span><span class="sxs-lookup"><span data-stu-id="ab95b-139">A solution is to put the slow and fast adapters in separate BizTalk Hosts and control the number of messages by using the "High Watermark" and "Low Watermark" settings.</span></span>  
  
### <a name="receive-side-throttling-improves-performance"></a><span data-ttu-id="ab95b-140">接收端阻止提高性能</span><span class="sxs-lookup"><span data-stu-id="ab95b-140">Receive-Side Throttling Improves Performance</span></span>  
 <span data-ttu-id="ab95b-141">存在多种接收适配器接收消息的速度快于其余系统处理消息的速率的情况。</span><span class="sxs-lookup"><span data-stu-id="ab95b-141">There are numerous situations in which a receive adapter receives messages faster than the rate at which the rest of the system can process the messages.</span></span> <span data-ttu-id="ab95b-142">在发生此类情况时，MessageBox 数据库将开始积压。</span><span class="sxs-lookup"><span data-stu-id="ab95b-142">When such a situation occurs, the MessageBox database becomes backlogged.</span></span> <span data-ttu-id="ab95b-143">此时，整个系统的性能都会显著下降。</span><span class="sxs-lookup"><span data-stu-id="ab95b-143">When this happens, the performance of the whole system drops dramatically.</span></span>  
  
 <span data-ttu-id="ab95b-144">如果在您的适配器上发生这种情况，则可以使用以下技术之一来降低接收适配器的速度：</span><span class="sxs-lookup"><span data-stu-id="ab95b-144">If this is happening with your adapter, you can use one of the following techniques to reduce the speed of the receive adapter:</span></span>  
  
- <span data-ttu-id="ab95b-145">减少消息引擎线程池大小。</span><span class="sxs-lookup"><span data-stu-id="ab95b-145">Reduce the Messaging Engine thread pool size.</span></span> <span data-ttu-id="ab95b-146">您可以控制消息引擎用于将消息发布到 MessageBox 中的线程数目。</span><span class="sxs-lookup"><span data-stu-id="ab95b-146">You can control the number of threads that the Messaging Engine uses to publish messages into the MessageBox.</span></span> <span data-ttu-id="ab95b-147">通过减少线程数目，您将降低接收适配器将消息接收到 MessageBox 中的速率。</span><span class="sxs-lookup"><span data-stu-id="ab95b-147">By reducing the number of threads, you reduce the rate at which the receive adapter receives messages into the MessageBox.</span></span> <span data-ttu-id="ab95b-148">只需对与适配器的接收处理程序相对应的主机进行此设置。</span><span class="sxs-lookup"><span data-stu-id="ab95b-148">This setting only needs to be done for the host corresponding to the receive handler for the adapter.</span></span> <span data-ttu-id="ab95b-149">您不应为与适配器的发送处理程序相对应的主机进行此设置，除非您也想降低发送适配器的速度。</span><span class="sxs-lookup"><span data-stu-id="ab95b-149">You should not set this for the host corresponding to the send handler for the adapter, unless you want to slow down the send adapter as well.</span></span>  
  
- <span data-ttu-id="ab95b-150">减少适配器的批大小。</span><span class="sxs-lookup"><span data-stu-id="ab95b-150">Reduce the adapter batch size.</span></span> <span data-ttu-id="ab95b-151">大多数快速的接收适配器都将消息按批发送到 MessageBox。</span><span class="sxs-lookup"><span data-stu-id="ab95b-151">Most fast receive adapters publish messages to the MessageBox in batches.</span></span> <span data-ttu-id="ab95b-152">这些批的大小通常可在接收位置属性页中进行配置。</span><span class="sxs-lookup"><span data-stu-id="ab95b-152">The size of these batches is usually configurable in the receive location property page.</span></span> <span data-ttu-id="ab95b-153">通过减小批大小，您可以减少进入系统的消息的整体吞吐量。</span><span class="sxs-lookup"><span data-stu-id="ab95b-153">By decreasing the batch size you can decrease the overall throughput of messages coming into the system.</span></span>  
  
- <span data-ttu-id="ab95b-154">更改其他特定于适配器的设置。</span><span class="sxs-lookup"><span data-stu-id="ab95b-154">Change other adapter-specific settings.</span></span> <span data-ttu-id="ab95b-155">在您完成前两个步骤后，可以尝试调整其他适配器参数以便进一步降低吞吐量。</span><span class="sxs-lookup"><span data-stu-id="ab95b-155">After you complete the two previous steps, you can try adjusting other adapter parameters to further decrease throughput.</span></span> <span data-ttu-id="ab95b-156">某些适配器公开可用于降低吞吐量的内部参数。</span><span class="sxs-lookup"><span data-stu-id="ab95b-156">Some adapters expose internal parameters that can be used to decrease throughput.</span></span> <span data-ttu-id="ab95b-157">例如，MQSeries 适配器具有“按序送达”设置。</span><span class="sxs-lookup"><span data-stu-id="ab95b-157">For example, the MQSeries adapter has a setting for “Ordered Delivery.”</span></span> <span data-ttu-id="ab95b-158">“按序送达”指定适配器将发布一批消息，等待该批消息完成，然后发布下一批消息。</span><span class="sxs-lookup"><span data-stu-id="ab95b-158">Ordered Delivery specifies that the adapter will publish a batch of messages, wait for it to complete, and then publish the next batch.</span></span> <span data-ttu-id="ab95b-159">通过启用此设置，您将从根本上取消与接收适配器的所有并行性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-159">By enabling this setting, you essentially remove all parallelism from the receive adapter.</span></span> <span data-ttu-id="ab95b-160">反过来，通过使用相反的方法调整这些参数，可以提高接收适配器的接收速率。</span><span class="sxs-lookup"><span data-stu-id="ab95b-160">Conversely, tuning the parameters in the opposite way can be used to increase the receiving rate of a receive adapter.</span></span>  
  
  <span data-ttu-id="ab95b-161">一个适配器可以向传输代理提交所需的任何数目的批。</span><span class="sxs-lookup"><span data-stu-id="ab95b-161">An adapter can submit as many batches as required to the transport proxy.</span></span> <span data-ttu-id="ab95b-162">当系统负荷极高，先调用**完成**方法**IBTTransportBatch**接口将阻止消息，直到所需的资源被释放到系统。</span><span class="sxs-lookup"><span data-stu-id="ab95b-162">When the system is heavily stressed, a call to the **Done** method of the **IBTTransportBatch** interface will block the message until the required resources are released to the system.</span></span>  
  
## <a name="plan-for-asynchronous-receive-and-send"></a><span data-ttu-id="ab95b-163">计划异步接收和发送</span><span class="sxs-lookup"><span data-stu-id="ab95b-163">Plan for Asynchronous Receive and Send</span></span>  
 <span data-ttu-id="ab95b-164">BizTalk Server 消息 API 具有对异步编程的大量支持。</span><span class="sxs-lookup"><span data-stu-id="ab95b-164">The BizTalk Server messaging APIs have rich support for asynchronous programming.</span></span> <span data-ttu-id="ab95b-165">如果您想要编写可伸缩的适配器，则应该计划从头就开始使用异步模型，因为异步模型提供更好的并行性。</span><span class="sxs-lookup"><span data-stu-id="ab95b-165">If you want to write a scalable adapter, plan on using the asynchronous model from the start because the asynchronous model provides better concurrency.</span></span>  
  
 <span data-ttu-id="ab95b-166">在接收端，适配器提交一批消息到 BizTalk 消息引擎时 (通过调用**ibttransportbatch:: Done**)，消息引擎使用其内部线程池的工作进行排队并立即返回。</span><span class="sxs-lookup"><span data-stu-id="ab95b-166">On the receive side, when an adapter submits a batch of messages to the BizTalk Messaging Engine (by calling **IBTTransportBatch::Done**), the Messaging Engine queues up the work using its internal thread pool and returns immediately.</span></span> <span data-ttu-id="ab95b-167">该引擎将处理单独线程上的消息，保持适配器可以自由读取来自源的更多消息，并且无需等待以前的消息完成处理即可提交它们。</span><span class="sxs-lookup"><span data-stu-id="ab95b-167">The engine processes the messages on a separate thread, leaving the adapter free to read more messages from its source and submit them without waiting for the previous message processing to complete.</span></span>  
  
 <span data-ttu-id="ab95b-168">在发送端，您的适配器可以是异步的或同步的。</span><span class="sxs-lookup"><span data-stu-id="ab95b-168">On the send side, your adapter can be either asynchronous or synchronous.</span></span> <span data-ttu-id="ab95b-169">但是，如果您的协议支持异步操作，则应利用这一支持来编写可伸缩适配器。</span><span class="sxs-lookup"><span data-stu-id="ab95b-169">However, if your protocol supports asynchronous operations, you should use this support to write a scalable adapter.</span></span> <span data-ttu-id="ab95b-170">例如，FILE 和 HTTP 发送适配器是完全异步的，它们执行非常少的阻止/同步操作。</span><span class="sxs-lookup"><span data-stu-id="ab95b-170">For example, File and HTTP send adapters are fully asynchronous and they perform very few blocking/synchronous operations.</span></span>  
  
 <span data-ttu-id="ab95b-171">异步操作将确保消息引擎和您的适配器都将继续并行执行其各自的工作，在执行一般的消息处理时不必彼此等待。</span><span class="sxs-lookup"><span data-stu-id="ab95b-171">Asynchronous operations ensure that both the Messaging Engine and your adapter will continue to do their respective work in parallel and not wait on each other for normal message processing.</span></span>  
  
## <a name="use-batching-to-improve-performance"></a><span data-ttu-id="ab95b-172">使用批处理以改进性能</span><span class="sxs-lookup"><span data-stu-id="ab95b-172">Use Batching to Improve Performance</span></span>  
 <span data-ttu-id="ab95b-173">批处理是用于编写可伸缩适配器的最佳起点。</span><span class="sxs-lookup"><span data-stu-id="ab95b-173">Batching is the best starting point for writing a scalable adapter.</span></span> <span data-ttu-id="ab95b-174">这一点在发送端和接收端适配器均成立。</span><span class="sxs-lookup"><span data-stu-id="ab95b-174">This is true for both send-side and receive-side adapters.</span></span> <span data-ttu-id="ab95b-175">即使您的适配器是非事务性的，每个批也都要通过 BizTalk Server 内的数据库事务。</span><span class="sxs-lookup"><span data-stu-id="ab95b-175">Every batch goes through a database transaction within BizTalk Server even if your adapter is nontransactional.</span></span> <span data-ttu-id="ab95b-176">因为存在与每个事务相关联的固定延迟，所以，您应该通过将多个操作合并为单个批，尝试尽量减少事务的数目。</span><span class="sxs-lookup"><span data-stu-id="ab95b-176">Because there is a fixed delay associated with each transaction, you should try to minimize the number of transactions by combining more than one operation into a single batch.</span></span>  
  
## <a name="do-not-starve-the-net-thread-pool"></a><span data-ttu-id="ab95b-177">不要让 .NET 线程池闲置</span><span class="sxs-lookup"><span data-stu-id="ab95b-177">Do Not Starve the .NET Thread Pool</span></span>  
 <span data-ttu-id="ab95b-178">编写 BizTalk 适配器有助于练习编写 .NET 运行时代码，编写 .NET 运行时代码也一定有助于练习异步编程。</span><span class="sxs-lookup"><span data-stu-id="ab95b-178">Writing BizTalk adapters is an exercise in writing .NET runtime code; writing .NET runtime code is invariably an exercise in asynchronous programming.</span></span>  
  
 <span data-ttu-id="ab95b-179">让 .NET 线程池闲置对于 .NET 中的所有异步编程都带来风险，因此是 BizTalk 适配器编程人员应极力避免的。</span><span class="sxs-lookup"><span data-stu-id="ab95b-179">Starving the .NET thread pool is a risk to all asynchronous programming in .NET, and it is particularly important for the BizTalk adapter programmer to avoid.</span></span>  
  
 <span data-ttu-id="ab95b-180">.NET 线程池是受到限制但全面共享的资源。</span><span class="sxs-lookup"><span data-stu-id="ab95b-180">The .NET thread pool is a limited but widely shared resource.</span></span> <span data-ttu-id="ab95b-181">可以很容易地就编写使用某一 .NET 线程池线程并且将其保留很长时间的代码，并且该代码可阻止其他工作项执行。</span><span class="sxs-lookup"><span data-stu-id="ab95b-181">It is easy to write code that uses one of the .NET thread pool threads and holds onto it for long time, blocking other work items from being executed.</span></span>  
  
 <span data-ttu-id="ab95b-182">您每次使用**BeginInvoke**或使用一个计时器，使用.NET 线程池线程。</span><span class="sxs-lookup"><span data-stu-id="ab95b-182">Whenever you use **BeginInvoke** or use a timer, you are using a .NET thread pool thread.</span></span> <span data-ttu-id="ab95b-183">如果有多个部分的工作要做 （例如将复制从 MQSeries 消息到 BizTalk Server 中），你应执行一个工作项 （一批消息到 BizTalk Server 中），然后重新排队在线程池中是否存在更多工作要做。</span><span class="sxs-lookup"><span data-stu-id="ab95b-183">If you have multiple pieces of work to do (for example copying messages out of MQSeries into BizTalk Server), you should execute one work item (one batch of messages into BizTalk Server) and then requeue in the thread pool if there is more work to do.</span></span> <span data-ttu-id="ab95b-184">永远不会进入`while`线程上的循环。</span><span class="sxs-lookup"><span data-stu-id="ab95b-184">Never sit in a `while` loop on the thread.</span></span>  
  
 <span data-ttu-id="ab95b-185">具体而言，这意味着替换`while`通过重复调用循环**BeginInvoke**。</span><span class="sxs-lookup"><span data-stu-id="ab95b-185">In concrete terms this means replacing `while` loops with repeated calls to **BeginInvoke**.</span></span> <span data-ttu-id="ab95b-186">这一简单的更改可以显著改善整个实现的响应性和扩展能力。</span><span class="sxs-lookup"><span data-stu-id="ab95b-186">This simple change can dramatically improve the responsiveness and scale-out ability for the whole implementation.</span></span>  
  
## <a name="choose-the-right-measurement-when-limiting-batch-size"></a><span data-ttu-id="ab95b-187">在限制批大小时选择正确的度量</span><span class="sxs-lookup"><span data-stu-id="ab95b-187">Choose the Right Measurement When Limiting Batch Size</span></span>  
 <span data-ttu-id="ab95b-188">如果您将消息成批提交到 BizTalk Server，则不要只基于消息计数限制批大小。</span><span class="sxs-lookup"><span data-stu-id="ab95b-188">If you are submitting messages to BizTalk Server in batches, do not limit the batch size based only on the message count.</span></span> <span data-ttu-id="ab95b-189">请考虑会发生什么情况配置适配器时进行批处理只基于消息计数： 如果批大小为 2，并且适配器获取的四个消息分别，大小为 4 KB，8 KB，1 MB 和 5 MB 的将第一个批处理大小为 12 KB并且是第二个批次大小为 6 MB。</span><span class="sxs-lookup"><span data-stu-id="ab95b-189">Consider what happens when an adapter has been configured to batch based only on message count: If the batch size is two and the adapter gets four messages of size 4 KB, 8 KB, 1 MB, and 5MB respectively, the first batch will be of size 12 KB, and the second batch will be of size 6 MB.</span></span>  
  
 <span data-ttu-id="ab95b-190">因为 BizTalk 消息引擎顺序处理单个批中的所有消息，所以，在此示例中，对第二个批的处理速度比对第一个批的处理速度要慢得多。</span><span class="sxs-lookup"><span data-stu-id="ab95b-190">Because the BizTalk Messaging Engine processes all messages in a single batch sequentially, the second batch in this example will be processed much more slowly than the first batch.</span></span> <span data-ttu-id="ab95b-191">这将大幅降低吞吐量。</span><span class="sxs-lookup"><span data-stu-id="ab95b-191">This is effectively reducing throughput.</span></span> <span data-ttu-id="ab95b-192">处理这一问题的一个较好的方法是基于消息计数和批中总字节数（即，按字节计算的批大小）进行批处理。</span><span class="sxs-lookup"><span data-stu-id="ab95b-192">A better way to handle this problem is to batch based on both message count and total bytes in the batch (that is, batch size in bytes).</span></span> <span data-ttu-id="ab95b-193">不存在针对总字节数的神奇数字。</span><span class="sxs-lookup"><span data-stu-id="ab95b-193">There is no magic number for total bytes.</span></span> <span data-ttu-id="ab95b-194">但是，在一般的处理情况中，如果批大小超过 1 MB，并行性和吞吐量都将开始下降。</span><span class="sxs-lookup"><span data-stu-id="ab95b-194">However, in a normal processing scenario, if the batch size exceeds 1 MB, you will start seeing poor concurrency and throughput.</span></span>  
  
 <span data-ttu-id="ab95b-195">通常，适配器是不知道消息情况的，它们不知道生产环境中消息的大小。</span><span class="sxs-lookup"><span data-stu-id="ab95b-195">Generally adapters are message agnostic and they do not know the size of the messages in the production environment.</span></span> <span data-ttu-id="ab95b-196">传入的消息的大小很可能差别很大。</span><span class="sxs-lookup"><span data-stu-id="ab95b-196">The sizes of the incoming messages are likely to vary significantly.</span></span> <span data-ttu-id="ab95b-197">因此，应始终使用消息计数和总字节数来生成批。</span><span class="sxs-lookup"><span data-stu-id="ab95b-197">Because of this, always use message count and total bytes to build the batch.</span></span>