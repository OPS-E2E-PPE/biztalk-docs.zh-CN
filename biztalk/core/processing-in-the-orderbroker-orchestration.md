---
title: 在 OrderBroker 业务流程处理 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- orchestrations, examples
- orchestrations, nested scopes
- nested scopes, performance
- processing, examples
- nested scopes, orchestrations
- orchestrations, performance
- performance, orchestrations
- performance, nested scopes
- examples, orchestration processing [process management solution]
- scopes, nesting
ms.assetid: c296e00c-b3ad-4161-baf7-258899185c34
caps.latest.revision: 23
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 7c6a6571ece3190b6195b207b4c45969ce25ddec
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
ms.locfileid: "22266629"
---
# <a name="processing-in-the-orderbroker-orchestration"></a><span data-ttu-id="f8b0d-102">OrderBroker 业务流程中的处理</span><span class="sxs-lookup"><span data-stu-id="f8b0d-102">Processing in the OrderBroker Orchestration</span></span>
<span data-ttu-id="f8b0d-103">本部分介绍如何**OrderBroker**业务流程接受订单和准备进程管理器。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-103">This section describes how the **OrderBroker** orchestration takes orders and prepares them for a process manager.</span></span> <span data-ttu-id="f8b0d-104">本部分首先介绍了该业务流程的日常工作。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-104">The section begins by discussing the general workings of the orchestration.</span></span> <span data-ttu-id="f8b0d-105">随后的部分将介绍该业务流程如何处理消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-105">The next part discusses how the orchestration processes a message.</span></span> <span data-ttu-id="f8b0d-106">然后，将重点介绍该业务流程如何使用原子事务来提高性能。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-106">It then highlights how the orchestration uses an atomic transaction to improve performance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8b0d-107">由于的长度的长度**OrderBroker**代码中，你可能想要阅读此部分与 Microsoft® Visual Studio 中打开业务流程。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-107">Because of the length of the length of the **OrderBroker** code, you may want to read this section with the orchestration open in Microsoft® Visual Studio.</span></span>  
  
## <a name="why-an-order-broker"></a><span data-ttu-id="f8b0d-108">为什么使用 OrderBroker？</span><span class="sxs-lookup"><span data-stu-id="f8b0d-108">Why an Order Broker?</span></span>  
 <span data-ttu-id="f8b0d-109">用途**OrderBroker** orchestration 是预处理订单，并将它路由到正确的进程管理器。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-109">The purpose of the **OrderBroker** orchestration is to preprocess an order and route it to the correct process manager.</span></span> <span data-ttu-id="f8b0d-110">上述预处理包括为历史记录数据库、服务系统以及确认订单的接收生成信息性消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-110">Pre-processing here consists of producing informational messages for the history database, for the servicing system, and to acknowledge receipt of the order.</span></span> <span data-ttu-id="f8b0d-111">**OrderBroker**还从客户服务请求创建泛型订单消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-111">The **OrderBroker** also creates a generic order message from the customer service request.</span></span> <span data-ttu-id="f8b0d-112">这种订单规范化允许订单通用于业务流程的各个元素。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-112">This normalization of the order allows for generic consumption of the order by elements of the business process.</span></span>  
  
 <span data-ttu-id="f8b0d-113">订单消息是包含独立于订单信息的路由信息的多部分消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-113">The order message is a multipart message with routing information separated from the order information.</span></span> <span data-ttu-id="f8b0d-114">路由信息也是通用的，其设计为可供任何订单管理器使用。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-114">The routing information is also generic and designed to be consumed by any order manager.</span></span> <span data-ttu-id="f8b0d-115">从而，可以更方便地扩展解决方案。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-115">This, in turn, makes it easier to expand the solution.</span></span> <span data-ttu-id="f8b0d-116">多部分消息有关的信息，请参阅[如何使用多部分消息类型](../core/how-to-use-multi-part-message-types.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-116">For information about multi-part messages, see [How to Use Multi-part Message Types](../core/how-to-use-multi-part-message-types.md).</span></span>  
  
 <span data-ttu-id="f8b0d-117">通过将执行 Broker 功能与其他功能相隔离，您也可以将该功能移至其他 BizTalk 组。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-117">Isolating the brokering function also allows you to move it to another BizTalk group.</span></span> <span data-ttu-id="f8b0d-118">因为**OrderBroker**将发布到 MessageBox 数据库-即，它是直接绑定-还简化了将 broker 放置在另一个组-可以移动 broker 而无需更改业务流程。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-118">Because the **OrderBroker** publishes to the MessageBox database—that is, it is direct-bound—also makes it easier to put the broker in another group --you can move the broker without changing the orchestration.</span></span> <span data-ttu-id="f8b0d-119">有关详细信息将放置**OrderBroker**在另一个组中，请参阅[OrderBroker 和 OrderManager 之间的通信](../core/communication-between-orderbroker-and-ordermanager.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-119">For more information about putting the **OrderBroker** in another group, see [Communication between OrderBroker and OrderManager](../core/communication-between-orderbroker-and-ordermanager.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8b0d-120">**OrderBroker**业务流程，因为它具有只有一个**OrderManager**能够与通信，只需将常量字符串以**OrderMgrType**字段的顺序管理器消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-120">The **OrderBroker** orchestration, because it has only one **OrderManager** to communicate with, simply assigns a constant string to the **OrderMgrType** field in the order manager message.</span></span> <span data-ttu-id="f8b0d-121">通常，在存在多个订单管理器的应用程序中，该应用程序将使用业务规则引擎来确定此字段的适当值和订单路由。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-121">Typically, in an application where there were multiple order managers, the application would use the Business Rule Engine to determine the proper value for this field and the order routing.</span></span> <span data-ttu-id="f8b0d-122">有关业务规则引擎的详细信息，请参阅[创建和使用业务规则](../core/creating-and-using-business-rules.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-122">For more information about the Business Rule Engine, see [Creating and Using Business Rules](../core/creating-and-using-business-rules.md).</span></span>  
  
## <a name="order-processing"></a><span data-ttu-id="f8b0d-123">订单处理</span><span class="sxs-lookup"><span data-stu-id="f8b0d-123">Order Processing</span></span>  
 <span data-ttu-id="f8b0d-124">**OrderBroker** orchestration 开头两个**接收**内的形状**侦听**形状。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-124">The **OrderBroker** orchestration begins with two **Receive** shapes within a **Listen** shape.</span></span> <span data-ttu-id="f8b0d-125">一个**接收**形状将消息从客户支持系统; 从供应商系统的其他消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-125">One **Receive** shape takes messages from the customer support system; the other, messages from the vendor system.</span></span> <span data-ttu-id="f8b0d-126">来自任一来源的消息都具有相同的架构。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-126">Messages from either source have the same schema.</span></span>  
  
 <span data-ttu-id="f8b0d-127">业务流程从消息中提取的寄信人地址并使用它来设置的动态端口地址**CSRPort**。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-127">The orchestration extracts the return address from the message and uses it to set the address for the dynamic port, **CSRPort**.</span></span> <span data-ttu-id="f8b0d-128">该业务流程使用此端口来发送确认和错误消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-128">The orchestration uses this port to send acknowledgement and error messages.</span></span>  
  
 <span data-ttu-id="f8b0d-129">中的下一个步骤**OrderBroker**业务流程创建历史记录消息、 服务消息，确认消息中，和订单消息将发送到**OrderManager**业务流程。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-129">The next steps in the **OrderBroker** orchestration create the history message, the service message, the confirmation message, and the order message to send to the **OrderManager** orchestration.</span></span> <span data-ttu-id="f8b0d-130">业务流程使用**InsertOrderBody**实用工具函数，用于将订单消息添加到历史记录消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-130">The orchestration uses the **InsertOrderBody** utility function to add the order message to the history message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f8b0d-131">在某些情况下，解决方案可能会生成已传送但未使用的消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-131">In some situations the solution may produce messages that are delivered but not consumed.</span></span> <span data-ttu-id="f8b0d-132">OrderBroker 业务流程使用发送端口将信息插入历史记录数据库中。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-132">The order broker orchestration uses a send port to insert information in the history database.</span></span> <span data-ttu-id="f8b0d-133">此发送端口使用送达通知。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-133">This send port uses delivery notification.</span></span> <span data-ttu-id="f8b0d-134">配置将发送端口映射到包含两个端口的发送端口组-一个用于测试配置端口 (**HistoryInsert 测试 SP**)，一个用于常规配置 (**HistoryInsert SP**)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-134">Configuration maps the send port to a send port group containing two ports—one port for the test configuration (**HistoryInsert-Test-SP**), one for the regular configuration (**HistoryInsert-SP**).</span></span> <span data-ttu-id="f8b0d-135">如果将该组中的两个端口都保持运行状态，则解决方案将在这两个端口上发送消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-135">If you leave both ports in the group running, the solution sends messages on both ports.</span></span> <span data-ttu-id="f8b0d-136">因而，该解决方案将请求两个送达通知，但仅处理其中一个通知。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-136">It thus requests two delivery notifications but processes only one.</span></span>  
>   
>  <span data-ttu-id="f8b0d-137">若要避免这种情况下，取消登记测试端口 (**HistoryInsert 测试 SP**)，或停止测试版本的应用程序， **BTSScn.BPM.OrderBrokerApp.Test**。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-137">To avoid this situation, unenlist the test port (**HistoryInsert-Test-SP**), or stop the test version of the application, **BTSScn.BPM.OrderBrokerApp.Test**.</span></span> <span data-ttu-id="f8b0d-138">有关传递通知的详细信息，请参阅[使用确认](../core/using-acknowledgments.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-138">For more information about delivery notifications, see [Using Acknowledgments](../core/using-acknowledgments.md).</span></span>  
  
 <span data-ttu-id="f8b0d-139">构造要发送到的消息时**OrderManager**业务流程、 **OrderBroker**业务流程创建包含两个部分的多个部分的消息。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-139">When constructing the message to send to the **OrderManager** orchestration, the **OrderBroker** orchestration creates a multi-part message with two parts.</span></span> <span data-ttu-id="f8b0d-140">其中一个部分包含路由信息，另一个部分包含订单自身。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-140">One part contains the routing information; the other, the order itself.</span></span> <span data-ttu-id="f8b0d-141">该消息的路由部分**OrderMgrMsg.Routing**，使用由 C# 类中定义了架构**SchemaClasses**程序集。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-141">The routing part of the message, **OrderMgrMsg.Routing**, uses a schema defined by a C# class in the **SchemaClasses** assembly.</span></span> <span data-ttu-id="f8b0d-142">为泛型时，消息的一部分或类型不可知的顺序，XML 文档，则代理会将 (**System.Xml.XmlDocument**) 并将它分配给**OrderMgrMsg.Order**。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-142">The broker treats the order part of the message as a generic, or type-agnostic, XML document (**System.Xml.XmlDocument**) and assigns it to **OrderMgrMsg.Order**.</span></span>  
  
 <span data-ttu-id="f8b0d-143">路由的信息对顺序管理器中，尤其是重要的两个字段**OrderMgrMsg.Routing.OrderMgrType**和**OrderMgrMsg.Routing.Status**。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-143">There are two fields in the routing information that are especially important to the order manager, **OrderMgrMsg.Routing.OrderMgrType** and **OrderMgrMsg.Routing.Status**.</span></span> <span data-ttu-id="f8b0d-144">Broker 集**OrderMgrType**为是处理顺序的顺序管理器的类型。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-144">The broker sets the **OrderMgrType** to the type of the order manager that is to handle the order.</span></span> <span data-ttu-id="f8b0d-145">在该解决方案中只有一个订单管理器，并且该字段设置为 CABLEORDER。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-145">In the solution, there is only one order manager and the field is set to CABLEORDER.</span></span> <span data-ttu-id="f8b0d-146">代理还将设置**状态**字段已接受。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-146">The broker also sets the **Status** field to ACCEPTED.</span></span> <span data-ttu-id="f8b0d-147">此字段是用于通知订单管理器该消息为新订单的值。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-147">This is the value that tells the order manager the message is a new order.</span></span> <span data-ttu-id="f8b0d-148">在解决方案中，订单管理器**OrderManager**业务流程，使用**接收**筛选器的步骤顺序类型等于 CABLEORDER 和等于已接受的状态的形状。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-148">The order manager in the solution, **OrderManager** orchestration, uses a **Receive** shape that filters for the order type equal to CABLEORDER and status equal to ACCEPTED.</span></span>  
  
 <span data-ttu-id="f8b0d-149">中的其余步骤**OrderBroker**业务流程将不同的消息发送到相应的端口。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-149">The remaining steps in the **OrderBroker** orchestration send the different messages to the appropriate ports.</span></span>  
  
## <a name="improving-performance-with-nested-scopes"></a><span data-ttu-id="f8b0d-150">使用嵌套的作用域提高性能</span><span class="sxs-lookup"><span data-stu-id="f8b0d-150">Improving Performance with Nested Scopes</span></span>  
 <span data-ttu-id="f8b0d-151">有关值得注意的要点之一**OrderBroker** orchestration 是其使用嵌套的作用域。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-151">One of the noticeable things about the **OrderBroker** orchestration is its use of nested scopes.</span></span> <span data-ttu-id="f8b0d-152">嵌套作用域的部分用途是通过限制持久化点来提高性能。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-152">The nested scopes are there, in part, to improve performance by limiting the persistence points.</span></span>  
  
 <span data-ttu-id="f8b0d-153">业务流程引擎将定期保存整个业务流程在称为持久化点的执行点时的状态。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-153">The orchestration engine periodically saves the state of the entire orchestration at execution points called persistence points.</span></span> <span data-ttu-id="f8b0d-154">业务流程引擎会自动将多个业务流程形状，包括**发送**形状，作为持久性点。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-154">The orchestration engine automatically treats several orchestration shapes, including **Send** shapes, as persistence points.</span></span> <span data-ttu-id="f8b0d-155">持久性点和有关它们的详细信息的列表，请参阅[持久性和业务流程引擎](../core/persistence-and-the-orchestration-engine.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-155">For a list of persistence points and more information about them, see [Persistence and the Orchestration Engine](../core/persistence-and-the-orchestration-engine.md).</span></span>  
  
 <span data-ttu-id="f8b0d-156">具有五个**发送**形状， **OrderBroker** orchestration 应具有五个持久性点。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-156">With five **Send** shapes, the **OrderBroker** orchestration should have five persistence points.</span></span> <span data-ttu-id="f8b0d-157">但是，当组**发送**在原子事务范围内的形状，引擎能够识别，只需一个持久点的范围。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-157">However, when you group **Send** shapes inside an atomic transaction scope, the engine recognizes it only needs one persistence point for the scope.</span></span> <span data-ttu-id="f8b0d-158">因为这四个**发送**中的形状**OrderBroker**业务流程不是异常处理程序的一部分，并且无需完成后发送，他们就可以在原子事务范围内。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-158">Because four of the **Send** shapes in **OrderBroker** orchestration are not part of exception handlers and nothing needs to be done after the send, they can go in an atomic transaction scope.</span></span> <span data-ttu-id="f8b0d-159">这样将会减少持久化点数。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-159">This reduces the number of persistence points.</span></span> <span data-ttu-id="f8b0d-160">有关原子事务的详细信息，请参阅[原子事务](../core/atomic-transactions.md)。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-160">For more information about atomic transactions, see [Atomic Transactions](../core/atomic-transactions.md).</span></span>  
  
 <span data-ttu-id="f8b0d-161">此外，如果嵌套事务都在同一时间结束，则业务流程引擎将为这些事务使用单个持久化点。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-161">In addition, the orchestration engine will use a single persistence point for nested transactions if the transactions all end at the same time.</span></span> <span data-ttu-id="f8b0d-162">因此的方式**OrderBroker** orchestration 嵌套事务进一步减少持久性点： 该业务流程没有单个暂留点由于使用了**作用域**形状。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-162">Thus, the way **OrderBroker** orchestration nests transactions further reduces the persistence points: the orchestration has a single persistence point due to the use of **Scope** shapes.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="f8b0d-163">可以通过最大限度地减少业务流程中的持久化点来提高性能。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-163">You can improve performance by minimizing the number of persistence points in an orchestration.</span></span> <span data-ttu-id="f8b0d-164">你可以分组**发送**形状在原子事务以生成单个暂留点的所有**发送**形状。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-164">You can group **Send** shapes in an atomic transaction to produce a single persistence point for all of the **Send** shapes.</span></span> <span data-ttu-id="f8b0d-165">如果同时结束嵌套事务作用域，将会为这些事务生成单个持久化点。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-165">Ending nested transaction scopes at the same time produces a single persistence point for the transactions.</span></span>  
  
 <span data-ttu-id="f8b0d-166">原子事务作用域不能具有异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-166">An atomic transaction scope cannot have an exception handler.</span></span> <span data-ttu-id="f8b0d-167">因此，该业务流程将原子作用域嵌套在长期事务中。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-167">Because of this, the orchestration nests the atomic scope inside a long running transaction.</span></span> <span data-ttu-id="f8b0d-168">此外部事务可以异常处理程序，并且它是此处理程序处理中的发生异常**发送**形状。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-168">This outer transaction can have an exception handler and it is this handler that processes an exception from the **Send** shapes.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="f8b0d-169">将原子事务嵌套在长期事务中是允许进行异常处理的通用模式。</span><span class="sxs-lookup"><span data-stu-id="f8b0d-169">Nesting an atomic transaction inside a long running transaction is a common pattern to allow for exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f8b0d-170">另请参阅</span><span class="sxs-lookup"><span data-stu-id="f8b0d-170">See Also</span></span>  
 <span data-ttu-id="f8b0d-171">[在业务流程管理解决方案中进行处理](../core/processing-in-the-business-process-management-solution.md) </span><span class="sxs-lookup"><span data-stu-id="f8b0d-171">[Processing in the Business Process Management Solution](../core/processing-in-the-business-process-management-solution.md) </span></span>  
 <span data-ttu-id="f8b0d-172">[过程管理器逻辑](../core/process-manager-logic.md) </span><span class="sxs-lookup"><span data-stu-id="f8b0d-172">[Process Manager Logic](../core/process-manager-logic.md) </span></span>  
 <span data-ttu-id="f8b0d-173">[中断业务流程管理解决方案中的处理](../core/interrupt-handling-in-the-business-process-management-solution.md) </span><span class="sxs-lookup"><span data-stu-id="f8b0d-173">[Interrupt Handling in the Business Process Management Solution](../core/interrupt-handling-in-the-business-process-management-solution.md) </span></span>  
 [<span data-ttu-id="f8b0d-174">ExceptionHandler 业务流程</span><span class="sxs-lookup"><span data-stu-id="f8b0d-174">The ExceptionHandler Orchestration</span></span>](../core/the-exceptionhandler-orchestration.md)