---
title: 在 OrderBroker 业务流程中处理 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- orchestrations, examples
- orchestrations, nested scopes
- nested scopes, performance
- processing, examples
- nested scopes, orchestrations
- orchestrations, performance
- performance, orchestrations
- performance, nested scopes
- examples, orchestration processing [process management solution]
- scopes, nesting
ms.assetid: c296e00c-b3ad-4161-baf7-258899185c34
caps.latest.revision: 23
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: d21d91cb8d03adadbd93296f1875efb681b674b0
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65255199"
---
# <a name="processing-in-the-orderbroker-orchestration"></a><span data-ttu-id="9cef6-102">OrderBroker 业务流程中处理</span><span class="sxs-lookup"><span data-stu-id="9cef6-102">Processing in the OrderBroker Orchestration</span></span>
<span data-ttu-id="9cef6-103">本部分介绍如何**OrderBroker**业务流程获取订单并做好准备，进程管理器。</span><span class="sxs-lookup"><span data-stu-id="9cef6-103">This section describes how the **OrderBroker** orchestration takes orders and prepares them for a process manager.</span></span> <span data-ttu-id="9cef6-104">本部分首先讨论该业务流程的日常工作。</span><span class="sxs-lookup"><span data-stu-id="9cef6-104">The section begins by discussing the general workings of the orchestration.</span></span> <span data-ttu-id="9cef6-105">下一部分讨论该业务流程如何处理一条消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-105">The next part discusses how the orchestration processes a message.</span></span> <span data-ttu-id="9cef6-106">它然后突出显示了业务流程如何使用原子事务来提高性能。</span><span class="sxs-lookup"><span data-stu-id="9cef6-106">It then highlights how the orchestration uses an atomic transaction to improve performance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cef6-107">由于的长度的长度**OrderBroker**代码中，你可能想要阅读此部分与 Microsoft® Visual Studio 中打开业务流程。</span><span class="sxs-lookup"><span data-stu-id="9cef6-107">Because of the length of the length of the **OrderBroker** code, you may want to read this section with the orchestration open in Microsoft® Visual Studio.</span></span>  
  
## <a name="why-an-order-broker"></a><span data-ttu-id="9cef6-108">为什么使用 Orderbroker？</span><span class="sxs-lookup"><span data-stu-id="9cef6-108">Why an Order Broker?</span></span>  
 <span data-ttu-id="9cef6-109">目的**OrderBroker**业务流程是预处理订单并将其路由到正确的进程管理器。</span><span class="sxs-lookup"><span data-stu-id="9cef6-109">The purpose of the **OrderBroker** orchestration is to preprocess an order and route it to the correct process manager.</span></span> <span data-ttu-id="9cef6-110">预处理包括生成的历史记录数据库、 服务系统以及确认订单的接收的信息性消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-110">Pre-processing here consists of producing informational messages for the history database, for the servicing system, and to acknowledge receipt of the order.</span></span> <span data-ttu-id="9cef6-111">**OrderBroker**还从客户服务请求创建通用的订单消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-111">The **OrderBroker** also creates a generic order message from the customer service request.</span></span> <span data-ttu-id="9cef6-112">此订单规范化允许订单的泛型消耗由业务流程的元素。</span><span class="sxs-lookup"><span data-stu-id="9cef6-112">This normalization of the order allows for generic consumption of the order by elements of the business process.</span></span>  
  
 <span data-ttu-id="9cef6-113">订单消息是分开的订单信息的路由信息的多部分消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-113">The order message is a multipart message with routing information separated from the order information.</span></span> <span data-ttu-id="9cef6-114">路由信息也是泛型，旨在供任何订单管理器。</span><span class="sxs-lookup"><span data-stu-id="9cef6-114">The routing information is also generic and designed to be consumed by any order manager.</span></span> <span data-ttu-id="9cef6-115">这进而使更方便地扩展解决方案。</span><span class="sxs-lookup"><span data-stu-id="9cef6-115">This, in turn, makes it easier to expand the solution.</span></span> <span data-ttu-id="9cef6-116">有关多部分消息的信息，请参阅[如何使用多部分消息类型](../core/how-to-use-multi-part-message-types.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-116">For information about multi-part messages, see [How to Use Multi-part Message Types](../core/how-to-use-multi-part-message-types.md).</span></span>  
  
 <span data-ttu-id="9cef6-117">隔离中转函数还可将其移到另一个 BizTalk 组。</span><span class="sxs-lookup"><span data-stu-id="9cef6-117">Isolating the brokering function also allows you to move it to another BizTalk group.</span></span> <span data-ttu-id="9cef6-118">因为**OrderBroker**将发布到 MessageBox 数据库 — 也就是说，它是直接绑定，还可以轻松将 broker 放在另一个组中即可移动 broker 而无需更改业务流程。</span><span class="sxs-lookup"><span data-stu-id="9cef6-118">Because the **OrderBroker** publishes to the MessageBox database—that is, it is direct-bound—also makes it easier to put the broker in another group --you can move the broker without changing the orchestration.</span></span> <span data-ttu-id="9cef6-119">有关放置的详细信息**OrderBroker**中另一个组，请参阅[OrderBroker 和 OrderManager 之间的通信](../core/communication-between-orderbroker-and-ordermanager.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-119">For more information about putting the **OrderBroker** in another group, see [Communication between OrderBroker and OrderManager](../core/communication-between-orderbroker-and-ordermanager.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cef6-120">**OrderBroker**业务流程，因为它具有只有一个**OrderManager**与进行通信，只需将分配一个常量字符串到**OrderMgrType**字段的顺序管理器消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-120">The **OrderBroker** orchestration, because it has only one **OrderManager** to communicate with, simply assigns a constant string to the **OrderMgrType** field in the order manager message.</span></span> <span data-ttu-id="9cef6-121">通常情况下，在应用程序方面存在多个订单管理器，该应用程序将使用业务规则引擎来确定此字段和订单路由的正确值。</span><span class="sxs-lookup"><span data-stu-id="9cef6-121">Typically, in an application where there were multiple order managers, the application would use the Business Rule Engine to determine the proper value for this field and the order routing.</span></span> <span data-ttu-id="9cef6-122">有关业务规则引擎的详细信息，请参阅[创建和使用业务规则](../core/creating-and-using-business-rules.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-122">For more information about the Business Rule Engine, see [Creating and Using Business Rules](../core/creating-and-using-business-rules.md).</span></span>  
  
## <a name="order-processing"></a><span data-ttu-id="9cef6-123">订单处理</span><span class="sxs-lookup"><span data-stu-id="9cef6-123">Order Processing</span></span>  
 <span data-ttu-id="9cef6-124">**OrderBroker**具有两个业务流程首先**接收**形状内**侦听**形状。</span><span class="sxs-lookup"><span data-stu-id="9cef6-124">The **OrderBroker** orchestration begins with two **Receive** shapes within a **Listen** shape.</span></span> <span data-ttu-id="9cef6-125">一个**接收**形状将消息从客户支持系统; 从供应商系统的其他消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-125">One **Receive** shape takes messages from the customer support system; the other, messages from the vendor system.</span></span> <span data-ttu-id="9cef6-126">来自任一来源的消息具有相同的架构。</span><span class="sxs-lookup"><span data-stu-id="9cef6-126">Messages from either source have the same schema.</span></span>  
  
 <span data-ttu-id="9cef6-127">业务流程从消息中提取返回地址，并使用它来设置动态端口地址**csrport 的地址**。</span><span class="sxs-lookup"><span data-stu-id="9cef6-127">The orchestration extracts the return address from the message and uses it to set the address for the dynamic port, **CSRPort**.</span></span> <span data-ttu-id="9cef6-128">业务流程使用此端口来发送确认和错误消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-128">The orchestration uses this port to send acknowledgement and error messages.</span></span>  
  
 <span data-ttu-id="9cef6-129">下一步中的步骤**OrderBroker**业务流程创建历史记录消息、 服务消息、 确认消息和订单消息将发送到**OrderManager**业务流程。</span><span class="sxs-lookup"><span data-stu-id="9cef6-129">The next steps in the **OrderBroker** orchestration create the history message, the service message, the confirmation message, and the order message to send to the **OrderManager** orchestration.</span></span> <span data-ttu-id="9cef6-130">该业务流程使用**InsertOrderBody**实用工具函数将订单消息添加到历史记录消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-130">The orchestration uses the **InsertOrderBody** utility function to add the order message to the history message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9cef6-131">在某些情况下该解决方案可能会产生已传送但未使用的消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-131">In some situations the solution may produce messages that are delivered but not consumed.</span></span> <span data-ttu-id="9cef6-132">Orderbroker 业务流程使用发送端口以将信息插入历史记录数据库中。</span><span class="sxs-lookup"><span data-stu-id="9cef6-132">The order broker orchestration uses a send port to insert information in the history database.</span></span> <span data-ttu-id="9cef6-133">此发送端口使用送达通知。</span><span class="sxs-lookup"><span data-stu-id="9cef6-133">This send port uses delivery notification.</span></span> <span data-ttu-id="9cef6-134">配置将发送端口映射到包含两个端口的发送端口组，一个用于测试配置端口 (**测试-HISTORYINSERT-SP**)，一个常规配置 (**HISTORYINSERT-SP**)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-134">Configuration maps the send port to a send port group containing two ports—one port for the test configuration (**HistoryInsert-Test-SP**), one for the regular configuration (**HistoryInsert-SP**).</span></span> <span data-ttu-id="9cef6-135">如果将这两个端口中运行的组，该解决方案在这两个端口上发送消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-135">If you leave both ports in the group running, the solution sends messages on both ports.</span></span> <span data-ttu-id="9cef6-136">因此，请求两个送达通知，但仅处理其中一个。</span><span class="sxs-lookup"><span data-stu-id="9cef6-136">It thus requests two delivery notifications but processes only one.</span></span>  
>   
>  <span data-ttu-id="9cef6-137">若要避免这种情况下，取消登记测试端口 (**测试-HISTORYINSERT-SP**)，或停止该应用程序的测试版本**BTSScn.BPM.OrderBrokerApp.Test**。</span><span class="sxs-lookup"><span data-stu-id="9cef6-137">To avoid this situation, unenlist the test port (**HistoryInsert-Test-SP**), or stop the test version of the application, **BTSScn.BPM.OrderBrokerApp.Test**.</span></span> <span data-ttu-id="9cef6-138">有关送达通知的详细信息，请参阅[使用确认](../core/using-acknowledgments.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-138">For more information about delivery notifications, see [Using Acknowledgments](../core/using-acknowledgments.md).</span></span>  
  
 <span data-ttu-id="9cef6-139">构造要发送到的消息时**OrderManager**业务流程， **OrderBroker**业务流程包含两个部分创建多部分消息。</span><span class="sxs-lookup"><span data-stu-id="9cef6-139">When constructing the message to send to the **OrderManager** orchestration, the **OrderBroker** orchestration creates a multi-part message with two parts.</span></span> <span data-ttu-id="9cef6-140">一部分包含路由信息;另一个，本身的顺序。</span><span class="sxs-lookup"><span data-stu-id="9cef6-140">One part contains the routing information; the other, the order itself.</span></span> <span data-ttu-id="9cef6-141">该消息的路由部分**OrderMgrMsg.Routing**，使用的架构定义的C#类**SchemaClasses**程序集。</span><span class="sxs-lookup"><span data-stu-id="9cef6-141">The routing part of the message, **OrderMgrMsg.Routing**, uses a schema defined by a C# class in the **SchemaClasses** assembly.</span></span> <span data-ttu-id="9cef6-142">代理会将视为通用的消息的一部分或类型不明确的顺序、 XML 文档 (**System.Xml.XmlDocument**) 并将它分配给**OrderMgrMsg.Order**。</span><span class="sxs-lookup"><span data-stu-id="9cef6-142">The broker treats the order part of the message as a generic, or type-agnostic, XML document (**System.Xml.XmlDocument**) and assigns it to **OrderMgrMsg.Order**.</span></span>  
  
 <span data-ttu-id="9cef6-143">路由信息中尤其重要的订单管理器的两个字段 **: OrderMgrMsg.Routing.OrderMgrType**并**OrderMgrMsg.Routing.Status**。</span><span class="sxs-lookup"><span data-stu-id="9cef6-143">There are two fields in the routing information that are especially important to the order manager, **OrderMgrMsg.Routing.OrderMgrType** and **OrderMgrMsg.Routing.Status**.</span></span> <span data-ttu-id="9cef6-144">Broker 集**OrderMgrType**到是要处理订单的订单管理器的类型。</span><span class="sxs-lookup"><span data-stu-id="9cef6-144">The broker sets the **OrderMgrType** to the type of the order manager that is to handle the order.</span></span> <span data-ttu-id="9cef6-145">在解决方案中，只有一个订单管理器和字段设置为 CABLEORDER。</span><span class="sxs-lookup"><span data-stu-id="9cef6-145">In the solution, there is only one order manager and the field is set to CABLEORDER.</span></span> <span data-ttu-id="9cef6-146">Broker 还设置**状态**字段已接受。</span><span class="sxs-lookup"><span data-stu-id="9cef6-146">The broker also sets the **Status** field to ACCEPTED.</span></span> <span data-ttu-id="9cef6-147">这是告诉该消息为新订单的订单管理器的值。</span><span class="sxs-lookup"><span data-stu-id="9cef6-147">This is the value that tells the order manager the message is a new order.</span></span> <span data-ttu-id="9cef6-148">在解决方案中，订单管理器**OrderManager**业务流程，使用**接收**筛选等于 CABLEORDER 和等于 ACCEPTED 的状态的订单类型的形状。</span><span class="sxs-lookup"><span data-stu-id="9cef6-148">The order manager in the solution, **OrderManager** orchestration, uses a **Receive** shape that filters for the order type equal to CABLEORDER and status equal to ACCEPTED.</span></span>  
  
 <span data-ttu-id="9cef6-149">中的其余步骤**OrderBroker**业务流程将不同的消息发送到相应的端口。</span><span class="sxs-lookup"><span data-stu-id="9cef6-149">The remaining steps in the **OrderBroker** orchestration send the different messages to the appropriate ports.</span></span>  
  
## <a name="improving-performance-with-nested-scopes"></a><span data-ttu-id="9cef6-150">使用嵌套作用域提高性能</span><span class="sxs-lookup"><span data-stu-id="9cef6-150">Improving Performance with Nested Scopes</span></span>  
 <span data-ttu-id="9cef6-151">有关值得注意的地方之一**OrderBroker**业务流程是其使用的嵌套作用域。</span><span class="sxs-lookup"><span data-stu-id="9cef6-151">One of the noticeable things about the **OrderBroker** orchestration is its use of nested scopes.</span></span> <span data-ttu-id="9cef6-152">嵌套作用域有，部分，通过限制持久化点来提高性能。</span><span class="sxs-lookup"><span data-stu-id="9cef6-152">The nested scopes are there, in part, to improve performance by limiting the persistence points.</span></span>  
  
 <span data-ttu-id="9cef6-153">业务流程引擎定期保存整个业务流程在称为持久化点的执行点的状态。</span><span class="sxs-lookup"><span data-stu-id="9cef6-153">The orchestration engine periodically saves the state of the entire orchestration at execution points called persistence points.</span></span> <span data-ttu-id="9cef6-154">业务流程引擎自动将多个业务流程形状，包括**发送**形状视为持久化点。</span><span class="sxs-lookup"><span data-stu-id="9cef6-154">The orchestration engine automatically treats several orchestration shapes, including **Send** shapes, as persistence points.</span></span> <span data-ttu-id="9cef6-155">有关持久化点和相关的详细信息的列表，请参阅[持久化和业务流程引擎](../core/persistence-and-the-orchestration-engine.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-155">For a list of persistence points and more information about them, see [Persistence and the Orchestration Engine](../core/persistence-and-the-orchestration-engine.md).</span></span>  
  
 <span data-ttu-id="9cef6-156">具有五个**发送**形状**OrderBroker**该业务流程具有五个持久化点。</span><span class="sxs-lookup"><span data-stu-id="9cef6-156">With five **Send** shapes, the **OrderBroker** orchestration should have five persistence points.</span></span> <span data-ttu-id="9cef6-157">但是，分组**发送**原子事务作用域内的形状，则引擎将认为它只需要为作用域的一个持久化点。</span><span class="sxs-lookup"><span data-stu-id="9cef6-157">However, when you group **Send** shapes inside an atomic transaction scope, the engine recognizes it only needs one persistence point for the scope.</span></span> <span data-ttu-id="9cef6-158">因为这四个**发送**形状中**OrderBroker**业务流程不属于异常处理程序和无需完成在发送后，他们就可以访问在原子事务作用域中。</span><span class="sxs-lookup"><span data-stu-id="9cef6-158">Because four of the **Send** shapes in **OrderBroker** orchestration are not part of exception handlers and nothing needs to be done after the send, they can go in an atomic transaction scope.</span></span> <span data-ttu-id="9cef6-159">这样可以减少持久化点。</span><span class="sxs-lookup"><span data-stu-id="9cef6-159">This reduces the number of persistence points.</span></span> <span data-ttu-id="9cef6-160">有关原子事务的详细信息，请参阅[原子事务](../core/atomic-transactions.md)。</span><span class="sxs-lookup"><span data-stu-id="9cef6-160">For more information about atomic transactions, see [Atomic Transactions](../core/atomic-transactions.md).</span></span>  
  
 <span data-ttu-id="9cef6-161">此外，业务流程引擎将如果在同一时间结束所有事务的嵌套事务中使用单个持久化点。</span><span class="sxs-lookup"><span data-stu-id="9cef6-161">In addition, the orchestration engine will use a single persistence point for nested transactions if the transactions all end at the same time.</span></span> <span data-ttu-id="9cef6-162">因此，方式**OrderBroker**业务流程嵌套事务进一步减少暂留点： 业务流程只具有一个持久化点由于使用了**作用域**形状。</span><span class="sxs-lookup"><span data-stu-id="9cef6-162">Thus, the way **OrderBroker** orchestration nests transactions further reduces the persistence points: the orchestration has a single persistence point due to the use of **Scope** shapes.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cef6-163">可以通过尽量减少的业务流程中的持久化点来提高性能。</span><span class="sxs-lookup"><span data-stu-id="9cef6-163">You can improve performance by minimizing the number of persistence points in an orchestration.</span></span> <span data-ttu-id="9cef6-164">可以对其进行分组**发送**形状中的原子事务，以生成单个持久化点的所有**发送**形状。</span><span class="sxs-lookup"><span data-stu-id="9cef6-164">You can group **Send** shapes in an atomic transaction to produce a single persistence point for all of the **Send** shapes.</span></span> <span data-ttu-id="9cef6-165">结束嵌套的事务的范围限定在同一时间会生成单个持久化点的事务。</span><span class="sxs-lookup"><span data-stu-id="9cef6-165">Ending nested transaction scopes at the same time produces a single persistence point for the transactions.</span></span>  
  
 <span data-ttu-id="9cef6-166">原子事务作用域不能具有异常处理程序。</span><span class="sxs-lookup"><span data-stu-id="9cef6-166">An atomic transaction scope cannot have an exception handler.</span></span> <span data-ttu-id="9cef6-167">因此，业务流程将嵌套在长时间运行事务的原子作用域。</span><span class="sxs-lookup"><span data-stu-id="9cef6-167">Because of this, the orchestration nests the atomic scope inside a long running transaction.</span></span> <span data-ttu-id="9cef6-168">此外部事务可以具有异常处理程序，并且该处理程序处理的异常**发送**形状。</span><span class="sxs-lookup"><span data-stu-id="9cef6-168">This outer transaction can have an exception handler and it is this handler that processes an exception from the **Send** shapes.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="9cef6-169">原子事务嵌套在长时间运行事务内是一种常见的模式，以允许进行异常处理。</span><span class="sxs-lookup"><span data-stu-id="9cef6-169">Nesting an atomic transaction inside a long running transaction is a common pattern to allow for exception handling.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9cef6-170">请参阅</span><span class="sxs-lookup"><span data-stu-id="9cef6-170">See Also</span></span>  
 <span data-ttu-id="9cef6-171">[在业务流程管理解决方案中处理](../core/processing-in-the-business-process-management-solution.md) </span><span class="sxs-lookup"><span data-stu-id="9cef6-171">[Processing in the Business Process Management Solution](../core/processing-in-the-business-process-management-solution.md) </span></span>  
 <span data-ttu-id="9cef6-172">[进程管理器逻辑](../core/process-manager-logic.md) </span><span class="sxs-lookup"><span data-stu-id="9cef6-172">[Process Manager Logic](../core/process-manager-logic.md) </span></span>  
 <span data-ttu-id="9cef6-173">[业务流程管理解决方案中的中断处理](../core/interrupt-handling-in-the-business-process-management-solution.md) </span><span class="sxs-lookup"><span data-stu-id="9cef6-173">[Interrupt Handling in the Business Process Management Solution](../core/interrupt-handling-in-the-business-process-management-solution.md) </span></span>  
 [<span data-ttu-id="9cef6-174">ExceptionHandler 业务流程</span><span class="sxs-lookup"><span data-stu-id="9cef6-174">The ExceptionHandler Orchestration</span></span>](../core/the-exceptionhandler-orchestration.md)