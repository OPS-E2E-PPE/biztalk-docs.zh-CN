---
title: "如何部署 BizTalk Server 中的程序集 |Microsoft 文档"
description: "将程序集部署到 GAC 中，并启用 BizTalk Server 中的程序集的版本控制"
ms.custom: 
ms.date: 01/21/2016
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: c7f99ed5-b64a-4a38-99d7-83070fb69030
caps.latest.revision: "13"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 339d0bba76c26186fe8356145207462e7ce25ed7
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="biztalk-assemblies"></a><span data-ttu-id="1ba84-103">BizTalk 程序集</span><span class="sxs-lookup"><span data-stu-id="1ba84-103">BizTalk Assemblies</span></span>
<span data-ttu-id="1ba84-104">Microsoft BizTalk Server 和 .NET Framework 最重要的一个方面是：所有 BizTalk Server 项目（映射、架构、业务流程和管道）都已编译到 .NET 程序集中。</span><span class="sxs-lookup"><span data-stu-id="1ba84-104">The most important aspect of Microsoft BizTalk Server and the .NET Framework is that all BizTalk Server artifacts; maps, schemas, orchestrations, and pipelines, get compiled into .NET assemblies.</span></span> <span data-ttu-id="1ba84-105">此设计的两个最重要含义是：这些程序集必须具有强名称，为此它们还需遵守 .NET 版本控制规则。</span><span class="sxs-lookup"><span data-stu-id="1ba84-105">The two most important implications of this design are that these assemblies must have strong names, and because of that, they also follow .NET versioning rules.</span></span> <span data-ttu-id="1ba84-106">其主要含义是：根据特定版本的其他 .NET 项目或程序集（包括 BizTalk 项目）生成 BizTalk 项目后，该 BizTalk 项目将继续使用该版本，直到根据更高的版本重新生成该 BizTalk 项目。</span><span class="sxs-lookup"><span data-stu-id="1ba84-106">The main implication of this is that a BizTalk project, once built against a particular version of another .NET project or assembly (including BizTalk projects), continues to use that version until it has been rebuilt against a newer version.</span></span>  
  
## <a name="net-versioning-and-assemblies"></a><span data-ttu-id="1ba84-107">.NET 版本控制和程序集</span><span class="sxs-lookup"><span data-stu-id="1ba84-107">.NET Versioning and Assemblies</span></span>  
 <span data-ttu-id="1ba84-108">如果在没有停止和启动加载类型的 BizTalk 主机实例的情况下，没有更改 BizTalk 项目上的版本号而重新部署了程序集，则在进行与 .NET 版本控制有关的开发过程中会出现一个常见问题。</span><span class="sxs-lookup"><span data-stu-id="1ba84-108">A common problem occurs during development related to .NET versioning when the version numbers on a BizTalk project are not changed and the assembly is redeployed without stopping and starting the BizTalk host instance that the types are loaded into.</span></span>  
  
 <span data-ttu-id="1ba84-109">再次运行该进程时，更改不会生效。</span><span class="sxs-lookup"><span data-stu-id="1ba84-109">When the process is run again, the changes do not take effect.</span></span> <span data-ttu-id="1ba84-110">这是由 .NET 程序集加载到内存中的方式造成的。</span><span class="sxs-lookup"><span data-stu-id="1ba84-110">This is due to the way in which .NET assemblies are loaded into memory.</span></span> <span data-ttu-id="1ba84-111">因为主机已经具有该程序集的内存中副本，所以在将新的副本放入全局程序集缓存中时，不会重新加载该程序集。</span><span class="sxs-lookup"><span data-stu-id="1ba84-111">Because the host already has an in-memory copy of the assembly, it does not reload the assembly when a new copy is put into the Global Assembly Cache.</span></span> <span data-ttu-id="1ba84-112">例如，部署并运行带有业务流程的版本 1.0.0.0 的程序集，如果对业务流程进行了更改而未更改版本号，则这些更改不会生效。</span><span class="sxs-lookup"><span data-stu-id="1ba84-112">For example, if version 1.0.0.0 of an assembly with an orchestration is deployed and running, and changes are made to the orchestration but the version number is not changed, then the changes do not take effect.</span></span> <span data-ttu-id="1ba84-113">停止主机实例后将释放该程序集的内存中副本，重新启动该主机实例时，将重新加载该程序集的新副本并获取更改。</span><span class="sxs-lookup"><span data-stu-id="1ba84-113">After the host instance is stopped, the in-memory copy of the assembly is released and when the host instance starts again it reloads the new copy of the assembly and gets the changes.</span></span> <span data-ttu-id="1ba84-114">如果部署并加载了新的版本（例如版本 2.0.0.0），则更改生效。</span><span class="sxs-lookup"><span data-stu-id="1ba84-114">If a new version was deployed, say version 2.0.0.0, and it was loaded, then the changes would have taken effect.</span></span>  
  
 <span data-ttu-id="1ba84-115">将程序集部署到 BizTalk Server 的过程分两个部分。</span><span class="sxs-lookup"><span data-stu-id="1ba84-115">Deploying assemblies to BizTalk Server is a two part process.</span></span> <span data-ttu-id="1ba84-116">第一部分是传统的 .NET 程序集部署，即在每个将使用强名称程序集的服务器上将该程序集部署到全局程序集缓存 (GAC)。</span><span class="sxs-lookup"><span data-stu-id="1ba84-116">The first part is traditional .NET assembly deployment in which the strong-named assembly is deployed to the Global Assembly Cache (GAC) on each server where the assembly will be used.</span></span> <span data-ttu-id="1ba84-117">第二步是将有关这些程序集及其类型的元数据部署到 BizTalk Server 管理数据库。</span><span class="sxs-lookup"><span data-stu-id="1ba84-117">The second step is to deploy metadata about the assemblies and their types to the BizTalk Server Management database.</span></span> <span data-ttu-id="1ba84-118">BizTalk Server 加载 BizTalk Server 程序集时，通常使用这些程序集的强名称（可在管理数据库中找到）进行加载。</span><span class="sxs-lookup"><span data-stu-id="1ba84-118">When BizTalk Server assemblies are loaded by BizTalk Server, they are most often loaded using their strong name, found in the Management database.</span></span>  
  
## <a name="deploying-biztalk-server-assemblies-to-the-gac"></a><span data-ttu-id="1ba84-119">将 BizTalk Server 程序集部署到 GAC</span><span class="sxs-lookup"><span data-stu-id="1ba84-119">Deploying BizTalk Server Assemblies to the GAC</span></span>  
 <span data-ttu-id="1ba84-120">开发人员创建的 BizTalk Server 项目将编译为从内置 BizTalk Server 类型派生的类。</span><span class="sxs-lookup"><span data-stu-id="1ba84-120">The BizTalk Server artifacts that a developer creates get compiled into classes which derive from built in BizTalk Server types.</span></span> <span data-ttu-id="1ba84-121">例如，业务流程编译为从 Microsoft.BizTalkXLANGs.BTXEngine.BTXService 类派生的类。</span><span class="sxs-lookup"><span data-stu-id="1ba84-121">For example, an orchestration becomes a class which derives from the Microsoft.BizTalkXLANGs.BTXEngine.BTXService class.</span></span> <span data-ttu-id="1ba84-122">由于这些基类部署到全局程序集缓存的程序集中，并且这些程序集对 GAC 中的其他程序集具有依存关系，因此还必须将开发人员的程序集部署到 GAC。</span><span class="sxs-lookup"><span data-stu-id="1ba84-122">It is because these base classes are deployed in assemblies to the Global Assembly Cache, and these assemblies have dependencies on other assemblies in the GAC, that a developer's assemblies must also get deployed to the GAC.</span></span>  
  
 <span data-ttu-id="1ba84-123">要部署到全局程序集缓存并因此要具有强名称的 BizTalk Server 项目的另一个重要含义是：强名称程序集不能调用还未具有强名称的程序集。</span><span class="sxs-lookup"><span data-stu-id="1ba84-123">Another important implication of BizTalk Server artifacts being deployed to the Global Assembly Cache and therefore being strong named, is that strong named assemblies cannot call other assemblies that are not also strong named.</span></span> <span data-ttu-id="1ba84-124">这意味着开发人员创建且由这些 BizTalk Server 程序集使用的任何程序集也必须具有强名称。</span><span class="sxs-lookup"><span data-stu-id="1ba84-124">This means that any assemblies a developer creates that are used by these BizTalk Server assemblies must also be strong named.</span></span> <span data-ttu-id="1ba84-125">同样，如果部署到 GAC 的程序集不使用特定路径加载其他程序集，则必须从 GAC 加载这些程序集。</span><span class="sxs-lookup"><span data-stu-id="1ba84-125">Likewise, assemblies deployed to the GAC that load other assemblies without using a specific path, must load those assemblies from the GAC.</span></span>  
  
 <span data-ttu-id="1ba84-126">管道组件将被添加到开发人员的工具箱中[!INCLUDE[btsVStudioNoVersion](../includes/btsvstudionoversion-md.md)]以使它们可用拖动到管道设计器上。</span><span class="sxs-lookup"><span data-stu-id="1ba84-126">Pipeline components are added to a developer's toolbox in [!INCLUDE[btsVStudioNoVersion](../includes/btsvstudionoversion-md.md)] to make them available to be dragged onto the pipeline designer.</span></span> <span data-ttu-id="1ba84-127">将 BizTalk Server 管道编译为 .NET 程序集时，有关该管道各个阶段中的所有组件的信息将被编译到该程序集中。</span><span class="sxs-lookup"><span data-stu-id="1ba84-127">When a BizTalk Server pipeline is compiled into a .NET assembly, the information about all of the components in the various stages of the pipeline get compiled into the assembly.</span></span> <span data-ttu-id="1ba84-128">此管道部署到 BizTalk Server，组件，包括各自的文件名称，有关的信息插入到 BizTalk 管理数据库和管道程序集部署到 GAC。</span><span class="sxs-lookup"><span data-stu-id="1ba84-128">When this pipeline is deployed to BizTalk Server, the information about the components, including their file name, is inserted into the BizTalk Management database and the pipeline assembly is deployed into the GAC.</span></span> <span data-ttu-id="1ba84-129">取决于 BizTalk 管道组件的任何其他程序集必须还将部署到 GAC 以便在运行时找到。</span><span class="sxs-lookup"><span data-stu-id="1ba84-129">Any additional assemblies that BizTalk pipeline components depend upon must also be deployed to the GAC in order to be found at runtime.</span></span> <span data-ttu-id="1ba84-130">此外必须将管道组件程序集复制到[!INCLUDE[btsBizTalkServer2006r3](../includes/btsbiztalkserver2006r3-md.md)]\Pipeline 组件的目录，可以在运行时的 BizTalk 管道访问。</span><span class="sxs-lookup"><span data-stu-id="1ba84-130">Pipeline component assemblies must also be copied to the [!INCLUDE[btsBizTalkServer2006r3](../includes/btsbiztalkserver2006r3-md.md)]\Pipeline Components directory to be accessible by a BizTalk pipeline at runtime.</span></span> <span data-ttu-id="1ba84-131">执行该管道时，将加载这些组件，并根据需要调用它们实现的接口。</span><span class="sxs-lookup"><span data-stu-id="1ba84-131">When the pipeline is executed, these components are loaded, and the interfaces they implement called as appropriate.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1ba84-132">另请参阅</span><span class="sxs-lookup"><span data-stu-id="1ba84-132">See Also</span></span>  
 [<span data-ttu-id="1ba84-133">运行时体系结构</span><span class="sxs-lookup"><span data-stu-id="1ba84-133">Runtime Architecture</span></span>](../core/runtime-architecture.md)