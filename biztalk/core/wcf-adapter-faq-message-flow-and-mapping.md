---
title: WCF 适配器常见问题解答：消息流和映射 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 907e5c6a-a095-4b3a-9362-506832b6bc8c
caps.latest.revision: 4
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 5d80e16fc03ea7ed60f68cbacc9fb4f24b395b9e
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65393577"
---
# <a name="wcf-adapter-faq-message-flow-and-mapping"></a><span data-ttu-id="f880c-102">WCF 适配器常见问题解答：消息流和映射</span><span class="sxs-lookup"><span data-stu-id="f880c-102">WCF Adapter FAQ: Message Flow and Mapping</span></span>
## <a name="what-is-the-message-flow-within-the-wcf-and-biztalk-systems"></a><span data-ttu-id="f880c-103">WCF 和 BizTalk 系统中的消息流是什么？</span><span class="sxs-lookup"><span data-stu-id="f880c-103">What is the message flow within the WCF and BizTalk systems?</span></span>  
 <span data-ttu-id="f880c-104">下面是向 BizTalk Server 将传入 WCF 消息流的说明：</span><span class="sxs-lookup"><span data-stu-id="f880c-104">Here is a description of the flow of an incoming WCF message to BizTalk Server:</span></span>  
  
1. <span data-ttu-id="f880c-105">WCF 消息到达接收位置，然后 BizTalk Server 实例化承载的 WCF 服务。</span><span class="sxs-lookup"><span data-stu-id="f880c-105">A WCF message arrives at a receive location, and BizTalk Server instantiates a hosted WCF service.</span></span>  
  
2. <span data-ttu-id="f880c-106">WCF 运行时实例化服务的通道堆栈和其通道侦听器。</span><span class="sxs-lookup"><span data-stu-id="f880c-106">The WCF runtime instantiates the service’s channel stack and its channel listeners.</span></span> <span data-ttu-id="f880c-107">通道堆栈是一系列处理不同处理任务的阶段。</span><span class="sxs-lookup"><span data-stu-id="f880c-107">A channel stack is a sequence of stages that handle differing processing tasks.</span></span> <span data-ttu-id="f880c-108">每个通道堆栈由至少一个传输通道、 最常消息编码器和零个或多个协议通道组成。</span><span class="sxs-lookup"><span data-stu-id="f880c-108">Each channel stack consists of at least a transport channel, most often a message encoder, and zero or more protocol channels.</span></span> <span data-ttu-id="f880c-109">传输通道读取到达的传入消息流。</span><span class="sxs-lookup"><span data-stu-id="f880c-109">The transport channel reads the incoming message stream upon arrival.</span></span> <span data-ttu-id="f880c-110">它调用编码器来解释该消息并生成 WCF 消息对象。</span><span class="sxs-lookup"><span data-stu-id="f880c-110">It invokes an encoder to interpret the message and to produce a WCF Message object.</span></span> <span data-ttu-id="f880c-111">现在每个协议通道将有机会对 WCF 消息按顺序进行操作。</span><span class="sxs-lookup"><span data-stu-id="f880c-111">At this point each protocol channel will have an opportunity to operate on the WCF message in order.</span></span>  
  
3. <span data-ttu-id="f880c-112">通过将其转发通过已配置的 WCF 通道堆栈并将其调度到相应的服务实例的侦听器接收 WCF 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-112">The WCF message is received by a listener that forwards it through the configured WCF channel stack and dispatches it to the proper service instance.</span></span> <span data-ttu-id="f880c-113">此时在 WCF 消息转换 （映射） 为 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-113">At this point the WCF message is converted (mapped) to a BizTalk message.</span></span> <span data-ttu-id="f880c-114">简而言之，WCF 消息标头被写入 BizTalk 消息上下文，WCF 消息正文被写入 BizTalk 消息正文部分。</span><span class="sxs-lookup"><span data-stu-id="f880c-114">Briefly stated, the WCF message headers are written into the BizTalk message context, and the WCF message body is written into the  BizTalk message body part.</span></span> <span data-ttu-id="f880c-115">映射控制 WCF 消息的哪个部分变为 BizTalk 消息正文：信封、 正文或子元素。</span><span class="sxs-lookup"><span data-stu-id="f880c-115">Mapping controls what part of the WCF message becomes the BizTalk message body: Envelope, body, or sub-element.</span></span>  
  
4. <span data-ttu-id="f880c-116">配置接收位置中的任何管道组件处理 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-116">Any pipeline components configured in the receive location processes the BizTalk message.</span></span>  
  
5. <span data-ttu-id="f880c-117">BizTalk 消息存储在 MessageBox 数据库。</span><span class="sxs-lookup"><span data-stu-id="f880c-117">The BizTalk message is stored in the MessageBox database.</span></span>  
  
   <span data-ttu-id="f880c-118">下面是来自 BizTalk Server 的传出 WCF 消息流的说明：</span><span class="sxs-lookup"><span data-stu-id="f880c-118">Here is a description of the flow of an outgoing WCF message from BizTalk Server:</span></span>  
  
6. <span data-ttu-id="f880c-119">通过发送端口根据其订阅接收 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-119">A BizTalk message is received by a send port according to its subscription.</span></span>  
  
7. <span data-ttu-id="f880c-120">任何管道组件在发送端口过程中配置 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-120">Any pipeline components configured in the send port process the BizTalk message.</span></span>  
  
8. <span data-ttu-id="f880c-121">实例化 WCF 通道堆栈时，，BizTalk 消息转换 （映射） 到基于服务的外部可见协议的 WCF 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-121">A WCF channel stack is instantiated, and the BizTalk message is converted (mapped) into a WCF message based upon the service’s external visible contract.</span></span>  
  
9. <span data-ttu-id="f880c-122">WCF 通道堆栈将传输到外部 WCF 服务的 WCF 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-122">The WCF channel stack transmits the WCF message to the external WCF service.</span></span>  
  
## <a name="how-is-a-wcf-message-converted-mapped-into-a-biztalk-message"></a><span data-ttu-id="f880c-123">如何为 WCF 消息转换 （映射） 为 BizTalk 消息？</span><span class="sxs-lookup"><span data-stu-id="f880c-123">How is a WCF message converted (mapped) into a BizTalk message?</span></span>  
 <span data-ttu-id="f880c-124">为了了解该映射，我们需要查看 WCF 消息和 BizTalk 消息的结构。</span><span class="sxs-lookup"><span data-stu-id="f880c-124">In order to understand the mapping, we need to look at the structure of a WCF message and a BizTalk message.</span></span>  
  
 <span data-ttu-id="f880c-125">WCF 消息所依据的 SOAP 消息结构和消息属性、 消息标头和一个消息正文组成。</span><span class="sxs-lookup"><span data-stu-id="f880c-125">A WCF message is modeled on the SOAP message structure and consists of message properties, message headers, and a single message body.</span></span>  
  
- <span data-ttu-id="f880c-126">**消息属性**是附加到消息对象的公共语言运行时 (CLR) 对象。</span><span class="sxs-lookup"><span data-stu-id="f880c-126">The **message properties** are Common Language Runtime (CLR) objects that are attached to the Message object.</span></span> <span data-ttu-id="f880c-127">属性是 WCF 堆栈和通信的每个最终用户的应用程序的内部。</span><span class="sxs-lookup"><span data-stu-id="f880c-127">Properties are internal to the WCF stack and the user’s application at each end of the communication.</span></span> <span data-ttu-id="f880c-128">它们从不直接客户端和服务器之间的传输。</span><span class="sxs-lookup"><span data-stu-id="f880c-128">They are never directly transferred between client and server.</span></span>  
  
- <span data-ttu-id="f880c-129">**消息标头**，但是，客户端和服务器之间进行传输。</span><span class="sxs-lookup"><span data-stu-id="f880c-129">**Message headers**, however, are transferred between client and server.</span></span> <span data-ttu-id="f880c-130">上一条消息，可以有许多标头，但只有一个消息正文，并且标头与消息正文进行流处理。</span><span class="sxs-lookup"><span data-stu-id="f880c-130">There can be many headers on a message, but there is only one message body, and unlike the headers the message body is streamed.</span></span> <span data-ttu-id="f880c-131">消息标头和消息正文被定义为 XML Infoset。</span><span class="sxs-lookup"><span data-stu-id="f880c-131">Both the message headers and the message body are defined as an XML Infoset.</span></span>  
  
- <span data-ttu-id="f880c-132">**正文**的 WCF 消息是为其属性和标头提供的详细信息的消息的主要内容。</span><span class="sxs-lookup"><span data-stu-id="f880c-132">The **body** of a WCF message is the main content of the message for which the properties and headers provide more information.</span></span>  
  
  <span data-ttu-id="f880c-133">BizTalk 消息具有不同的结构。</span><span class="sxs-lookup"><span data-stu-id="f880c-133">A BizTalk message has a different structure.</span></span>  
  
- <span data-ttu-id="f880c-134">没有一组每个消息的上下文属性。</span><span class="sxs-lookup"><span data-stu-id="f880c-134">There is a single set of context properties on each message.</span></span> <span data-ttu-id="f880c-135">每个上下文属性包含的命名空间名称/值对。</span><span class="sxs-lookup"><span data-stu-id="f880c-135">Each context property consists of a namespace name/value pair.</span></span> <span data-ttu-id="f880c-136">可以升级或写入上下文属性。</span><span class="sxs-lookup"><span data-stu-id="f880c-136">Context properties can be either promoted or written.</span></span> <span data-ttu-id="f880c-137">如果对它们进行升级，它们可以参与 BizTalk Server 中执行的路由规则。</span><span class="sxs-lookup"><span data-stu-id="f880c-137">If they are promoted, they can take part in the routing rules that execute within BizTalk Server.</span></span>  
  
- <span data-ttu-id="f880c-138">在 BizTalk Server 中消息的数据可以包含多个流。</span><span class="sxs-lookup"><span data-stu-id="f880c-138">The data of a message in BizTalk Server can consist of multiple streams.</span></span> <span data-ttu-id="f880c-139">因为可以单独读取每个流，是多部分 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-139">A BizTalk message is multipart because each stream can be read independently.</span></span> <span data-ttu-id="f880c-140">一个消息部分比较特殊，它被称为正文部分。</span><span class="sxs-lookup"><span data-stu-id="f880c-140">One of the message parts is special and it is referred to as the body part.</span></span>  
  
  <span data-ttu-id="f880c-141">因为通信有时是双向的 WCF 适配器允许为特定的转换或映射，以配置有关的消息交换的入站和出站方向。</span><span class="sxs-lookup"><span data-stu-id="f880c-141">Because the communication can sometimes be two-way, the WCF adapter allows the particular translation or mapping to be configured for both inbound and outbound directions of message exchange.</span></span> <span data-ttu-id="f880c-142">这可以为接收位置和 BizTalk Server 中的发送端口。</span><span class="sxs-lookup"><span data-stu-id="f880c-142">This can be done for both the receive locations and send ports within BizTalk Server.</span></span>  
  
  <span data-ttu-id="f880c-143">BizTalk WCF 适配器支持在运行时这些两个消息结构之间转换的排列数。</span><span class="sxs-lookup"><span data-stu-id="f880c-143">The BizTalk WCF adapters support a number of permutations of translating at run time between these two message structures.</span></span> <span data-ttu-id="f880c-144">通过控制映射**消息**选项卡**传输属性**个 WCF 适配器的对话框。</span><span class="sxs-lookup"><span data-stu-id="f880c-144">Mapping is controlled through the **Messages** tab in the **Transport Properties** dialog box for a WCF adapter.</span></span> <span data-ttu-id="f880c-145">例如，最明显转换和默认情况下，为入站 WCF 消息的正文变为 BizTalk 消息的正文时。</span><span class="sxs-lookup"><span data-stu-id="f880c-145">For example, the most obvious translation, and the default, is when the body of an inbound WCF message becomes the body of the BizTalk message.</span></span> <span data-ttu-id="f880c-146">有关映射模式的详细信息，请参阅[ http://go.microsoft.com/fwlink/?LinkID=119792 ](http://go.microsoft.com/fwlink/?LinkID=119792)。</span><span class="sxs-lookup"><span data-stu-id="f880c-146">For more information about mapping modes, see [http://go.microsoft.com/fwlink/?LinkID=119792](http://go.microsoft.com/fwlink/?LinkID=119792).</span></span>  
  
## <a name="how-can-you-preserve-the-complete-incoming-wcf-message-inside-the-biztalk-message"></a><span data-ttu-id="f880c-147">可以保留的 BizTalk 消息内完成的传入 WCF 消息的方式？</span><span class="sxs-lookup"><span data-stu-id="f880c-147">How can you preserve the complete incoming WCF message inside the BizTalk message?</span></span>  
 <span data-ttu-id="f880c-148">入站 BizTalk 消息正文选项之一是**信封**选项。</span><span class="sxs-lookup"><span data-stu-id="f880c-148">One of the inbound BizTalk message body options is the **Envelope** option.</span></span> <span data-ttu-id="f880c-149">选择此选项将整个 soap: Envelope 元素中包含到传入 BizTalk 消息正文的 SOAP 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-149">Choosing this option takes the entire SOAP message contained within the soap:Envelope element into the incoming BizTalk message body.</span></span> <span data-ttu-id="f880c-150">生成的 BizTalk 消息包含信封标记、 所有标头和正文。</span><span class="sxs-lookup"><span data-stu-id="f880c-150">The resulting BizTalk message contains the Envelope tags, all the headers, and the body.</span></span>  
  
## <a name="how-can-you-extract-specific-elements-of-the-incoming-wcf-message-into-a-biztalk-message-or-map-elements-of-an-outgoing-biztalk-message-to-an-outgoing-wcf-message"></a><span data-ttu-id="f880c-151">您如何将传入 WCF 消息的特定元素提取到 BizTalk 消息，或将传出 BizTalk 消息的元素映射到传出 WCF 消息？</span><span class="sxs-lookup"><span data-stu-id="f880c-151">How can you extract specific elements of the incoming WCF message into a BizTalk message, or map elements of an outgoing BizTalk message to an outgoing WCF message?</span></span>  
 <span data-ttu-id="f880c-152">若要映射 WCF 或 BizTalk 消息正文部分，使用路径或模板选项。</span><span class="sxs-lookup"><span data-stu-id="f880c-152">To map a section of a WCF or BizTalk message body, use the Path or Template option.</span></span> <span data-ttu-id="f880c-153">这允许您输入的 XPath 表达式提取消息正文的特定部分。</span><span class="sxs-lookup"><span data-stu-id="f880c-153">This allows you to enter an XPath expression to extract specific parts of the message body.</span></span> <span data-ttu-id="f880c-154">在此情况下不支持完整的 XPath 语法，因为提取流式传输和读取器必须因此始终向前读取。</span><span class="sxs-lookup"><span data-stu-id="f880c-154">Full XPath syntax is not supported in this situation as the extraction is streamed and the reader must therefore always walk forward.</span></span> <span data-ttu-id="f880c-155">这就是在为什么**消息**它称为"路径-按正文路径定位内容"而不是"XPath – 按正文路径定位内容。"选项卡</span><span class="sxs-lookup"><span data-stu-id="f880c-155">This is why in the **Messages** tab it is called “Path – content located by body path” instead of “XPath – content located by body path.”</span></span>  
  
 <span data-ttu-id="f880c-156">在接收端，使用路径表达式，用于指示从 WCF 消息中读取数据的方式。</span><span class="sxs-lookup"><span data-stu-id="f880c-156">On the receive side, use a Path expression that dictates how data is to be read from the WCF message.</span></span> <span data-ttu-id="f880c-157">对于入站消息，Path 语句提取的特定元素将替换 BizTalk 消息的内容。</span><span class="sxs-lookup"><span data-stu-id="f880c-157">For an inbound message, the specific element extracted by the Path statement gets substituted for the content of the BizTalk message.</span></span> <span data-ttu-id="f880c-158">适配器使用此路径表达式来查找和提取 BizTalk 消息的所需的数据。</span><span class="sxs-lookup"><span data-stu-id="f880c-158">The adapter uses this Path expression to locate and extract the desired data for the BizTalk message.</span></span>  
  
 <span data-ttu-id="f880c-159">在发送端，使用模板从 BizTalk 消息创建 WCF 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-159">On the send side, use a template to create a WCF message from the BizTalk message.</span></span> <span data-ttu-id="f880c-160">出站消息的模板选项旨在允许 XPath 选项反向。</span><span class="sxs-lookup"><span data-stu-id="f880c-160">The template option for outbound messages is designed to allow the exact opposite of the XPath option.</span></span> <span data-ttu-id="f880c-161">在 WCF 适配器配置中，XML 代码段用作的出站消息的结构的基础。</span><span class="sxs-lookup"><span data-stu-id="f880c-161">In the WCF adapter configuration, the snippet of XML is used as the basis for the structure of the outbound message.</span></span> <span data-ttu-id="f880c-162">BizTalk 消息的内容将在运行时插入到此结构。</span><span class="sxs-lookup"><span data-stu-id="f880c-162">The content of the BizTalk message is inserted at run time into this structure.</span></span>  
  
 <span data-ttu-id="f880c-163">为传出消息，还必须选择使用 XML、 Base64、 字符串或十六进制中的节点编码设置编写的元素的类型。</span><span class="sxs-lookup"><span data-stu-id="f880c-163">For an outgoing message, you must also choose the type of the element written by using the Node Encoding setting from XML, Base64, String, or Hexadecimal.</span></span> <span data-ttu-id="f880c-164">您希望提取 WCF 消息中包含的二进制数据流时，此选项会非常有用。</span><span class="sxs-lookup"><span data-stu-id="f880c-164">This option is very useful when you want to extract a binary data stream contained in a WCF message.</span></span> <span data-ttu-id="f880c-165">使用此功能可指示 WCF 适配器使用 WCF 消息的正文读取器调用 ReadContextAsBase64。</span><span class="sxs-lookup"><span data-stu-id="f880c-165">Using this feature instructs the WCF Adapter to use the ReadContextAsBase64 calls on the body Reader of the WCF Message.</span></span> <span data-ttu-id="f880c-166">此调用允许直接通过 XmlReader API 读取，因此使用此功能，二进制数据可以直接从移动 WCF 传输到 BizTalk MessageBox 数据库中二进制数据。</span><span class="sxs-lookup"><span data-stu-id="f880c-166">This call allows binary data to be read directly through the XmlReader API, so using this feature binary data can be moved directly from the WCF Transport into the BizTalk MessageBox database.</span></span> <span data-ttu-id="f880c-167">通过写入含有二进制数据的节点路径可以拉出，并将其放入 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-167">By writing a path to the node containing the binary data you can pull it out and place it into the BizTalk message.</span></span>  
  
## <a name="how-do-you-access-wcf-message-properties-within-an-incoming-wcf-message"></a><span data-ttu-id="f880c-168">如何访问传入 WCF 消息中的 WCF 消息属性？</span><span class="sxs-lookup"><span data-stu-id="f880c-168">How do you access WCF message properties within an incoming WCF message?</span></span>  
 <span data-ttu-id="f880c-169">若要转换为 BizTalk 消息之前，请访问传入 WCF 消息中的属性，可以使用自定义的 WCF 通道组件或服务模型结合使用 WCF 行为扩展点。</span><span class="sxs-lookup"><span data-stu-id="f880c-169">To access properties within an incoming WCF message before it is transformed into a BizTalk message, you can use a custom WCF channel component or a service model extensibility point with a WCF behavior.</span></span> <span data-ttu-id="f880c-170">例如， **IDispatchMessageInspector**对象。</span><span class="sxs-lookup"><span data-stu-id="f880c-170">For example, an **IDispatchMessageInspector** object.</span></span> <span data-ttu-id="f880c-171">BizTalk Wcf-custom 和 Wcf-customisolated 适配器提供了使你的应用程序可插入到使用 WCF 行为的强大功能轻松地**行为**选项卡**传输属性**对话框这些适配器。</span><span class="sxs-lookup"><span data-stu-id="f880c-171">The BizTalk WCF-Custom and WCF-CustomIsolated adapters provide a simple way for your application to plug into the power of WCF behaviors using the **Behavior** tab in the **Transport Properties** dialog for those adapters.</span></span>  
  
 <span data-ttu-id="f880c-172">若要允许 WCF 消息是可用于 WCF 适配器的属性，这些属性首先需要向其中写入消息正文或标头，因为内容。</span><span class="sxs-lookup"><span data-stu-id="f880c-172">To allow the properties of a WCF message to be available to the WCF adapter, those properties first have to be written into the message body or header as content.</span></span> <span data-ttu-id="f880c-173">标头复制到 BizTalk 消息上下文自动为您。</span><span class="sxs-lookup"><span data-stu-id="f880c-173">The headers are copied into the BizTalk message context automatically for you.</span></span> <span data-ttu-id="f880c-174">如果你想升级属性值，可用于自定义 BizTalk 管道组件中将 WCF 消息属性升级到 BizTalk 消息上下文**IComponent： 执行**方法。</span><span class="sxs-lookup"><span data-stu-id="f880c-174">If you want a property value promoted, you can use a custom BizTalk pipeline component to promote the WCF message property into the BizTalk message context from within the **IComponent:Execute** method.</span></span> <span data-ttu-id="f880c-175">WCF 自定义适配器中使用自定义 WCF 行为，可充分利用 WCF 和 BizTalk 的扩展性让您的解决方案，更为强大和灵活。</span><span class="sxs-lookup"><span data-stu-id="f880c-175">Using custom WCF behaviors with the WCF custom adapters allows you to take advantage of both WCF and BizTalk extensibility to make your solution more powerful and flexible.</span></span> <span data-ttu-id="f880c-176">WCF 适配器可以合并现有的 BizTalk 和 WCF 扩展性来解决你的问题。</span><span class="sxs-lookup"><span data-stu-id="f880c-176">The WCF adapter allows you to combine existing BizTalk and WCF extensibilities to solve your problem.</span></span>  
  
 <span data-ttu-id="f880c-177">好消息是这种情况下公共属性，WCF 适配器中是一种快捷方式。</span><span class="sxs-lookup"><span data-stu-id="f880c-177">The good news is that there is a shortcut in the WCF adapter for this common property case.</span></span> <span data-ttu-id="f880c-178">而不是写入到这两个扩展内容，您可以只需使用 WCF 扩展创建一个新的"已知"属性，理解的 WCF 适配器。</span><span class="sxs-lookup"><span data-stu-id="f880c-178">Rather than writing to both extensibility stories, you can simply have the WCF extension create a new “well known” property that is understood by the WCF adapter.</span></span>  
  
 <span data-ttu-id="f880c-179">为了编写或将 SOAP 标头值升级到 BizTalk 消息上下文，WCF 消息必须包含属性名称和命名空间组成的值对的集合。</span><span class="sxs-lookup"><span data-stu-id="f880c-179">In order to write or promote SOAP header values into the BizTalk message context, the WCF message must contain a collection of value pairs that consist of property names and namespaces.</span></span> <span data-ttu-id="f880c-180">这样，WCF 适配器，以便识别的标头值是以写入或升级。</span><span class="sxs-lookup"><span data-stu-id="f880c-180">This allows the WCF adapters to recognize that the header values are to be written or promoted.</span></span>  
  
 <span data-ttu-id="f880c-181">WCF 适配器需要下面的消息属性中的 WCF 消息的写入或升级到 BizTalk 消息上下文的 SOAP 标头值：</span><span class="sxs-lookup"><span data-stu-id="f880c-181">A WCF adapter expects the following message properties in the WCF messages for writing or promoting SOAP header values to the BizTalk message context:</span></span>  
  
-   <span data-ttu-id="f880c-182">若要升级到 BizTalk 消息上下文的 SOAP 标头值，WCF 适配器会寻找的密钥对**http://schemas.microsoft.com/BizTalk/2006/01/Adapters/WCF-properties/Promote**和值**列表 < KeyValuePair\<XmlQualifiedName，对象\>>**.</span><span class="sxs-lookup"><span data-stu-id="f880c-182">To promote the SOAP header values to the BizTalk message context, WCF adapters are looking for the pair of key **http://schemas.microsoft.com/BizTalk/2006/01/Adapters/WCF-properties/Promote** and value **List<KeyValuePair\<XmlQualifiedName, object\>>**.</span></span> <span data-ttu-id="f880c-183">使用此对 WCF 适配器采用命名空间、 名称和值从**XmlQualifiedName**对象，并将其用于升级标头值。</span><span class="sxs-lookup"><span data-stu-id="f880c-183">Using this pair, WCF adapters take the namespace, name, and value from the **XmlQualifiedName** object and use them for promoting the header values.</span></span>  
  
-   <span data-ttu-id="f880c-184">若要编写，而不是升级到 BizTalk 消息上下文中，SOAP 标头值 WCF 适配器会寻找的密钥对**http://schemas.microsoft.com/BizTalk/2006/01/Adapters/WCF-properties/WriteToContext**和值**列表 < KeyValuePair\<XmlQualifiedName，对象\>>。**</span><span class="sxs-lookup"><span data-stu-id="f880c-184">To write, but not promote, the SOAP header values into the BizTalk message context, WCF adapters are looking for the pair of key **http://schemas.microsoft.com/BizTalk/2006/01/Adapters/WCF-properties/WriteToContext** and value **List<KeyValuePair\<XmlQualifiedName, object\>>.**</span></span> <span data-ttu-id="f880c-185">WCF 适配器使用此对写入到消息上下文的值。</span><span class="sxs-lookup"><span data-stu-id="f880c-185">Using this pair, WCF adapters write the values to the message context.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="f880c-186">升级的属性还必须在 BizTalk 属性架构中以接受由 BizTalk 运行时指定。</span><span class="sxs-lookup"><span data-stu-id="f880c-186">Promoted properties must also be specified in a BizTalk property schema in order to be accepted by the BizTalk runtime.</span></span>  
  
## <a name="you-have-an-existing-orchestration-or-send-port-etc-that-expects-a-biztalk-multipart-message-how-can-you-get-a-multipart-message-in-the-wcf-scenario"></a><span data-ttu-id="f880c-187">具有一个现有的业务流程 （或发送端口，等等） 的期望 BizTalk 多部分消息。</span><span class="sxs-lookup"><span data-stu-id="f880c-187">You have an existing orchestration (or send port, etc.) that expects a BizTalk multipart message.</span></span> <span data-ttu-id="f880c-188">如何在 WCF 方案中获取多部分消息？</span><span class="sxs-lookup"><span data-stu-id="f880c-188">How can you get a multipart message in the WCF scenario?</span></span>  
 <span data-ttu-id="f880c-189">BizTalk 多部分消息组成一个或多个消息部分。</span><span class="sxs-lookup"><span data-stu-id="f880c-189">A BizTalk multipart message is composed of one or more message parts.</span></span> <span data-ttu-id="f880c-190">但是，WCF 具有多部分消息的概念。</span><span class="sxs-lookup"><span data-stu-id="f880c-190">However, WCF has no concept of a multipart message.</span></span> <span data-ttu-id="f880c-191">因为 WCF 不使用多部分消息，BizTalk WCF 适配器也不会使用它们。</span><span class="sxs-lookup"><span data-stu-id="f880c-191">Because WCF does not use multipart messages, the BizTalk WCF adapters also do not use them.</span></span> <span data-ttu-id="f880c-192">问题在于，您可能具有的现有 BizTalk 业务流程或写入到生成或使用多部分消息的管道。</span><span class="sxs-lookup"><span data-stu-id="f880c-192">The problem is that you may have an existing BizTalk orchestration or pipeline that is written to produce or consume multipart messages.</span></span>  
  
 <span data-ttu-id="f880c-193">如果你需要通过传入 WCF 消息和 WCF 适配器到 BizTalk Server 中获取多部分消息，在 WCF 消息中以 XML 形式呈现多部分数据。</span><span class="sxs-lookup"><span data-stu-id="f880c-193">If you need to get a multipart message into BizTalk Server by using an incoming WCF message and the WCF adapters, render your multipart data as XML in your WCF message.</span></span> <span data-ttu-id="f880c-194">开发用于处理传入 XML 流 （WCF 消息） 并创建应用程序相应的 BizTalk 多部分消息的自定义 BizTalk 管道组件。</span><span class="sxs-lookup"><span data-stu-id="f880c-194">Develop a custom BizTalk pipeline component to process the incoming XML stream (WCF message) and create the appropriate BizTalk multipart message for your application.</span></span> <span data-ttu-id="f880c-195">如果需要，可以在发送端反向完成这些步骤。</span><span class="sxs-lookup"><span data-stu-id="f880c-195">These steps can be done in reverse for the Send side if required.</span></span>