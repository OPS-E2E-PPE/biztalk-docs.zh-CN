---
title: 使用规则引擎时的性能注意事项 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: 7
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 41501ad852fe30ba54245a26a10e22e42979a1f5
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65262890"
---
# <a name="performance-considerations-when-using-the-rule-engine"></a><span data-ttu-id="49d94-102">使用规则引擎时的性能注意事项</span><span class="sxs-lookup"><span data-stu-id="49d94-102">Performance Considerations When Using the Rule Engine</span></span>
<span data-ttu-id="49d94-103">本主题介绍规则引擎如何执行各种方案，并且具有不同的配置/优化参数值。</span><span class="sxs-lookup"><span data-stu-id="49d94-103">This topic discusses how the rule engine performs in various scenarios and with different values for the configuration/tuning parameters.</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="49d94-104">事实类型</span><span class="sxs-lookup"><span data-stu-id="49d94-104">Fact Types</span></span>  
 <span data-ttu-id="49d94-105">规则引擎需要更少时间来访问 XML 和数据库事实比访问.NET 事实。</span><span class="sxs-lookup"><span data-stu-id="49d94-105">The rule engine takes less time to access .NET facts than it does to access XML and database facts.</span></span> <span data-ttu-id="49d94-106">如果选择在策略中使用.NET、 XML 或数据库事实，您应考虑使用.NET 事实的更好的性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-106">If you have a choice of using .NET, XML, or database facts in a policy, you should consider using .NET facts for better performance.</span></span>  
  
## <a name="data-table-vs-data-connection-binding"></a><span data-ttu-id="49d94-107">数据的表与。数据连接绑定</span><span class="sxs-lookup"><span data-stu-id="49d94-107">Data Table vs. Data Connection Binding</span></span>  
 <span data-ttu-id="49d94-108">当数据集的大小很小 （少于大约 10 行）， **TypedDataTable**绑定的性能更好地比**DataConnection**绑定。</span><span class="sxs-lookup"><span data-stu-id="49d94-108">When the size of the data set is small (fewer than approximately 10 rows), the **TypedDataTable** binding performs better than the **DataConnection** binding.</span></span> <span data-ttu-id="49d94-109">当数据集较大 （大于或等于大约 10 行）， **DataConnection**绑定的性能更好地比**TypedDataTable**绑定。</span><span class="sxs-lookup"><span data-stu-id="49d94-109">When the data set is large (greater than or equal to approximately 10 rows), the **DataConnection** binding performs better than the **TypedDataTable** binding.</span></span> <span data-ttu-id="49d94-110">因此，应决定是使用**DataConnection**绑定或**TypedDataTable**绑定基于数据集的估计大小。</span><span class="sxs-lookup"><span data-stu-id="49d94-110">Therefore, you should decide whether to use the **DataConnection** binding or the **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="49d94-111">事实检索器</span><span class="sxs-lookup"><span data-stu-id="49d94-111">Fact Retrievers</span></span>  
 <span data-ttu-id="49d94-112">您可以编写事实检索器 — 实现标准方法，并通常使用它们来提供长期和渐变事实到规则引擎之前执行了策略的对象。</span><span class="sxs-lookup"><span data-stu-id="49d94-112">You can write a fact retriever—an object that implements standard methods and typically uses them to supply long-term and slowly changing facts to the rule engine before the policy is executed.</span></span> <span data-ttu-id="49d94-113">引擎将缓存这些事实，并使用多个执行循环。</span><span class="sxs-lookup"><span data-stu-id="49d94-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="49d94-114">而不是调用规则引擎每次提交一个静态的或相当静态的事实，则应创建事实检索器，将这一事实提交第一次，并仅在需要时，然后更新内存中的事实。</span><span class="sxs-lookup"><span data-stu-id="49d94-114">Instead of submitting a static or fairly static fact each time you invoke the rule engine, you should create a fact retriever that submits the fact the first time, and then updates the fact in memory only when it is needed.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="49d94-115">规则优先级</span><span class="sxs-lookup"><span data-stu-id="49d94-115">Rule Priority</span></span>  
 <span data-ttu-id="49d94-116">优先级设置规则范围的任何一侧**0**，更大的数字越大优先级越高。</span><span class="sxs-lookup"><span data-stu-id="49d94-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="49d94-117">从最高优先级到最低优先级的顺序执行操作。</span><span class="sxs-lookup"><span data-stu-id="49d94-117">Actions are executed in order from highest priority to lowest priority.</span></span> <span data-ttu-id="49d94-118">当此策略将实现通过使用正向链接行为**Assert/Update**可以使用优先级设置优化链接的调用。</span><span class="sxs-lookup"><span data-stu-id="49d94-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="49d94-119">例如，假设**Rule2**具有一个值，通过设置该值的依赖项**Rule1**。</span><span class="sxs-lookup"><span data-stu-id="49d94-119">For example, suppose that **Rule2** has a dependency on a value that is set by **Rule1**.</span></span> <span data-ttu-id="49d94-120">为提供**Rule1**更高的优先级意味着**Rule2**后才会执行**Rule1**触发和更新值。</span><span class="sxs-lookup"><span data-stu-id="49d94-120">Giving **Rule1** a higher priority means that **Rule2** will execute only after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="49d94-121">相反，如果**Rule2**是更高的优先级，它可以触发一次，并触发后**Rule1**触发和更新这一事实， **Rule2**条件中使用。</span><span class="sxs-lookup"><span data-stu-id="49d94-121">Conversely, if **Rule2** is given a higher priority, it can fire once, and then fire again after **Rule1** fires and updates the fact that **Rule2** is using in a condition.</span></span> <span data-ttu-id="49d94-122">这可能会或可能不会产生正确的结果，但显然触发两次会影响性能与触发一次。</span><span class="sxs-lookup"><span data-stu-id="49d94-122">This may or may not produce the correct results, but clearly firing twice has a performance impact versus firing only once.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="49d94-123">Update 调用</span><span class="sxs-lookup"><span data-stu-id="49d94-123">Update Calls</span></span>  
 <span data-ttu-id="49d94-124">**更新**函数更新事实的规则引擎工作内存中存在并导致在条件中使用已更新的事实重新评估所有规则。</span><span class="sxs-lookup"><span data-stu-id="49d94-124">The **Update** function updates a fact that exists in the working memory of the rule engine, and causes all the rules that use the updated fact in conditions to be reevaluated.</span></span> <span data-ttu-id="49d94-125">**更新**函数调用可能很昂贵，尤其是如果许多规则需要因更新事实而重新计算。</span><span class="sxs-lookup"><span data-stu-id="49d94-125">**Update** function calls can be expensive, especially if many rules need to be reevaluated because of updating the facts.</span></span> <span data-ttu-id="49d94-126">有些情况下，可以避免不得不重新计算规则。</span><span class="sxs-lookup"><span data-stu-id="49d94-126">There are situations where you can avoid having to reevaluate the rules.</span></span> <span data-ttu-id="49d94-127">例如，请考虑以下规则：</span><span class="sxs-lookup"><span data-stu-id="49d94-127">For example, consider the following rules:</span></span>  
  
 <span data-ttu-id="49d94-128">**规则 1:**</span><span class="sxs-lookup"><span data-stu-id="49d94-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="49d94-129">**规则 2:**</span><span class="sxs-lookup"><span data-stu-id="49d94-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="49d94-130">策略使用的所有其余规则**StatusObj.Flag**在其条件中。</span><span class="sxs-lookup"><span data-stu-id="49d94-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="49d94-131">因此，当**更新**上调用**StatusObj**对象，将重新计算所有规则。</span><span class="sxs-lookup"><span data-stu-id="49d94-131">Therefore, when **Update** is called on the **StatusObj** object, all the rules will be reevaluated.</span></span> <span data-ttu-id="49d94-132">任何值**量**字段为，除非所有规则**Rule1**并**Rule2**计算两次，一次之前**更新**调用后, 一次**更新**调用。</span><span class="sxs-lookup"><span data-stu-id="49d94-132">Whatever the value of the **Amount** field is, all the rules except **Rule1** and **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="49d94-133">相反，可以设置的值**标志**字段**false**调用策略，则仅使用前**Rule1**在策略中设置标志。</span><span class="sxs-lookup"><span data-stu-id="49d94-133">Instead, you could set the value of the **flag** field to **false** before you invoke the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="49d94-134">在这种情况下，**更新**才会调用的值**量**字段大于 5，并且**更新**如果金额小于或等于 5 不调用。</span><span class="sxs-lookup"><span data-stu-id="49d94-134">In this case, **Update** is called only if the value of the **Amount** field is greater than 5, and **Update** is not called if the amount is less than or equal to 5.</span></span> <span data-ttu-id="49d94-135">因此，所有规则除外**Rule1**并**Rule2**计算两次才的值**量**字段大于 5。</span><span class="sxs-lookup"><span data-stu-id="49d94-135">Therefore, all the rules except **Rule1** and **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="use-of-logical-or-operators"></a><span data-ttu-id="49d94-136">使用逻辑 OR 运算符</span><span class="sxs-lookup"><span data-stu-id="49d94-136">Use of Logical OR Operators</span></span>  
 <span data-ttu-id="49d94-137">规则引擎进行了优化的执行逻辑**AND**运算符，它重新构造分析的规则在析取范式中因此所**或**运算符仅在最高级别使用。</span><span class="sxs-lookup"><span data-stu-id="49d94-137">The rule engine is optimized for executing logical **AND** operators and it reconstructs the rule it parsed in a disjunctive normal form so that **OR** operator is used only at the top level.</span></span> <span data-ttu-id="49d94-138">使用越来越多的逻辑**或**中条件的运算符创建其他排列，从而扩展规则引擎的分析网络，并可能需要很长时间的规则引擎来规范化规则。</span><span class="sxs-lookup"><span data-stu-id="49d94-138">Using an increasing number of logical **OR** operators in conditions creates additional permutations that expand the analysis network of the rule engine, and It may take long time for the rule engine to normalize the rule.</span></span> <span data-ttu-id="49d94-139">以下列表包含此问题的可能解决方法。</span><span class="sxs-lookup"><span data-stu-id="49d94-139">The following list contains possible workarounds for this issue.</span></span>  
  
-   <span data-ttu-id="49d94-140">修改规则为析取范式中因此**或**运算符是仅在最高级别。</span><span class="sxs-lookup"><span data-stu-id="49d94-140">Modify the rule to be in disjunctive normal form so that the **OR** operator is only at the top level.</span></span> <span data-ttu-id="49d94-141">请注意，开发了析取范式在业务规则编辑器中的规则可能比较棘手。</span><span class="sxs-lookup"><span data-stu-id="49d94-141">Note that developing a rule in disjunctive normal form in Business Rule Composer can be tricky.</span></span> <span data-ttu-id="49d94-142">您可能想要以编程方式创建规则，请考虑。</span><span class="sxs-lookup"><span data-stu-id="49d94-142">You may want to consider creating the rule programmatically.</span></span>  
  
-   <span data-ttu-id="49d94-143">开发的帮助器组件执行**或**操作并返回一个布尔值，并在规则中使用该组件。</span><span class="sxs-lookup"><span data-stu-id="49d94-143">Develop a helper component that performs the **OR** operations and returns a Boolean value, and use the component in the rule.</span></span>  
  
-   <span data-ttu-id="49d94-144">请考虑将规则拆分为多个规则和具有规则检查标志由以前执行的规则设置，或者使用一个对象，如以下示例所示添加由以前执行的规则：</span><span class="sxs-lookup"><span data-stu-id="49d94-144">Consider splitting the rule into multiple rules and have the rules check for a flag set by a previously executed rule or use an object that is asserted by a previously executed rule as shown in the following examples:</span></span>  
  
    -   <span data-ttu-id="49d94-145">规则 1:如果 (1 = = 或 = = 3) 然后 b = true</span><span class="sxs-lookup"><span data-stu-id="49d94-145">Rule 1: IF (a == 1 OR a == 3) THEN b = true</span></span>  
  
         <span data-ttu-id="49d94-146">规则 2： 如果 (b = = true) 然后...</span><span class="sxs-lookup"><span data-stu-id="49d94-146">Rule 2: if (b == true) THEN …</span></span>  
  
    -   <span data-ttu-id="49d94-147">规则 1:如果 (1 = = 或 = = 3) 然后断言 (新 c())</span><span class="sxs-lookup"><span data-stu-id="49d94-147">Rule 1: IF (a == 1 OR a == 3) THEN assert(new c())</span></span>  
  
         <span data-ttu-id="49d94-148">规则 2:IF (c.flag == true) THEN …</span><span class="sxs-lookup"><span data-stu-id="49d94-148">Rule 2: IF (c.flag == true) THEN …</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="49d94-149">缓存设置</span><span class="sxs-lookup"><span data-stu-id="49d94-149">Caching Settings</span></span>  
 <span data-ttu-id="49d94-150">规则引擎使用两个缓存。</span><span class="sxs-lookup"><span data-stu-id="49d94-150">The rule engine uses two caches.</span></span> <span data-ttu-id="49d94-151">第一个参数是在更新服务和第二个是在每个 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="49d94-151">The first one is in the Update service and the second one is in each BizTalk process.</span></span> <span data-ttu-id="49d94-152">首次使用一个策略，BizTalk 进程从更新服务请求的策略信息。</span><span class="sxs-lookup"><span data-stu-id="49d94-152">The first time a policy is used, the BizTalk process requests the policy information from the Update service.</span></span> <span data-ttu-id="49d94-153">更新服务从规则引擎数据库中检索策略信息、 缓存，并将信息返回到 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="49d94-153">The Update service retrieves the policy information from the Rule Engine database, caches it, and returns the information to the BizTalk process.</span></span> <span data-ttu-id="49d94-154">BizTalk 进程创建基于该信息的策略对象，并将该策略对象存储在缓存中，相关联的规则引擎实例完成后执行策略。</span><span class="sxs-lookup"><span data-stu-id="49d94-154">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes executing the policy.</span></span> <span data-ttu-id="49d94-155">再次调用同一个策略时，BizTalk 进程重用缓存中的策略对象，如果有在缓存中可用。</span><span class="sxs-lookup"><span data-stu-id="49d94-155">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available in the cache.</span></span>  
  
 <span data-ttu-id="49d94-156">同样，如果 BizTalk 进程从更新服务请求有关策略的信息，更新服务首先查找其缓存中的策略信息。</span><span class="sxs-lookup"><span data-stu-id="49d94-156">Similarly, if the BizTalk process requests the information about a policy from the Update service, the Update service first looks for the policy information in its cache.</span></span> <span data-ttu-id="49d94-157">更新服务还会检查每隔 60 秒 （一分钟） 以查看是否已对数据库中的策略的任何更新。</span><span class="sxs-lookup"><span data-stu-id="49d94-157">The Update service also checks every 60 seconds (one minute) to see if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="49d94-158">如果有任何更新，更新服务检索信息，并将缓存的更新的信息。</span><span class="sxs-lookup"><span data-stu-id="49d94-158">If there are any updates, the Update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="49d94-159">有三个规则引擎与这些缓存相关的优化参数：**CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="49d94-159">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="49d94-160">在注册表或配置文件中，可以指定这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="49d94-160">You can specify the values for these parameters either in the registry or in a configuration file.</span></span>  
  
 <span data-ttu-id="49d94-161">值**CacheEntries**是缓存中的最大项数。</span><span class="sxs-lookup"><span data-stu-id="49d94-161">The value of **CacheEntries** is the maximum number of entries in the cache.</span></span> <span data-ttu-id="49d94-162">默认值**CacheEntries**为 32。</span><span class="sxs-lookup"><span data-stu-id="49d94-162">The default value of **CacheEntries** is 32.</span></span> <span data-ttu-id="49d94-163">你可能想要增加的价值**CacheEntries**参数，以提高在某些情况下的性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-163">You may want to increase the value of the **CacheEntries** parameter to improve performance in some cases.</span></span> <span data-ttu-id="49d94-164">例如，假设您重复使用 40 个策略。</span><span class="sxs-lookup"><span data-stu-id="49d94-164">For example, suppose you are using 40 policies repeatedly.</span></span> <span data-ttu-id="49d94-165">在这种情况下你可能想要增加的价值**CacheEntries**至 40 以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-165">In this case you may want to increase the value of **CacheEntries** to 40 to improve performance.</span></span> <span data-ttu-id="49d94-166">这将在内存中允许更新服务的最多 40 个策略的缓存详细信息。</span><span class="sxs-lookup"><span data-stu-id="49d94-166">This would allow the Update service to cache details of up to 40 policies in memory.</span></span> <span data-ttu-id="49d94-167">此外可以使 BizTalk 服务能缓存多达 40 个在内存中的策略实例。</span><span class="sxs-lookup"><span data-stu-id="49d94-167">It would also cause the BizTalk service to cache up to 40 policy instances in memory.</span></span> <span data-ttu-id="49d94-168">可能有多个实例中的 BizTalk 服务的缓存策略。</span><span class="sxs-lookup"><span data-stu-id="49d94-168">There may be more than one instance of a policy in the cache of the BizTalk service.</span></span>  
  
 <span data-ttu-id="49d94-169">值**CacheTimeout**是从更新服务缓存条目的时间 （以秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="49d94-169">The value of **CacheTimeout** is the time (in seconds) for entries to age out of the Update service cache.</span></span> <span data-ttu-id="49d94-170">换而言之， **CacheTimeout**值参考了多长时间策略某个缓存项保存在缓存中是否存在任何对它的引用。</span><span class="sxs-lookup"><span data-stu-id="49d94-170">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is kept in the cache if there are no references to it.</span></span> <span data-ttu-id="49d94-171">默认值**CacheTimeout**为 3600 秒 （1 小时）。</span><span class="sxs-lookup"><span data-stu-id="49d94-171">The default value of **CacheTimeout** is 3600 seconds (one hour).</span></span> <span data-ttu-id="49d94-172">这意味着，如果一小时内未引用的缓存项，将其删除。</span><span class="sxs-lookup"><span data-stu-id="49d94-172">This means that, if the cache entry is not referenced within an hour, it is deleted.</span></span> <span data-ttu-id="49d94-173">在某些情况下，你可能想要增加**CacheTimeout**值以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-173">In some cases, you may want to increase the **CacheTimeout** value to improve performance.</span></span> <span data-ttu-id="49d94-174">例如，假设将调用策略，每隔两小时。</span><span class="sxs-lookup"><span data-stu-id="49d94-174">For example, suppose the policy is invoked every two hours.</span></span> <span data-ttu-id="49d94-175">您可以通过增加的值提高策略执行的性能**CacheTimeout**值超过两个小时以上的参数。</span><span class="sxs-lookup"><span data-stu-id="49d94-175">You could improve the performance of the policy execution by increasing the value of the **CacheTimeout** parameter to a value greater than two hours.</span></span>  
  
 <span data-ttu-id="49d94-176">**PollingInterval**参数的规则引擎更新服务会检查更新的规则引擎数据库的时间间隔 （秒） 定义的时间。</span><span class="sxs-lookup"><span data-stu-id="49d94-176">The **PollingInterval** parameter for the rule engine defines the time in seconds for the interval at which the Update service checks the Rule Engine database for updates.</span></span> <span data-ttu-id="49d94-177">默认值为**PollingInterval**参数为 60 秒 （一分钟）。</span><span class="sxs-lookup"><span data-stu-id="49d94-177">The default value for the **PollingInterval** parameter is 60 seconds (one minute).</span></span> <span data-ttu-id="49d94-178">如果您知道策略不在所有更新或者很少更新，可以增加此值以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-178">If you know that the policies do not get updated at all or are updated rarely, you could increase this value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="49d94-179">SideEffects 属性</span><span class="sxs-lookup"><span data-stu-id="49d94-179">SideEffects Property</span></span>  
 <span data-ttu-id="49d94-180">**ClassMemberBinding**， **DatabaseColumnBinding**，并**XmlDocumentFieldBinding**类具有一个名为属性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="49d94-180">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="49d94-181">此属性确定是否缓存绑定的字段、 成员或列的值。</span><span class="sxs-lookup"><span data-stu-id="49d94-181">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="49d94-182">默认值**SideEffects**属性中的**DatabaseColumnBinding**并**XmlDocumentFieldBinding**类是**false**.</span><span class="sxs-lookup"><span data-stu-id="49d94-182">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="49d94-183">默认值**SideEffects**属性中的**ClassMemberBinding**类是**true**。</span><span class="sxs-lookup"><span data-stu-id="49d94-183">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="49d94-184">因此，XML 文档的字段或数据库表的列访问时的第二次或更高版本的策略内，从缓存检索其值。</span><span class="sxs-lookup"><span data-stu-id="49d94-184">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="49d94-185">但是，第二次或更高版本访问.NET 对象的成员时，从.NET 对象，而不是从缓存检索的值。</span><span class="sxs-lookup"><span data-stu-id="49d94-185">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="49d94-186">设置**SideEffects**的.NET 属性**ClassMemberBinding**到**false**会提高性能，因为从缓存中检索的字段的值第二次及更高版本。</span><span class="sxs-lookup"><span data-stu-id="49d94-186">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="49d94-187">您可以仅执行此操作以编程方式。</span><span class="sxs-lookup"><span data-stu-id="49d94-187">You can only do this programmatically.</span></span> <span data-ttu-id="49d94-188">业务规则编辑器工具不会公开**SideEffects**属性。</span><span class="sxs-lookup"><span data-stu-id="49d94-188">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="49d94-189">Instances 和 Selectivity</span><span class="sxs-lookup"><span data-stu-id="49d94-189">Instances and Selectivity</span></span>  
 <span data-ttu-id="49d94-190">**XmlDocumentBinding**， **ClassBinding**，并**DatabaseBinding**类具有两个属性：**实例**并**选择性**。</span><span class="sxs-lookup"><span data-stu-id="49d94-190">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="49d94-191">值**实例**是预期的工作内存中类的实例数。</span><span class="sxs-lookup"><span data-stu-id="49d94-191">The value of **Instances** is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="49d94-192">值**选择性**是成功传递规则条件的类实例的百分比。</span><span class="sxs-lookup"><span data-stu-id="49d94-192">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="49d94-193">规则引擎使用这些值来优化条件评估，以便在条件计算中首次使用最少可能实例，然后使用剩余的实例。</span><span class="sxs-lookup"><span data-stu-id="49d94-193">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="49d94-194">如果您有经验的对象的实例数，则将设置**实例**属性设置为该值也会提高性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-194">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="49d94-195">同样，如果必须预先知道满足条件这些对象的百分比，则设置**选择性**属性设置为该值也会提高性能。</span><span class="sxs-lookup"><span data-stu-id="49d94-195">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="49d94-196">只能以编程方式设置这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="49d94-196">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="49d94-197">业务规则编辑器工具不公开它们。</span><span class="sxs-lookup"><span data-stu-id="49d94-197">The Business Rule Composer tool does not expose them.</span></span>