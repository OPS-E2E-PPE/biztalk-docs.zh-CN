---
title: "使用规则引擎时的性能注意事项 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: "7"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: c24a1c6ffb278d257e16c192e5fc7d827df70e24
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="performance-considerations-when-using-the-rule-engine"></a><span data-ttu-id="49e9d-102">使用规则引擎时的性能注意事项</span><span class="sxs-lookup"><span data-stu-id="49e9d-102">Performance Considerations When Using the Rule Engine</span></span>
<span data-ttu-id="49e9d-103">本主题介绍规则引擎在各种情况下以及使用不同的配置/优化参数值时的性能表现。</span><span class="sxs-lookup"><span data-stu-id="49e9d-103">This topic discusses how the rule engine performs in various scenarios and with different values for the configuration/tuning parameters.</span></span>  
  
## <a name="fact-types"></a><span data-ttu-id="49e9d-104">事实类型</span><span class="sxs-lookup"><span data-stu-id="49e9d-104">Fact Types</span></span>  
 <span data-ttu-id="49e9d-105">规则引擎访问 .NET 事实所用的时间比访问 XML 事实和数据库事实所用的时间要少。</span><span class="sxs-lookup"><span data-stu-id="49e9d-105">The rule engine takes less time to access .NET facts than it does to access XML and database facts.</span></span> <span data-ttu-id="49e9d-106">如果面临在策略中使用 .NET 事实、XML 事实还是数据库事实的情况，应该考虑到，使用 .NET 事实会获得更好的性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-106">If you have a choice of using .NET, XML, or database facts in a policy, you should consider using .NET facts for better performance.</span></span>  
  
## <a name="data-table-vs-data-connection-binding"></a><span data-ttu-id="49e9d-107">数据表 vs。数据连接绑定</span><span class="sxs-lookup"><span data-stu-id="49e9d-107">Data Table vs. Data Connection Binding</span></span>  
 <span data-ttu-id="49e9d-108">当数据集的大小很小 （少于大约 10 行）， **TypedDataTable**绑定更好地执行比**该组**绑定。</span><span class="sxs-lookup"><span data-stu-id="49e9d-108">When the size of the data set is small (fewer than approximately 10 rows), the **TypedDataTable** binding performs better than the **DataConnection** binding.</span></span> <span data-ttu-id="49e9d-109">大型数据集时 （大于或等于大约 10 行），**该组**绑定更好地执行比**TypedDataTable**绑定。</span><span class="sxs-lookup"><span data-stu-id="49e9d-109">When the data set is large (greater than or equal to approximately 10 rows), the **DataConnection** binding performs better than the **TypedDataTable** binding.</span></span> <span data-ttu-id="49e9d-110">因此，你应确定是否使用**该组**绑定或**TypedDataTable**绑定基于数据集的估计大小。</span><span class="sxs-lookup"><span data-stu-id="49e9d-110">Therefore, you should decide whether to use the **DataConnection** binding or the **TypedDataTable** binding based on the estimated size of the data set.</span></span>  
  
## <a name="fact-retrievers"></a><span data-ttu-id="49e9d-111">事实检索器</span><span class="sxs-lookup"><span data-stu-id="49e9d-111">Fact Retrievers</span></span>  
 <span data-ttu-id="49e9d-112">你可以编写事实检索器 — 实施标准方法，并通常提供长期和渐变事实到规则引擎在执行该策略之前使用它们的对象。</span><span class="sxs-lookup"><span data-stu-id="49e9d-112">You can write a fact retriever—an object that implements standard methods and typically uses them to supply long-term and slowly changing facts to the rule engine before the policy is executed.</span></span> <span data-ttu-id="49e9d-113">引擎将缓存这些事实，并在多个执行循环中使用它们。</span><span class="sxs-lookup"><span data-stu-id="49e9d-113">The engine caches these facts and uses them over multiple execution cycles.</span></span> <span data-ttu-id="49e9d-114">您应该创建一个事实检索器，它只在第一次调用规则引擎时提交事实，然后在需要时才在内存中更新该事实，而不是每次调用规则引擎时都提交一个静态事实或相当静态的事实。</span><span class="sxs-lookup"><span data-stu-id="49e9d-114">Instead of submitting a static or fairly static fact each time you invoke the rule engine, you should create a fact retriever that submits the fact the first time, and then updates the fact in memory only when it is needed.</span></span>  
  
## <a name="rule-priority"></a><span data-ttu-id="49e9d-115">规则的优先级</span><span class="sxs-lookup"><span data-stu-id="49e9d-115">Rule Priority</span></span>  
 <span data-ttu-id="49e9d-116">优先级设置的任何一侧的范围规则可以**0**，有了更多具有更高的优先级。</span><span class="sxs-lookup"><span data-stu-id="49e9d-116">The priority setting for a rule can range on either side of **0**, with larger numbers having higher priority.</span></span> <span data-ttu-id="49e9d-117">操作按照从最高优先级到最低优先级的顺序执行。</span><span class="sxs-lookup"><span data-stu-id="49e9d-117">Actions are executed in order from highest priority to lowest priority.</span></span> <span data-ttu-id="49e9d-118">当策略都实现通过使用正向链接行为**断言/更新**调用，链接，可优化通过使用的优先级设置。</span><span class="sxs-lookup"><span data-stu-id="49e9d-118">When the policy implements forward-chaining behavior by using **Assert/Update** calls, the chaining can be optimized by using the priority setting.</span></span> <span data-ttu-id="49e9d-119">例如，假设**Rule2**具有一个值，通过设置的依赖关系**规则 1**。</span><span class="sxs-lookup"><span data-stu-id="49e9d-119">For example, suppose that **Rule2** has a dependency on a value that is set by **Rule1**.</span></span> <span data-ttu-id="49e9d-120">提供**规则 1**更高的优先级意味着**Rule2**将之后才执行**规则 1**激发和更新的值。</span><span class="sxs-lookup"><span data-stu-id="49e9d-120">Giving **Rule1** a higher priority means that **Rule2** will execute only after **Rule1** fires and updates the value.</span></span> <span data-ttu-id="49e9d-121">相反，如果**Rule2**是更高的优先级，它可以触发一次，并显示后再次然后激发**规则 1**触发并更新这一事实， **Rule2**条件中使用。</span><span class="sxs-lookup"><span data-stu-id="49e9d-121">Conversely, if **Rule2** is given a higher priority, it can fire once, and then fire again after **Rule1** fires and updates the fact that **Rule2** is using in a condition.</span></span> <span data-ttu-id="49e9d-122">这样可能会也可能不会生成正确的结果，但显然触发两次比只触发一次对性能的影响更大。</span><span class="sxs-lookup"><span data-stu-id="49e9d-122">This may or may not produce the correct results, but clearly firing twice has a performance impact versus firing only once.</span></span>  
  
## <a name="update-calls"></a><span data-ttu-id="49e9d-123">更新调用</span><span class="sxs-lookup"><span data-stu-id="49e9d-123">Update Calls</span></span>  
 <span data-ttu-id="49e9d-124">**更新**函数更新存在于规则引擎，使用内存中并导致在条件中使用更新的事实进行重新求值的所有规则的事实。</span><span class="sxs-lookup"><span data-stu-id="49e9d-124">The **Update** function updates a fact that exists in the working memory of the rule engine, and causes all the rules that use the updated fact in conditions to be reevaluated.</span></span> <span data-ttu-id="49e9d-125">**更新**函数调用可能很昂贵，尤其是许多规则需要会由于更新事实数据重新计算。</span><span class="sxs-lookup"><span data-stu-id="49e9d-125">**Update** function calls can be expensive, especially if many rules need to be reevaluated because of updating the facts.</span></span> <span data-ttu-id="49e9d-126">在有些情况下，可以避免重新计算规则。</span><span class="sxs-lookup"><span data-stu-id="49e9d-126">There are situations where you can avoid having to reevaluate the rules.</span></span> <span data-ttu-id="49e9d-127">例如，考虑以下规则：</span><span class="sxs-lookup"><span data-stu-id="49e9d-127">For example, consider the following rules:</span></span>  
  
 <span data-ttu-id="49e9d-128">**规则 1:**</span><span class="sxs-lookup"><span data-stu-id="49e9d-128">**Rule1:**</span></span>  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 <span data-ttu-id="49e9d-129">**Rule2:**</span><span class="sxs-lookup"><span data-stu-id="49e9d-129">**Rule2:**</span></span>  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 <span data-ttu-id="49e9d-130">策略使用的所有剩余规则**StatusObj.Flag**在其条件。</span><span class="sxs-lookup"><span data-stu-id="49e9d-130">All remaining rules of the policy use **StatusObj.Flag** in their conditions.</span></span> <span data-ttu-id="49e9d-131">因此，当**更新**上调用**StatusObj**对象，将会重新计算所有规则。</span><span class="sxs-lookup"><span data-stu-id="49e9d-131">Therefore, when **Update** is called on the **StatusObj** object, all the rules will be reevaluated.</span></span> <span data-ttu-id="49e9d-132">任意值**量**字段为，除之外的所有规则**规则 1**和**Rule2**两次，计算一次之前**更新**调用，另一次后的**更新**调用。</span><span class="sxs-lookup"><span data-stu-id="49e9d-132">Whatever the value of the **Amount** field is, all the rules except **Rule1** and **Rule2** are evaluated twice, once before the **Update** call and once after the **Update** call.</span></span>  
  
 <span data-ttu-id="49e9d-133">相反，你可以设置的值**标志**字段**false**你调用该策略，然后使用仅之前**规则 1**中设置标志的策略。</span><span class="sxs-lookup"><span data-stu-id="49e9d-133">Instead, you could set the value of the **flag** field to **false** before you invoke the policy and then use only **Rule1** in the policy to set the flag.</span></span> <span data-ttu-id="49e9d-134">在这种情况下，**更新**才会调用的值**量**字段大于 5，和**更新**如果量小于或等于 5，则不会调用。</span><span class="sxs-lookup"><span data-stu-id="49e9d-134">In this case, **Update** is called only if the value of the **Amount** field is greater than 5, and **Update** is not called if the amount is less than or equal to 5.</span></span> <span data-ttu-id="49e9d-135">因此，所有规则除**规则 1**和**Rule2**计算两次才的值**量**字段大于 5。</span><span class="sxs-lookup"><span data-stu-id="49e9d-135">Therefore, all the rules except **Rule1** and **Rule2** are evaluated twice only if the value of the **Amount** field is greater than 5.</span></span>  
  
## <a name="use-of-logical-or-operators"></a><span data-ttu-id="49e9d-136">使用“逻辑或”运算符</span><span class="sxs-lookup"><span data-stu-id="49e9d-136">Use of Logical OR Operators</span></span>  
 <span data-ttu-id="49e9d-137">规则引擎进行了优化用于执行逻辑**AND**运算符和它重新构造对其分析中分离的标准形式因此，该规则**或**仅在顶级使用运算符。</span><span class="sxs-lookup"><span data-stu-id="49e9d-137">The rule engine is optimized for executing logical **AND** operators and it reconstructs the rule it parsed in a disjunctive normal form so that **OR** operator is used only at the top level.</span></span> <span data-ttu-id="49e9d-138">使用越来越多的逻辑**或**中条件的运算符创建展开规则引擎，分析网络的其他排列，这可能需要长时间来规范化该规则的规则引擎。</span><span class="sxs-lookup"><span data-stu-id="49e9d-138">Using an increasing number of logical **OR** operators in conditions creates additional permutations that expand the analysis network of the rule engine, and It may take long time for the rule engine to normalize the rule.</span></span> <span data-ttu-id="49e9d-139">以下列表包含此问题的可能解决方法。</span><span class="sxs-lookup"><span data-stu-id="49e9d-139">The following list contains possible workarounds for this issue.</span></span>  
  
-   <span data-ttu-id="49e9d-140">修改要使规则中分离范式因此，**或**运算符是仅在最高级别。</span><span class="sxs-lookup"><span data-stu-id="49e9d-140">Modify the rule to be in disjunctive normal form so that the **OR** operator is only at the top level.</span></span> <span data-ttu-id="49e9d-141">请注意，开发分离正常业务规则编辑器中的窗体中的规则可能会很棘手。</span><span class="sxs-lookup"><span data-stu-id="49e9d-141">Note that developing a rule in disjunctive normal form in Business Rule Composer can be tricky.</span></span> <span data-ttu-id="49e9d-142">你可能想要以编程方式创建规则，请考虑。</span><span class="sxs-lookup"><span data-stu-id="49e9d-142">You may want to consider creating the rule programmatically.</span></span>  
  
-   <span data-ttu-id="49e9d-143">开发执行的帮助程序组件**或**操作并返回一个布尔值，并且在规则中使用该组件。</span><span class="sxs-lookup"><span data-stu-id="49e9d-143">Develop a helper component that performs the **OR** operations and returns a Boolean value, and use the component in the rule.</span></span>  
  
-   <span data-ttu-id="49e9d-144">请考虑将规则拆分为多个规则和具有规则检查标志以前执行的规则所设或使用下面的示例中所示，由以前执行的规则断言的对象：</span><span class="sxs-lookup"><span data-stu-id="49e9d-144">Consider splitting the rule into multiple rules and have the rules check for a flag set by a previously executed rule or use an object that is asserted by a previously executed rule as shown in the following examples:</span></span>  
  
    -   <span data-ttu-id="49e9d-145">规则 1： 如果 (= = 1 或 = = 3) 然后 b = true</span><span class="sxs-lookup"><span data-stu-id="49e9d-145">Rule 1: IF (a == 1 OR a == 3) THEN b = true</span></span>  
  
         <span data-ttu-id="49e9d-146">规则 2： 如果 (b = = true) 然后...</span><span class="sxs-lookup"><span data-stu-id="49e9d-146">Rule 2: if (b == true) THEN …</span></span>  
  
    -   <span data-ttu-id="49e9d-147">规则 1： 如果 (= = 1 或 = = 3) 然后断言 (新 c())</span><span class="sxs-lookup"><span data-stu-id="49e9d-147">Rule 1: IF (a == 1 OR a == 3) THEN assert(new c())</span></span>  
  
         <span data-ttu-id="49e9d-148">规则 2： 如果 (c.flag = = true) 然后...</span><span class="sxs-lookup"><span data-stu-id="49e9d-148">Rule 2: IF (c.flag == true) THEN …</span></span>  
  
## <a name="caching-settings"></a><span data-ttu-id="49e9d-149">缓存设置</span><span class="sxs-lookup"><span data-stu-id="49e9d-149">Caching Settings</span></span>  
 <span data-ttu-id="49e9d-150">规则引擎使用两个缓存。</span><span class="sxs-lookup"><span data-stu-id="49e9d-150">The rule engine uses two caches.</span></span> <span data-ttu-id="49e9d-151">第一个缓存在更新服务中，第二个缓存在每个 BizTalk 进程中。</span><span class="sxs-lookup"><span data-stu-id="49e9d-151">The first one is in the Update service and the second one is in each BizTalk process.</span></span> <span data-ttu-id="49e9d-152">初次使用某个策略时，BizTalk 进程从更新服务请求策略信息。</span><span class="sxs-lookup"><span data-stu-id="49e9d-152">The first time a policy is used, the BizTalk process requests the policy information from the Update service.</span></span> <span data-ttu-id="49e9d-153">更新服务从规则引擎数据库检索策略信息，对其进行缓存，然后将信息返回 BizTalk 进程。</span><span class="sxs-lookup"><span data-stu-id="49e9d-153">The Update service retrieves the policy information from the Rule Engine database, caches it, and returns the information to the BizTalk process.</span></span> <span data-ttu-id="49e9d-154">BizTalk 进程基于该信息创建策略对象，并在关联的规则引擎实例完成策略执行后，将策略对象存储在缓存中。</span><span class="sxs-lookup"><span data-stu-id="49e9d-154">The BizTalk process creates a policy object based on that information and stores the policy object in a cache when the associated rule engine instance completes executing the policy.</span></span> <span data-ttu-id="49e9d-155">再次调用同一个策略时，BizTalk 进程重用缓存中的策略对象（如果缓存中有的话）。</span><span class="sxs-lookup"><span data-stu-id="49e9d-155">When the same policy is invoked again, the BizTalk process reuses the policy object from the cache if one is available in the cache.</span></span>  
  
 <span data-ttu-id="49e9d-156">同样，如果 BizTalk 进程从更新服务请求有关策略的信息，更新服务会首先在其缓存中查找策略信息。</span><span class="sxs-lookup"><span data-stu-id="49e9d-156">Similarly, if the BizTalk process requests the information about a policy from the Update service, the Update service first looks for the policy information in its cache.</span></span> <span data-ttu-id="49e9d-157">更新服务还会每隔 60 秒（一分钟）进行检查，查看是否对数据库中的策略有任何更新。</span><span class="sxs-lookup"><span data-stu-id="49e9d-157">The Update service also checks every 60 seconds (one minute) to see if there have been any updates to the policy in the database.</span></span> <span data-ttu-id="49e9d-158">如果有任何更新，更新服务将检索该信息，将更新的信息进行缓存。</span><span class="sxs-lookup"><span data-stu-id="49e9d-158">If there are any updates, the Update service retrieves the information and caches the updated information.</span></span>  
  
 <span data-ttu-id="49e9d-159">与这些缓存相关的规则引擎的三个优化参数： **CacheEntries**， **CacheTimeout**，和**PollingInterval**。</span><span class="sxs-lookup"><span data-stu-id="49e9d-159">There are three tuning parameters for the rule engine related to these caches: **CacheEntries**, **CacheTimeout**, and **PollingInterval**.</span></span> <span data-ttu-id="49e9d-160">您可以在注册表或配置文件中为这些参数指定值。</span><span class="sxs-lookup"><span data-stu-id="49e9d-160">You can specify the values for these parameters either in the registry or in a configuration file.</span></span>  
  
 <span data-ttu-id="49e9d-161">值**CacheEntries**是缓存中的最大项数。</span><span class="sxs-lookup"><span data-stu-id="49e9d-161">The value of **CacheEntries** is the maximum number of entries in the cache.</span></span> <span data-ttu-id="49e9d-162">默认值**CacheEntries**为 32。</span><span class="sxs-lookup"><span data-stu-id="49e9d-162">The default value of **CacheEntries** is 32.</span></span> <span data-ttu-id="49e9d-163">你可能想要的值增加**CacheEntries**参数，以提高在某些情况下的性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-163">You may want to increase the value of the **CacheEntries** parameter to improve performance in some cases.</span></span> <span data-ttu-id="49e9d-164">例如，假设您要重复地使用 40 个策略。</span><span class="sxs-lookup"><span data-stu-id="49e9d-164">For example, suppose you are using 40 policies repeatedly.</span></span> <span data-ttu-id="49e9d-165">在这种情况下你可能想要的值增加**CacheEntries**为 40 以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-165">In this case you may want to increase the value of **CacheEntries** to 40 to improve performance.</span></span> <span data-ttu-id="49e9d-166">这样做可以使更新服务在内存中能缓存多达 40 个策略的详细信息。</span><span class="sxs-lookup"><span data-stu-id="49e9d-166">This would allow the Update service to cache details of up to 40 policies in memory.</span></span> <span data-ttu-id="49e9d-167">还可以使 BizTalk 服务在内存中能缓存多达 40 个策略实例。</span><span class="sxs-lookup"><span data-stu-id="49e9d-167">It would also cause the BizTalk service to cache up to 40 policy instances in memory.</span></span> <span data-ttu-id="49e9d-168">在 BizTalk 服务的缓存中可能有策略的多个实例。</span><span class="sxs-lookup"><span data-stu-id="49e9d-168">There may be more than one instance of a policy in the cache of the BizTalk service.</span></span>  
  
 <span data-ttu-id="49e9d-169">值**CacheTimeout**用于更新服务缓存中脱离的条目的时间 （以秒为单位）。</span><span class="sxs-lookup"><span data-stu-id="49e9d-169">The value of **CacheTimeout** is the time (in seconds) for entries to age out of the Update service cache.</span></span> <span data-ttu-id="49e9d-170">换而言之， **CacheTimeout**值参考了策略的缓存项的保留时间缓存中是否存在任何引用了它。</span><span class="sxs-lookup"><span data-stu-id="49e9d-170">In other words, the **CacheTimeout** value refers to how long a cache entry for a policy is kept in the cache if there are no references to it.</span></span> <span data-ttu-id="49e9d-171">默认值**CacheTimeout**为 3600 秒 （1 小时）。</span><span class="sxs-lookup"><span data-stu-id="49e9d-171">The default value of **CacheTimeout** is 3600 seconds (one hour).</span></span> <span data-ttu-id="49e9d-172">这意味着，如果缓存条目没有在一小时之内被引用，就会被删除。</span><span class="sxs-lookup"><span data-stu-id="49e9d-172">This means that, if the cache entry is not referenced within an hour, it is deleted.</span></span> <span data-ttu-id="49e9d-173">在某些情况下，你可能想要增加**CacheTimeout**值以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-173">In some cases, you may want to increase the **CacheTimeout** value to improve performance.</span></span> <span data-ttu-id="49e9d-174">例如，假设策略每隔两小时调用一次。</span><span class="sxs-lookup"><span data-stu-id="49e9d-174">For example, suppose the policy is invoked every two hours.</span></span> <span data-ttu-id="49e9d-175">可以通过增加的值通过改进性能的策略执行**CacheTimeout**参数大于两个小时的值。</span><span class="sxs-lookup"><span data-stu-id="49e9d-175">You could improve the performance of the policy execution by increasing the value of the **CacheTimeout** parameter to a value greater than two hours.</span></span>  
  
 <span data-ttu-id="49e9d-176">**PollingInterval**规则引擎的参数在秒的间隔更新服务检查更新的规则引擎数据库中定义的时间。</span><span class="sxs-lookup"><span data-stu-id="49e9d-176">The **PollingInterval** parameter for the rule engine defines the time in seconds for the interval at which the Update service checks the Rule Engine database for updates.</span></span> <span data-ttu-id="49e9d-177">默认值为**PollingInterval**参数为 60 秒 （1 分钟）。</span><span class="sxs-lookup"><span data-stu-id="49e9d-177">The default value for the **PollingInterval** parameter is 60 seconds (one minute).</span></span> <span data-ttu-id="49e9d-178">如果您知道策略根本不更新或者很少更新，可以增加此值以提高性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-178">If you know that the policies do not get updated at all or are updated rarely, you could increase this value to improve performance.</span></span>  
  
## <a name="sideeffects-property"></a><span data-ttu-id="49e9d-179">SideEffects 属性</span><span class="sxs-lookup"><span data-stu-id="49e9d-179">SideEffects Property</span></span>  
 <span data-ttu-id="49e9d-180">**ClassMemberBinding**， **DatabaseColumnBinding**，和**XmlDocumentFieldBinding**类具有名为的属性**SideEffects**.</span><span class="sxs-lookup"><span data-stu-id="49e9d-180">The **ClassMemberBinding**, **DatabaseColumnBinding**, and **XmlDocumentFieldBinding** classes have a property named **SideEffects**.</span></span> <span data-ttu-id="49e9d-181">此属性确定是否缓存绑定字段的值、成员或列。</span><span class="sxs-lookup"><span data-stu-id="49e9d-181">This property determines whether the value of the bound field, member, or column is cached.</span></span> <span data-ttu-id="49e9d-182">默认值**SideEffects**中的属性**DatabaseColumnBinding**和**XmlDocumentFieldBinding**类**false**.</span><span class="sxs-lookup"><span data-stu-id="49e9d-182">The default value of the **SideEffects** property in the **DatabaseColumnBinding** and **XmlDocumentFieldBinding** classes is **false**.</span></span> <span data-ttu-id="49e9d-183">默认值**SideEffects**中的属性**ClassMemberBinding**类是**true**。</span><span class="sxs-lookup"><span data-stu-id="49e9d-183">The default value of the **SideEffects** property in the **ClassMemberBinding** class is **true**.</span></span> <span data-ttu-id="49e9d-184">因此，如果 XML 文档字段或数据库表的列是在策略中第二次访问或稍后访问的，则其值从缓存中检索。</span><span class="sxs-lookup"><span data-stu-id="49e9d-184">Therefore, when a field of an XML document or a column of a database table is accessed for the second time or later within the policy, its value is retrieved from the cache.</span></span> <span data-ttu-id="49e9d-185">不过，如果 .NET 对象的成员是第二次访问或稍后访问的，其值从 .NET 对象检索，而不是从缓存中检索。</span><span class="sxs-lookup"><span data-stu-id="49e9d-185">However, when a member of a .NET object is accessed for the second time or later, the value is retrieved from the .NET object, and not from the cache.</span></span> <span data-ttu-id="49e9d-186">设置**SideEffects** .NET 属性**ClassMemberBinding**到**false**将提高性能，因为从缓存中检索字段的值第二次及以上版本。</span><span class="sxs-lookup"><span data-stu-id="49e9d-186">Setting the **SideEffects** property of a .NET **ClassMemberBinding** to **false** will improve performance because the value of the field is retrieved from the cache from the second time onwards.</span></span> <span data-ttu-id="49e9d-187">您只能通过编程方式来完成此步骤。</span><span class="sxs-lookup"><span data-stu-id="49e9d-187">You can only do this programmatically.</span></span> <span data-ttu-id="49e9d-188">业务规则编辑器工具不会公开**SideEffects**属性。</span><span class="sxs-lookup"><span data-stu-id="49e9d-188">The Business Rule Composer tool does not expose the **SideEffects** property.</span></span>  
  
## <a name="instances-and-selectivity"></a><span data-ttu-id="49e9d-189">实例和选择性</span><span class="sxs-lookup"><span data-stu-id="49e9d-189">Instances and Selectivity</span></span>  
 <span data-ttu-id="49e9d-190">**XmlDocumentBinding**， **ClassBinding**，和**DatabaseBinding**类具有两个属性：**实例**和**选择性**。</span><span class="sxs-lookup"><span data-stu-id="49e9d-190">The **XmlDocumentBinding**, **ClassBinding**, and **DatabaseBinding** classes have two properties: **Instances** and **Selectivity**.</span></span> <span data-ttu-id="49e9d-191">值**实例**是预期的工作内存中的类的实例数。</span><span class="sxs-lookup"><span data-stu-id="49e9d-191">The value of **Instances** is the expected number of instances of the class in working memory.</span></span> <span data-ttu-id="49e9d-192">值**选择性**是成功传递的规则条件的类实例的百分比。</span><span class="sxs-lookup"><span data-stu-id="49e9d-192">The value of **Selectivity** is the percentage of the class instances that will successfully pass the rule conditions.</span></span> <span data-ttu-id="49e9d-193">规则引擎使用这些值来优化条件计算，这样在条件计算中最初尽可能使用最少的实例，以后再使用其余的实例。</span><span class="sxs-lookup"><span data-stu-id="49e9d-193">The rule engine uses these values to optimize the condition evaluation so that the fewest possible instances are used in condition evaluations first and then the remaining instances are used.</span></span> <span data-ttu-id="49e9d-194">如果必须事先了解的对象的实例数，请设置**实例**属性与此值会提高性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-194">If you have prior knowledge of the number of instances of the object, setting the **Instances** property to that value would improve performance.</span></span> <span data-ttu-id="49e9d-195">同样，如果必须事先了解这些对象传递条件的百分比，则设置**选择性**属性与此值会提高性能。</span><span class="sxs-lookup"><span data-stu-id="49e9d-195">Similarly, if you have prior knowledge of the percentage of these objects passing the conditions, setting the **Selectivity** property to that value would improve performance.</span></span> <span data-ttu-id="49e9d-196">只能通过编程方式来设置这些参数的值。</span><span class="sxs-lookup"><span data-stu-id="49e9d-196">You can only set values for these parameters programmatically.</span></span> <span data-ttu-id="49e9d-197">业务规则编辑器工具不公开这些属性。</span><span class="sxs-lookup"><span data-stu-id="49e9d-197">The Business Rule Composer tool does not expose them.</span></span>