---
title: 使用规则引擎时的性能注意事项 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 9e9020c2-5152-40f6-940b-d4ce4081f069
caps.latest.revision: 7
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: c24a1c6ffb278d257e16c192e5fc7d827df70e24
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
ms.locfileid: "22266501"
---
# <a name="performance-considerations-when-using-the-rule-engine"></a>使用规则引擎时的性能注意事项
本主题介绍规则引擎在各种情况下以及使用不同的配置/优化参数值时的性能表现。  
  
## <a name="fact-types"></a>事实类型  
 规则引擎访问 .NET 事实所用的时间比访问 XML 事实和数据库事实所用的时间要少。 如果面临在策略中使用 .NET 事实、XML 事实还是数据库事实的情况，应该考虑到，使用 .NET 事实会获得更好的性能。  
  
## <a name="data-table-vs-data-connection-binding"></a>数据表 vs。数据连接绑定  
 当数据集的大小很小 （少于大约 10 行）， **TypedDataTable**绑定更好地执行比**该组**绑定。 大型数据集时 （大于或等于大约 10 行），**该组**绑定更好地执行比**TypedDataTable**绑定。 因此，你应确定是否使用**该组**绑定或**TypedDataTable**绑定基于数据集的估计大小。  
  
## <a name="fact-retrievers"></a>事实检索器  
 你可以编写事实检索器 — 实施标准方法，并通常提供长期和渐变事实到规则引擎在执行该策略之前使用它们的对象。 引擎将缓存这些事实，并在多个执行循环中使用它们。 您应该创建一个事实检索器，它只在第一次调用规则引擎时提交事实，然后在需要时才在内存中更新该事实，而不是每次调用规则引擎时都提交一个静态事实或相当静态的事实。  
  
## <a name="rule-priority"></a>规则的优先级  
 优先级设置的任何一侧的范围规则可以**0**，有了更多具有更高的优先级。 操作按照从最高优先级到最低优先级的顺序执行。 当策略都实现通过使用正向链接行为**断言/更新**调用，链接，可优化通过使用的优先级设置。 例如，假设**Rule2**具有一个值，通过设置的依赖关系**规则 1**。 提供**规则 1**更高的优先级意味着**Rule2**将之后才执行**规则 1**激发和更新的值。 相反，如果**Rule2**是更高的优先级，它可以触发一次，并显示后再次然后激发**规则 1**触发并更新这一事实， **Rule2**条件中使用。 这样可能会也可能不会生成正确的结果，但显然触发两次比只触发一次对性能的影响更大。  
  
## <a name="update-calls"></a>更新调用  
 **更新**函数更新存在于规则引擎，使用内存中并导致在条件中使用更新的事实进行重新求值的所有规则的事实。 **更新**函数调用可能很昂贵，尤其是许多规则需要会由于更新事实数据重新计算。 在有些情况下，可以避免重新计算规则。 例如，考虑以下规则：  
  
 **规则 1:**  
  
```  
IF PurchaseOrder.Amount > 5   
THEN StatusObj.Flag = true; Update(StatusObj)  
```  
  
 **Rule2:**  
  
```  
IF PurchaseOrder.Amount <= 5   
THEN StatusObj.Flag = false; Update(StatusObj)  
```  
  
 策略使用的所有剩余规则**StatusObj.Flag**在其条件。 因此，当**更新**上调用**StatusObj**对象，将会重新计算所有规则。 任意值**量**字段为，除之外的所有规则**规则 1**和**Rule2**两次，计算一次之前**更新**调用，另一次后的**更新**调用。  
  
 相反，你可以设置的值**标志**字段**false**你调用该策略，然后使用仅之前**规则 1**中设置标志的策略。 在这种情况下，**更新**才会调用的值**量**字段大于 5，和**更新**如果量小于或等于 5，则不会调用。 因此，所有规则除**规则 1**和**Rule2**计算两次才的值**量**字段大于 5。  
  
## <a name="use-of-logical-or-operators"></a>使用“逻辑或”运算符  
 规则引擎进行了优化用于执行逻辑**AND**运算符和它重新构造对其分析中分离的标准形式因此，该规则**或**仅在顶级使用运算符。 使用越来越多的逻辑**或**中条件的运算符创建展开规则引擎，分析网络的其他排列，这可能需要长时间来规范化该规则的规则引擎。 以下列表包含此问题的可能解决方法。  
  
-   修改要使规则中分离范式因此，**或**运算符是仅在最高级别。 请注意，开发分离正常业务规则编辑器中的窗体中的规则可能会很棘手。 你可能想要以编程方式创建规则，请考虑。  
  
-   开发执行的帮助程序组件**或**操作并返回一个布尔值，并且在规则中使用该组件。  
  
-   请考虑将规则拆分为多个规则和具有规则检查标志以前执行的规则所设或使用下面的示例中所示，由以前执行的规则断言的对象：  
  
    -   规则 1： 如果 (= = 1 或 = = 3) 然后 b = true  
  
         规则 2： 如果 (b = = true) 然后...  
  
    -   规则 1： 如果 (= = 1 或 = = 3) 然后断言 (新 c())  
  
         规则 2： 如果 (c.flag = = true) 然后...  
  
## <a name="caching-settings"></a>缓存设置  
 规则引擎使用两个缓存。 第一个缓存在更新服务中，第二个缓存在每个 BizTalk 进程中。 初次使用某个策略时，BizTalk 进程从更新服务请求策略信息。 更新服务从规则引擎数据库检索策略信息，对其进行缓存，然后将信息返回 BizTalk 进程。 BizTalk 进程基于该信息创建策略对象，并在关联的规则引擎实例完成策略执行后，将策略对象存储在缓存中。 再次调用同一个策略时，BizTalk 进程重用缓存中的策略对象（如果缓存中有的话）。  
  
 同样，如果 BizTalk 进程从更新服务请求有关策略的信息，更新服务会首先在其缓存中查找策略信息。 更新服务还会每隔 60 秒（一分钟）进行检查，查看是否对数据库中的策略有任何更新。 如果有任何更新，更新服务将检索该信息，将更新的信息进行缓存。  
  
 与这些缓存相关的规则引擎的三个优化参数： **CacheEntries**， **CacheTimeout**，和**PollingInterval**。 您可以在注册表或配置文件中为这些参数指定值。  
  
 值**CacheEntries**是缓存中的最大项数。 默认值**CacheEntries**为 32。 你可能想要的值增加**CacheEntries**参数，以提高在某些情况下的性能。 例如，假设您要重复地使用 40 个策略。 在这种情况下你可能想要的值增加**CacheEntries**为 40 以提高性能。 这样做可以使更新服务在内存中能缓存多达 40 个策略的详细信息。 还可以使 BizTalk 服务在内存中能缓存多达 40 个策略实例。 在 BizTalk 服务的缓存中可能有策略的多个实例。  
  
 值**CacheTimeout**用于更新服务缓存中脱离的条目的时间 （以秒为单位）。 换而言之， **CacheTimeout**值参考了策略的缓存项的保留时间缓存中是否存在任何引用了它。 默认值**CacheTimeout**为 3600 秒 （1 小时）。 这意味着，如果缓存条目没有在一小时之内被引用，就会被删除。 在某些情况下，你可能想要增加**CacheTimeout**值以提高性能。 例如，假设策略每隔两小时调用一次。 可以通过增加的值通过改进性能的策略执行**CacheTimeout**参数大于两个小时的值。  
  
 **PollingInterval**规则引擎的参数在秒的间隔更新服务检查更新的规则引擎数据库中定义的时间。 默认值为**PollingInterval**参数为 60 秒 （1 分钟）。 如果您知道策略根本不更新或者很少更新，可以增加此值以提高性能。  
  
## <a name="sideeffects-property"></a>SideEffects 属性  
 **ClassMemberBinding**， **DatabaseColumnBinding**，和**XmlDocumentFieldBinding**类具有名为的属性**SideEffects**. 此属性确定是否缓存绑定字段的值、成员或列。 默认值**SideEffects**中的属性**DatabaseColumnBinding**和**XmlDocumentFieldBinding**类**false**. 默认值**SideEffects**中的属性**ClassMemberBinding**类是**true**。 因此，如果 XML 文档字段或数据库表的列是在策略中第二次访问或稍后访问的，则其值从缓存中检索。 不过，如果 .NET 对象的成员是第二次访问或稍后访问的，其值从 .NET 对象检索，而不是从缓存中检索。 设置**SideEffects** .NET 属性**ClassMemberBinding**到**false**将提高性能，因为从缓存中检索字段的值第二次及以上版本。 您只能通过编程方式来完成此步骤。 业务规则编辑器工具不会公开**SideEffects**属性。  
  
## <a name="instances-and-selectivity"></a>实例和选择性  
 **XmlDocumentBinding**， **ClassBinding**，和**DatabaseBinding**类具有两个属性：**实例**和**选择性**。 值**实例**是预期的工作内存中的类的实例数。 值**选择性**是成功传递的规则条件的类实例的百分比。 规则引擎使用这些值来优化条件计算，这样在条件计算中最初尽可能使用最少的实例，以后再使用其余的实例。 如果必须事先了解的对象的实例数，请设置**实例**属性与此值会提高性能。 同样，如果必须事先了解这些对象传递条件的百分比，则设置**选择性**属性与此值会提高性能。 只能通过编程方式来设置这些参数的值。 业务规则编辑器工具不公开这些属性。