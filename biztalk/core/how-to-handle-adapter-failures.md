---
title: 如何处理适配器故障 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: 12
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 863ad82ce429bebb6bb5eb3ce671ca493830e8f4
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65337538"
---
# <a name="how-to-handle-adapter-failures"></a><span data-ttu-id="094aa-102">如何处理适配器故障</span><span class="sxs-lookup"><span data-stu-id="094aa-102">How to Handle Adapter Failures</span></span>
<span data-ttu-id="094aa-103">一般情况下，适配器应挂起无法处理的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-103">In general, adapters should suspend messages that they cannot process.</span></span> <span data-ttu-id="094aa-104">例如，遇到提交失败的接收适配器通常应挂起消息，尽管决策取决于适配器的用途。</span><span class="sxs-lookup"><span data-stu-id="094aa-104">For example, a receive adapter that experiences a submit failure should typically suspend the messages, although this decision depends upon the purpose of the adapter.</span></span> <span data-ttu-id="094aa-105">此外，还有关于失败的处理的安全注意事项。</span><span class="sxs-lookup"><span data-stu-id="094aa-105">There are also security considerations around handling failures.</span></span> <span data-ttu-id="094aa-106">例如，如果适配器自动挂起所有失败的消息，适配器可能会受到拒绝服务攻击，导致 BizTalk Server 挂起队列向上填充。</span><span class="sxs-lookup"><span data-stu-id="094aa-106">For example, if an adapter automatically suspends all failed messages, the adapter might be open to a denial-of-service attack that causes the BizTalk Server Suspended queue to fill up.</span></span>  <span data-ttu-id="094aa-107">某些适配器，如 HTTP、 可以返回到客户端，该值指示已拒绝该请求的失败代码。</span><span class="sxs-lookup"><span data-stu-id="094aa-107">Some adapters, such as HTTP, can return a failure code to the client indicating that the request has been rejected.</span></span> <span data-ttu-id="094aa-108">对于这些类型的适配器通常最好返回失败代码而不挂起消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-108">For these types of adapters it often makes sense to return a failure code rather than suspend the message.</span></span> <span data-ttu-id="094aa-109">通常，发送适配器仅挂起消息后主要和次要传输已用尽所有的重试次数。</span><span class="sxs-lookup"><span data-stu-id="094aa-109">Typically send adapters only suspend messages after all of the retries have been exhausted for both primary and secondary transports.</span></span>  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a><span data-ttu-id="094aa-110">将错误处理与单个操作，而不包含该操作的批处理相关联</span><span class="sxs-lookup"><span data-stu-id="094aa-110">Associate Error Processing with an Individual Operation and Not with the Batch That Contains the Operation</span></span>  
 <span data-ttu-id="094aa-111">批处理中适配器的消息应为适配器的用户看不到。</span><span class="sxs-lookup"><span data-stu-id="094aa-111">The batching of messages within an adapter should be invisible to the user of the adapter.</span></span> <span data-ttu-id="094aa-112">这意味着在批处理中的某一操作失败不应影响任何方式中的任何其他操作。</span><span class="sxs-lookup"><span data-stu-id="094aa-112">This means that the failure of one operation in a batch should not affect any other operation in any way.</span></span> <span data-ttu-id="094aa-113">但是，由于批是原子，因此一个消息的失败会导致错误的批处理，并会处理任何操作。</span><span class="sxs-lookup"><span data-stu-id="094aa-113">However, batches are atomic, so the failure of one message results in an error for the batch, and no operations are processed.</span></span>  
  
 <span data-ttu-id="094aa-114">您编写的代码，它负责处理错误、 重新提交成功的消息，并挂起不成功的。</span><span class="sxs-lookup"><span data-stu-id="094aa-114">You write the code that is responsible for handling the error, resubmitting the successful messages, and suspending the unsuccessful ones.</span></span> <span data-ttu-id="094aa-115">幸运的是，BizTalk Server 提供了一个详细的错误结构，使适配器能够确定具体的失败的操作。</span><span class="sxs-lookup"><span data-stu-id="094aa-115">Fortunately, BizTalk Server provides a detailed error structure that enables your adapter to determine the specific operation that failed.</span></span> <span data-ttu-id="094aa-116">它允许构造进一步的批，在其中重新提交成功的操作，不成功的挂起。</span><span class="sxs-lookup"><span data-stu-id="094aa-116">It permits construction of further batches in which the successful operations are resubmitted and the unsuccessful ones suspended.</span></span>  
  
 <span data-ttu-id="094aa-117">该操作的最终状态不应受适配器内批处理。</span><span class="sxs-lookup"><span data-stu-id="094aa-117">The final state of the operation should not be affected by the batching within the adapter.</span></span>  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a><span data-ttu-id="094aa-118">使用 SetErrorInfo 向 BizTalk Server 报告失败</span><span class="sxs-lookup"><span data-stu-id="094aa-118">Use SetErrorInfo to Report Failure to BizTalk Server</span></span>  
 <span data-ttu-id="094aa-119">如果要挂起一条消息，必须从以前的消息上下文向 BizTalk Server 提供失败信息。</span><span class="sxs-lookup"><span data-stu-id="094aa-119">If you are suspending a message, you must provide failure information to BizTalk Server from the previous message context.</span></span> <span data-ttu-id="094aa-120">BizTalk Server 提供的错误报告使用的功能**SetErrorInfo**方法同时**IBaseMessage**并**ITransportProxy**接口。</span><span class="sxs-lookup"><span data-stu-id="094aa-120">BizTalk Server provides error reporting capabilities using the **SetErrorInfo** method on both the **IBaseMessage** and **ITransportProxy** interfaces.</span></span> <span data-ttu-id="094aa-121">您可以报告错误，如下所示：</span><span class="sxs-lookup"><span data-stu-id="094aa-121">You can report errors as follows:</span></span>  
  
- <span data-ttu-id="094aa-122">异常使用时处理消息时失败，则设置**SetErrorInfo (Exception e)** 消息 (**IBaseMessage**) 被挂起。</span><span class="sxs-lookup"><span data-stu-id="094aa-122">When a failure occurs while processing a message, set the exception using **SetErrorInfo(Exception e)** on the message (**IBaseMessage**) to be suspended.</span></span> <span data-ttu-id="094aa-123">这允许引擎保留该错误和消息以便以后诊断，并将其记录到事件日志，向管理员发出警报。</span><span class="sxs-lookup"><span data-stu-id="094aa-123">This allows the engine to preserve the error with the message for later diagnosis and logs it to the event log to alert the administrator.</span></span>  
  
- <span data-ttu-id="094aa-124">如果错误是在初始化或内部簿记过程 （不在消息处理） 遇到应调用**SetErrorInfo (Exception e)** 上**ITransportProxy**指针传递给您在初始化过程中。</span><span class="sxs-lookup"><span data-stu-id="094aa-124">If you encounter an error during initialization or internal bookkeeping (not during message processing) you should call **SetErrorInfo(Exception e)** on the **ITransportProxy** pointer that was passed to you during initialization.</span></span> <span data-ttu-id="094aa-125">如果您的适配器基于 BaseAdapter 实现，应始终有权访问此指针。</span><span class="sxs-lookup"><span data-stu-id="094aa-125">If your adapter is based on the BaseAdapter implementation, you should always have access to this pointer.</span></span> <span data-ttu-id="094aa-126">否则，应确保其缓存。</span><span class="sxs-lookup"><span data-stu-id="094aa-126">Otherwise, you should be certain that you cache it.</span></span>  
  
  <span data-ttu-id="094aa-127">报告与错误消息写入到事件日志中这些方法结果的错误。</span><span class="sxs-lookup"><span data-stu-id="094aa-127">Reporting an error with either of these methods results in the error message being written to the event log.</span></span> <span data-ttu-id="094aa-128">该错误关联相关的消息，如果可以为此，至关重要。</span><span class="sxs-lookup"><span data-stu-id="094aa-128">It is important that you associate the error with the related message if you are able to do so.</span></span>  
  
## <a name="handle-a-database-offline-condition"></a><span data-ttu-id="094aa-129">处理数据库脱机的情况</span><span class="sxs-lookup"><span data-stu-id="094aa-129">Handle a Database-Offline Condition</span></span>  
 <span data-ttu-id="094aa-130">如果其中一个 BizTalk Server 数据库处于脱机状态，BizTalk 服务将回收其自身。</span><span class="sxs-lookup"><span data-stu-id="094aa-130">If one of the BizTalk Server databases goes offline, the BizTalk service recycles itself.</span></span> <span data-ttu-id="094aa-131">消息引擎会尽量在回收服务之前关闭所有接收位置。</span><span class="sxs-lookup"><span data-stu-id="094aa-131">The Messaging Engine makes a best effort to shut down all of the receive locations before recycling the service.</span></span> <span data-ttu-id="094aa-132">如果花费的时间超过 60 秒，则服务将中断。</span><span class="sxs-lookup"><span data-stu-id="094aa-132">If this takes longer than 60 seconds, the service terminates.</span></span> <span data-ttu-id="094aa-133">因为引擎会执行事务处理，这不会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="094aa-133">Because the engine is transacted, this does not cause data loss.</span></span>  
  
 <span data-ttu-id="094aa-134">通过使用键，可以在注册表中优化此超时：</span><span class="sxs-lookup"><span data-stu-id="094aa-134">This time-out can be tuned in the registry by using the key:</span></span>  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 <span data-ttu-id="094aa-135">对于独立适配器，因为 BizTalk Server 不拥有该过程中，接收位置将停用一个 BizTalk Server 数据库处于脱机状态。</span><span class="sxs-lookup"><span data-stu-id="094aa-135">For isolated adapters, because BizTalk Server does not own the process, the receive locations are disabled when one of the BizTalk Server databases goes offline.</span></span> <span data-ttu-id="094aa-136">数据库恢复联机后这些接收位置会重新启用。</span><span class="sxs-lookup"><span data-stu-id="094aa-136">After the database comes back online those receive locations are re-enabled.</span></span>  
  
## <a name="write-to-the-event-log"></a><span data-ttu-id="094aa-137">写入事件日志</span><span class="sxs-lookup"><span data-stu-id="094aa-137">Write to the Event Log</span></span>  
 <span data-ttu-id="094aa-138">适配器可以通过使用写入事件日志条目**IBTTransportProxy**接口传入异常。</span><span class="sxs-lookup"><span data-stu-id="094aa-138">The adapter can write event log entries by using the **IBTTransportProxy** interface passing in an exception.</span></span> <span data-ttu-id="094aa-139">用本机代码开发的适配器需要传入**IErrorInfo**接口， **IBTTransportProxy.SetErrorInfo (异常** `e` **)**。</span><span class="sxs-lookup"><span data-stu-id="094aa-139">Adapters developed in native code need to pass in an **IErrorInfo** interface, **IBTTransportProxy.SetErrorInfo( Exception** `e` **)**.</span></span>  
  
 <span data-ttu-id="094aa-140">消息引擎向事件日志写入代表事件适配器等消息传输失败后的适配器重试将一条消息移至其备份传输或挂起消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-140">The Messaging Engine writes to the event log on behalf of the adapter for events such as when an adapter retries a message after transmission failure, moves a message to its backup transport, or suspends a message.</span></span> <span data-ttu-id="094aa-141">类似这样的操作，适配器只需要调用 API 之前对消息设置异常。</span><span class="sxs-lookup"><span data-stu-id="094aa-141">For operations such as these the adapter only needs to set the exception on the message before calling the API.</span></span> <span data-ttu-id="094aa-142">下面的代码段演示了这一点：</span><span class="sxs-lookup"><span data-stu-id="094aa-142">The following code fragment demonstrates this:</span></span>  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a><span data-ttu-id="094aa-143">处理特定于接收的批错误</span><span class="sxs-lookup"><span data-stu-id="094aa-143">Handle Receive-Specific Batch Errors</span></span>  
  
### <a name="handle-receive-failures"></a><span data-ttu-id="094aa-144">处理接收失败</span><span class="sxs-lookup"><span data-stu-id="094aa-144">Handle Receive Failures</span></span>  
 <span data-ttu-id="094aa-145">适配器向 BizTalk Server 提交操作 （或一批操作） 时可以有多种原因导致失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-145">When an adapter submits an operation (or batch of operations) to BizTalk Server there can be various reasons for failure.</span></span> <span data-ttu-id="094aa-146">两项最重要的是：</span><span class="sxs-lookup"><span data-stu-id="094aa-146">The two most significant are:</span></span>  
  
- <span data-ttu-id="094aa-147">接收管道失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-147">The receive pipeline failed.</span></span>  
  
- <span data-ttu-id="094aa-148">发布消息时发生路由失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-148">A routing failure occurred while publishing a message.</span></span>  
  
  <span data-ttu-id="094aa-149">消息引擎会自动尝试挂起消息时获取接收管道故障。</span><span class="sxs-lookup"><span data-stu-id="094aa-149">The Messaging Engine automatically tries to suspend the message when it gets a receive pipeline failure.</span></span> <span data-ttu-id="094aa-150">挂起操作可能始终无法成功。</span><span class="sxs-lookup"><span data-stu-id="094aa-150">The suspend operation may not always be successful.</span></span> <span data-ttu-id="094aa-151">例如，如果消息引擎发布消息时遭遇路由失败，然后该引擎不会不甚至尝试挂起消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-151">For example, if the Messaging Engine hits a routing failure while publishing a message, then the engine does not even try to suspend the message.</span></span>  
  
  <span data-ttu-id="094aa-152">始终是可能一条消息将失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-152">It is always possible that a message will fail.</span></span> <span data-ttu-id="094aa-153">在这种情况下，适配器应显式调用**MoveToSuspendQ** API，应尝试挂起消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-153">In such a situation, the adapter should explicitly call the **MoveToSuspendQ** API and should try to suspend the message.</span></span> <span data-ttu-id="094aa-154">当适配器尝试挂起消息时，应是以下之一：</span><span class="sxs-lookup"><span data-stu-id="094aa-154">When an adapter tries to suspend a message, one of the following should be true:</span></span>  
  
- <span data-ttu-id="094aa-155">应暂停的同一个消息对象适配器提交 （推荐）。</span><span class="sxs-lookup"><span data-stu-id="094aa-155">The same message object that the adapter submitted (recommended) should be suspended.</span></span>  
  
- <span data-ttu-id="094aa-156">如果适配器必须创建新的消息，然后它应设置指针的新消息的消息上下文为最初提交的消息的消息上下文。</span><span class="sxs-lookup"><span data-stu-id="094aa-156">If the adapter has to create a new message, then it should set the message context of the new message with the pointer to the message context of the message that was originally submitted.</span></span> <span data-ttu-id="094aa-157">这是因为一条消息的消息上下文有很多有关该消息和失败的有价值信息。</span><span class="sxs-lookup"><span data-stu-id="094aa-157">This is because the message context of a message has a lot of valuable information about the message and the failure.</span></span> <span data-ttu-id="094aa-158">若要调试失败的消息，需要使用此信息。</span><span class="sxs-lookup"><span data-stu-id="094aa-158">This information is required to debug the failed message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="094aa-159">如果适配器创建新消息对象，并将它挂起，适配器应指向新的消息对象从旧消息对象复制的错误信息。</span><span class="sxs-lookup"><span data-stu-id="094aa-159">If the adapter creates a new message object and suspends it, the adapter should copy the error information from the old message object to the new message object.</span></span>  
  
 <span data-ttu-id="094aa-160">某些适配器，如与 BizTalk Server 一起提供的 HTTP 适配器不需要该消息被挂起。</span><span class="sxs-lookup"><span data-stu-id="094aa-160">Some adapters, such as the HTTP adapter provided with BizTalk Server, do not require that the message be suspended.</span></span> <span data-ttu-id="094aa-161">这些适配器可以返回给其客户端返回错误。</span><span class="sxs-lookup"><span data-stu-id="094aa-161">These adapters can return an error back to their client.</span></span>  
  
#### <a name="causes-of-failure"></a><span data-ttu-id="094aa-162">失败的原因</span><span class="sxs-lookup"><span data-stu-id="094aa-162">Causes of failure</span></span>  
 <span data-ttu-id="094aa-163">失败的简单原因是构造批或时可能发生的错误**ibttransportbatch:: Done**调用。</span><span class="sxs-lookup"><span data-stu-id="094aa-163">Simple causes of failure are the errors that can occur as the batch is constructed or when **IBTTransportBatch::Done** is called.</span></span>  
  
-   <span data-ttu-id="094aa-164">**提交失败。**</span><span class="sxs-lookup"><span data-stu-id="094aa-164">**Submit failure.**</span></span> <span data-ttu-id="094aa-165">**提交**调用有限数量的原因，可能会失败，所有这些都是致命。</span><span class="sxs-lookup"><span data-stu-id="094aa-165">The **Submit** call can fail for a limited number of reasons, and all of them are fatal.</span></span> <span data-ttu-id="094aa-166">由于这些原因包括：</span><span class="sxs-lookup"><span data-stu-id="094aa-166">These reasons include:</span></span>  
  
-   <span data-ttu-id="094aa-167">在 BizTalk Server 进程空间中发生的内存不足错误。</span><span class="sxs-lookup"><span data-stu-id="094aa-167">Out-of-memory errors occurring in the BizTalk Server process space.</span></span>  
  
-   <span data-ttu-id="094aa-168">已从部署删除了架构程序集。</span><span class="sxs-lookup"><span data-stu-id="094aa-168">The schema assembly has been dropped from the deployment.</span></span> <span data-ttu-id="094aa-169">在这种情况下，**提交**含义模糊的错误而失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-169">In this case, the **Submit** fails with a cryptic error.</span></span> <span data-ttu-id="094aa-170">在 MQSeries 适配器中，捕获从 BizTalk Server 的一般失败异常，并在系统事件日志中写入扩展的错误消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-170">In the MQSeries adapter, the generic failure exception from BizTalk Server is caught, and an extended error message is written in the system event log.</span></span> <span data-ttu-id="094aa-171">此消息表明错误的可能的原因之一是，以某种方式从部署删除了架构程序集时。</span><span class="sxs-lookup"><span data-stu-id="094aa-171">This message suggests that one of the possible causes of the error is that the schema assembly has somehow been dropped from the deployment.</span></span>  
  
     <span data-ttu-id="094aa-172">在常规，如果**提交**应尝试挂起消息使用相同的事务将失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-172">In general, if **Submit** fails you should try to suspend the message using the same transaction.</span></span>  
  
-   <span data-ttu-id="094aa-173">**Ibttransportbatch:: Done 失败。**</span><span class="sxs-lookup"><span data-stu-id="094aa-173">**IBTTransportBatch::Done failure.**</span></span> <span data-ttu-id="094aa-174">**Ibttransportbatch:: Done**调用可能会由于多种原因之一失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-174">The **IBTTransportBatch::Done** call can fail for one of several reasons.</span></span> <span data-ttu-id="094aa-175">一般情况下，您始终应尝试挂起操作，然后结束事务，仅当该操作失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-175">In general, you should always attempt one suspend operation and end the transaction only if that fails.</span></span> <span data-ttu-id="094aa-176">可能会收到从故障中的错误代码之一**ibttransportbatch:: Done**是 BizTalk Server 正在尝试关闭的情况下。</span><span class="sxs-lookup"><span data-stu-id="094aa-176">One of the error codes you might receive from the failure of **IBTTransportBatch::Done** is that BizTalk Server is trying to shut down.</span></span> <span data-ttu-id="094aa-177">在这种情况下，应只是结束事务，并将它，因为**Terminate**调用可能正在并发发生。</span><span class="sxs-lookup"><span data-stu-id="094aa-177">In this case, you should just end the transaction and leave it because the **Terminate** call is probably happening concurrently.</span></span> <span data-ttu-id="094aa-178">成功构造了批并成功执行时，会出现其他情况**ibttransportbatch:: Done**。</span><span class="sxs-lookup"><span data-stu-id="094aa-178">Other scenarios occur when you have successfully constructed the batch and successfully executed **IBTTransportBatch::Done**.</span></span> <span data-ttu-id="094aa-179">在这些情况下，在返回的错误**BatchComplete** ，适配器必须确定要执行的操作与之和。</span><span class="sxs-lookup"><span data-stu-id="094aa-179">In these cases, the errors are returned in **BatchComplete** and the adapter must determine what to do with them.</span></span> <span data-ttu-id="094aa-180">本部分的其余部分处理这种情况。</span><span class="sxs-lookup"><span data-stu-id="094aa-180">The rest of this section deals with this case.</span></span>  
  
#### <a name="processing-batchcomplete-errors"></a><span data-ttu-id="094aa-181">处理 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="094aa-181">Processing BatchComplete errors</span></span>  
 <span data-ttu-id="094aa-182">**BatchComplete**是由适配器调用的 BizTalk 服务器，用于指示批处理操作的完成状态时提供的回调。</span><span class="sxs-lookup"><span data-stu-id="094aa-182">**BatchComplete** is a callback provided by the adapter that is invoked by BizTalk Server to indicate the completion status of a batch operation.</span></span>  
  
 <span data-ttu-id="094aa-183">最重要的参数传递给**BatchComplete**是批状态`hResult`。</span><span class="sxs-lookup"><span data-stu-id="094aa-183">The most important parameter passed to **BatchComplete** is the batch status `hResult`.</span></span> <span data-ttu-id="094aa-184">这指示成功或失败的批处理。</span><span class="sxs-lookup"><span data-stu-id="094aa-184">This indicates success or failure for the batch.</span></span> <span data-ttu-id="094aa-185">如果批失败，则表示没有任何批处理中的操作已成功。</span><span class="sxs-lookup"><span data-stu-id="094aa-185">If the batch failed, it means that none of the operations in the batch succeeded.</span></span> <span data-ttu-id="094aa-186">该适配器将遍历批状态结构，并确定失败的消息 (我们称之为*批的筛选*)。</span><span class="sxs-lookup"><span data-stu-id="094aa-186">The adapter goes through the batch status structure and determines which messages failed (this is known as *filtering the batch*).</span></span>  
  
#### <a name="nontransactional-batchcomplete-errors"></a><span data-ttu-id="094aa-187">非事务性 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="094aa-187">Nontransactional BatchComplete errors</span></span>  
 <span data-ttu-id="094aa-188">对于非事务性适配器，您必须选择您的响应为在失败时**SubmitMessage**/**SubmitRequestMessage**或**SubmitResponseMessage**操作。</span><span class="sxs-lookup"><span data-stu-id="094aa-188">For nontransactional adapters, you must choose your response if a failure occurs for a **SubmitMessage**/**SubmitRequestMessage** or **SubmitResponseMessage** operation.</span></span> <span data-ttu-id="094aa-189">适配器通过调用挂起消息的通常**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="094aa-189">Typically adapters suspend the message by calling **MoveToSuspendQ**.</span></span>  
  
 <span data-ttu-id="094aa-190">传递时，始终需要执行以下操作：**DeleteMessage**， **MoveToSuspendQ**， **ResubmitMessage**。</span><span class="sxs-lookup"><span data-stu-id="094aa-190">The following operations are always expected to pass: **DeleteMessage**, **MoveToSuspendQ**, **ResubmitMessage**.</span></span> <span data-ttu-id="094aa-191">如果这些操作失败，则通常意味着在适配器中是有 bug。</span><span class="sxs-lookup"><span data-stu-id="094aa-191">If these operations fail, it typically means that there is a bug in the adapter.</span></span> <span data-ttu-id="094aa-192">不需要编写代码来处理在这些情况下失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-192">You do not have to write code to handle a failure in these cases.</span></span> <span data-ttu-id="094aa-193">但是如果批失败，因为另一个操作失败，则这些操作必须在新批中重新执行。</span><span class="sxs-lookup"><span data-stu-id="094aa-193">However if the batch failed because another operation failed, then these operations must be re-executed in a fresh batch.</span></span>  
  
 <span data-ttu-id="094aa-194">如果适配器调用**MovetoBackupTransport**并失败 （由于没有备份传输），然后应调用该适配器**MoveToSuspendQ**以挂起消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-194">If the adapter calls **MovetoBackupTransport** and that fails (because there was no backup transport), then the adapter should call **MoveToSuspendQ** to suspend the message.</span></span>  
  
#### <a name="transactional-batchcomplete-errors"></a><span data-ttu-id="094aa-195">事务性 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="094aa-195">Transactional BatchComplete errors</span></span>  
 <span data-ttu-id="094aa-196">当您提交到 BizTalk Server 使用适配器创建的事务的批处理时，应遵循这两种方案之一：</span><span class="sxs-lookup"><span data-stu-id="094aa-196">When you submit batches to BizTalk Server using a transaction created by the adapter, you should follow one of these two scenarios:</span></span>  
  
-   <span data-ttu-id="094aa-197">**使用单消息批。**</span><span class="sxs-lookup"><span data-stu-id="094aa-197">**Use single-message batches.**</span></span> <span data-ttu-id="094aa-198">向 BizTalk Server 发送单消息批。</span><span class="sxs-lookup"><span data-stu-id="094aa-198">Send a single-message batch to BizTalk Server.</span></span> <span data-ttu-id="094aa-199">如果这条消息失败，然后，可以合法发送 BizTalk Server 在同一个事务，第二个批处理，但必须将有问题的消息移动到挂起队列，而无需重新提交它。</span><span class="sxs-lookup"><span data-stu-id="094aa-199">If that single message fails, then you can legally send BizTalk Server a second batch under the same transaction, but you must move the offending message to the Suspended queue rather than resubmitting it.</span></span> <span data-ttu-id="094aa-200">删除失败的消息后，第二个批的提交应该会成功。</span><span class="sxs-lookup"><span data-stu-id="094aa-200">After the failed message is removed, the submission of the second batch should succeed.</span></span> <span data-ttu-id="094aa-201">发生这种情况时 BizTalk Server 确认可以提交事务后第二个批已成功完成。</span><span class="sxs-lookup"><span data-stu-id="094aa-201">After that occurs you can commit the transaction when BizTalk Server confirms that the second batch was successful.</span></span> <span data-ttu-id="094aa-202">如果第二个批失败，适配器必须中止该事务，或查找其他位置以存放该消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-202">If the second batch fails, the adapter must abort the transaction, or find somewhere else to place that message.</span></span> <span data-ttu-id="094aa-203">在此方案中，可能会立即严重的性能问题由于事务回滚处理。</span><span class="sxs-lookup"><span data-stu-id="094aa-203">In this scenario, you immediately take a significant performance hit due to transaction rollback processing.</span></span>  
  
     <span data-ttu-id="094aa-204">有一些技巧，可用于提高适配器的性能。</span><span class="sxs-lookup"><span data-stu-id="094aa-204">There are some techniques that you can use to improve the performance of the adapter.</span></span> <span data-ttu-id="094aa-205">例如，MQSeries 适配器动态调整其方法在运行时。</span><span class="sxs-lookup"><span data-stu-id="094aa-205">For example, the MQSeries adapter adjusts its approach dynamically at run time.</span></span> <span data-ttu-id="094aa-206">使用 100 个消息批运行它。</span><span class="sxs-lookup"><span data-stu-id="094aa-206">It runs with 100-message batches.</span></span> <span data-ttu-id="094aa-207">如果它遇到错误时，它必须结束该批，但它可以将其切换到单消息批，在短时间以错误的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-207">If it hits an error, it must end the batch, but it switches to single-message batches for a short time as it gets past the bad message.</span></span> <span data-ttu-id="094aa-208">然后还原为 100 个消息批。</span><span class="sxs-lookup"><span data-stu-id="094aa-208">It then reverts to 100-message batches.</span></span> <span data-ttu-id="094aa-209">如果再次遇到错误，会再次降低。</span><span class="sxs-lookup"><span data-stu-id="094aa-209">If it hits the error again, it slows down again.</span></span>  
  
-   <span data-ttu-id="094aa-210">**使用抢先挂起功能。**</span><span class="sxs-lookup"><span data-stu-id="094aa-210">**Use preemptive suspension.**</span></span> <span data-ttu-id="094aa-211">构造一个在其中抢先挂起错误消息的多消息批次。</span><span class="sxs-lookup"><span data-stu-id="094aa-211">Construct a multi-message batch in which the erroneous messages are preemptively suspended.</span></span> <span data-ttu-id="094aa-212">批处理包含多种**提交**并**MoveToSuspendQ**操作，并为第一个和仅在事务下的批处理。</span><span class="sxs-lookup"><span data-stu-id="094aa-212">The batch contains a mix of **Submit** and **MoveToSuspendQ** operations, and is the first and only batch under the transaction.</span></span> <span data-ttu-id="094aa-213">它应成功，因为抢先挂起错误数据，并可以 （在等待从 BizTalk Server 接收确认） 之后提交事务。</span><span class="sxs-lookup"><span data-stu-id="094aa-213">It should succeed because the bad data was preemptively suspended, and the transaction can be committed (after waiting to receive the confirmation from BizTalk Server).</span></span>  
  
     <span data-ttu-id="094aa-214">这看起来好象需要了解以后的但已在 MSMQ 适配器使用此方法。</span><span class="sxs-lookup"><span data-stu-id="094aa-214">This might seem to require looking into the future, but this technique has been used in the MSMQ adapter.</span></span> <span data-ttu-id="094aa-215">它依赖于具有唯一的消息 Id。</span><span class="sxs-lookup"><span data-stu-id="094aa-215">It depends on having reliably unique message IDs.</span></span> <span data-ttu-id="094aa-216">适配器会构造一批消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-216">This adapter constructs a batch of messages.</span></span> <span data-ttu-id="094aa-217">如果出现任何错误，它将回滚该事务 （并因此批处理），但会记住临时数据结构中的消息 ID。</span><span class="sxs-lookup"><span data-stu-id="094aa-217">If anything fails it rolls back the transaction (and therefore the batch), but remembers the message ID in a temporary data structure.</span></span> <span data-ttu-id="094aa-218">（若要防止此结构无限增长，在其中的项后被删除一些固定的时间延迟。）每个批次提交之前，适配器检查错误消息 Id 的列表。</span><span class="sxs-lookup"><span data-stu-id="094aa-218">(To prevent this structure from growing indefinitely, items in it are removed after some fixed time delay.) Before each batch is submitted, the adapter checks the list of bad message IDs.</span></span> <span data-ttu-id="094aa-219">如果它发现一个，它知道该消息将失败 （因为它未在过去一次），并会抢先挂起它而不是尝试将其提交。</span><span class="sxs-lookup"><span data-stu-id="094aa-219">If it sees one, it knows that message will fail (because it failed once in the past), and preemptively suspends it rather than trying to submit it.</span></span>  
  
     <span data-ttu-id="094aa-220">不是每个适配器都有唯一的消息 ID，并不大可能具有一个事务性存储。</span><span class="sxs-lookup"><span data-stu-id="094aa-220">Not every adapter has a reliably unique message ID, and a transactional store is less likely to have one.</span></span> <span data-ttu-id="094aa-221">因此，很多事务性适配器被限制为发送单消息批。</span><span class="sxs-lookup"><span data-stu-id="094aa-221">Because of this, many transactional adapters are restricted to sending single-message batches.</span></span>  
  
#### <a name="processing-other-errors"></a><span data-ttu-id="094aa-222">处理其他错误</span><span class="sxs-lookup"><span data-stu-id="094aa-222">Processing other errors</span></span>  
 <span data-ttu-id="094aa-223">在所有其他情况下 （如挂起消息失败），适配器必须结束事务。</span><span class="sxs-lookup"><span data-stu-id="094aa-223">In all other cases (such as failures in suspending messages), the adapter must end the transaction.</span></span> <span data-ttu-id="094aa-224">任何其他结果重复或已删除的消息中。</span><span class="sxs-lookup"><span data-stu-id="094aa-224">Any other outcome results in either duplicate or dropped messages.</span></span>  
  
 <span data-ttu-id="094aa-225">适配器可以只要它应中止事务，如果某一批失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-225">Whenever the adapter can, it should abort the transaction if a batch fails.</span></span> <span data-ttu-id="094aa-226">但是，在其中适配器无法中止事务的方案。</span><span class="sxs-lookup"><span data-stu-id="094aa-226">However there are scenarios where the adapter cannot abort the transaction.</span></span> <span data-ttu-id="094aa-227">在这种情况下它应挂起使用同一个事务的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-227">In such a scenario it should suspend the message using the same transaction.</span></span>  
  
#### <a name="processing-errors-on-transactional-receive"></a><span data-ttu-id="094aa-228">处理事务性接收错误</span><span class="sxs-lookup"><span data-stu-id="094aa-228">Processing errors on transactional receive</span></span>  
 <span data-ttu-id="094aa-229">常见的事务处理模式是发生错误时结束事务。</span><span class="sxs-lookup"><span data-stu-id="094aa-229">A common transactional processing pattern is to end a transaction when an error occurs.</span></span> <span data-ttu-id="094aa-230">在这种情况下的所有内容返回到其以前的状态，不会丢失数据。</span><span class="sxs-lookup"><span data-stu-id="094aa-230">In this case everything returns to its previous state and no data is lost.</span></span> <span data-ttu-id="094aa-231">但是，如果您正在使用事务性源 （例如，从临时表在数据库中，一次请求一行或从 MQSeries 或 MSMQ 这样的队列产品一次提取一条消息） 中的数据，则这可能不是足够。</span><span class="sxs-lookup"><span data-stu-id="094aa-231">However, if you are consuming data from a transactional feed (for example, pulling a row at a time from a staging table in a database, or pulling one message at a time from a queuing product like MQSeries or MSMQ), then this might not be enough.</span></span> <span data-ttu-id="094aa-232">如果只是结束事务并返回并获得相同的数据同样，相同的错误可能发生的并且系统会进入重复的循环。</span><span class="sxs-lookup"><span data-stu-id="094aa-232">If you simply end the transaction and go back and pick up the same data again, the same error is likely to occur and the system becomes stuck in a repeated loop.</span></span>  
  
 <span data-ttu-id="094aa-233">SQL 适配器的 BizTalk Server 的早期版本中附带了此行为。</span><span class="sxs-lookup"><span data-stu-id="094aa-233">The SQL adapter in an earlier version of BizTalk Server shipped with this behavior.</span></span> <span data-ttu-id="094aa-234">但是，发行后不久，适配器的行为已更改尝试挂起失败的消息并提交事务。</span><span class="sxs-lookup"><span data-stu-id="094aa-234">However, soon after release the adapter behavior was changed to attempt to suspend a failed message and commit the transaction.</span></span> <span data-ttu-id="094aa-235">将一条消息移到同一事务下的挂起队列，然后提交事务保存中丢失的数据，还允许适配器以绕过错误数据。</span><span class="sxs-lookup"><span data-stu-id="094aa-235">Moving a message to the Suspended queue under the same transaction and then committing the transaction saves the data from being lost and also allows the adapter to get past bad data.</span></span>  
  
 <span data-ttu-id="094aa-236">当适配器的接收部分传递一条错误消息，以响应**提交**消息操作，适配器应处理该错误并将消息移至挂起队列。</span><span class="sxs-lookup"><span data-stu-id="094aa-236">When the receive portion of an adapter is passed an error message in response to a **Submit** message operation, the adapter should process that error and move the message to the Suspended queue.</span></span>  
  
 <span data-ttu-id="094aa-237">在事务性批处理中的适配器已创建的事务对象，并且事务下提交了消息的情况下，适配器应以逻辑方式将消息移到同一事务下的挂起队列发生故障时。</span><span class="sxs-lookup"><span data-stu-id="094aa-237">In the case of transactional batches in which the adapter has created the transaction object and submits messages under the transaction, the adapter should logically move the message to the Suspended queue under the same transaction when failures occur.</span></span> <span data-ttu-id="094aa-238">事务可确保未删除数据，并将导致错误甚至数据应不会被删除。</span><span class="sxs-lookup"><span data-stu-id="094aa-238">The transaction ensures that data is not dropped, and even data that is causing an error should never be dropped.</span></span>  
  
### <a name="handle-messages-without-subscriptions"></a><span data-ttu-id="094aa-239">处理没有订阅的消息</span><span class="sxs-lookup"><span data-stu-id="094aa-239">Handle Messages without Subscriptions</span></span>  
 <span data-ttu-id="094aa-240">BizTalk Server 不接受一条消息，如果不存在定义为接受它的订阅在其 MessageBox 数据库中发布。</span><span class="sxs-lookup"><span data-stu-id="094aa-240">BizTalk Server does not accept a message to be published in its MessageBox database if there are no subscriptions defined to accept it.</span></span> <span data-ttu-id="094aa-241">订阅注册由业务流程或发送端口。</span><span class="sxs-lookup"><span data-stu-id="094aa-241">Subscriptions are registered by either orchestrations or send ports.</span></span> <span data-ttu-id="094aa-242">可以定义多个订阅，在这种情况下将消息发送到多个目标。</span><span class="sxs-lookup"><span data-stu-id="094aa-242">Multiple subscriptions can be defined, in which case the message is sent to multiple destinations.</span></span> <span data-ttu-id="094aa-243">如果没有任何订阅，BizTalk Server 会拒绝该消息并不会尝试暂停它。</span><span class="sxs-lookup"><span data-stu-id="094aa-243">If there are no subscriptions, BizTalk Server rejects the message and does not attempt to suspend it.</span></span> <span data-ttu-id="094aa-244">如果适配器没有处理此错误，并显式挂起该消息，然后删除该消息，其数据可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="094aa-244">If the adapter does not handle this error and explicitly suspend the message, then the message is dropped and its data is potentially lost.</span></span> <span data-ttu-id="094aa-245">当然事务性适配器可能结束事务并返回到其目标的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-245">Of course a transactional adapter may end the transaction and return the message to its destination.</span></span>  
  
### <a name="support-seek-with-your-receive-stream"></a><span data-ttu-id="094aa-246">支持 Seek 接收 Stream</span><span class="sxs-lookup"><span data-stu-id="094aa-246">Support Seek with Your Receive Stream</span></span>  
 <span data-ttu-id="094aa-247">接收端流必须支持**Seek**为 BizTalk Server 能够管道失败时挂起消息的方法。</span><span class="sxs-lookup"><span data-stu-id="094aa-247">The receive-side stream must support the **Seek** method for BizTalk Server to be able to suspend the message on a pipeline failure.</span></span> <span data-ttu-id="094aa-248">如果消息流不可查找，则 BizTalk Server 将尝试运行时生成错误**Seek**。</span><span class="sxs-lookup"><span data-stu-id="094aa-248">If the message stream is not seekable, then BizTalk Server generates an error when it tries to run **Seek**.</span></span>  
  
 <span data-ttu-id="094aa-249">在许多情况下支持**Seek**并不容易。</span><span class="sxs-lookup"><span data-stu-id="094aa-249">In many cases supporting **Seek** is not easy.</span></span> <span data-ttu-id="094aa-250">当流式处理网络中的数据，例如，可能会难以返回到的网络资源并重新请求数据。</span><span class="sxs-lookup"><span data-stu-id="094aa-250">When streaming data from a network, for example, it may be difficult to go back to the network resource and request the data again.</span></span>  
  
 <span data-ttu-id="094aa-251">随 BizTalk Server 的多个适配器假脱机到磁盘上的文件上的消息数据保存在同一时间，BizTalk Server 读取数据。</span><span class="sxs-lookup"><span data-stu-id="094aa-251">Several adapters that ship with BizTalk Server spool the message data onto a file on disk at the same time as BizTalk Server reads the data.</span></span> <span data-ttu-id="094aa-252">这允许适配器以使用**Seek**上该文件，如果遇到错误 （在管道处理的消息数据，例如）。</span><span class="sxs-lookup"><span data-stu-id="094aa-252">This allows the adapter to use **Seek** on that file if it encounters an error (in the pipeline processing of the message data, for example).</span></span> <span data-ttu-id="094aa-253">在内部使用该适配器**ReadOnlySeekableStream**包装不可查找的传入流并达到可配置的大小阈值时溢出到磁盘。</span><span class="sxs-lookup"><span data-stu-id="094aa-253">Internally the adapter uses the **ReadOnlySeekableStream** class that wraps an incoming non-seekable stream and overflows to disk when a configurable size threshold is reached.</span></span> <span data-ttu-id="094aa-254">对于小于阈值大小的消息，不会保存该磁盘。</span><span class="sxs-lookup"><span data-stu-id="094aa-254">For messages smaller than the threshold size, the disk is never hit.</span></span>  
  
### <a name="consider-user-configurable-error-handling-options"></a><span data-ttu-id="094aa-255">请考虑使用用户可配置的错误处理选项</span><span class="sxs-lookup"><span data-stu-id="094aa-255">Consider User-Configurable Error-Handling Options</span></span>  
 <span data-ttu-id="094aa-256">有时是未正确响应到错误。</span><span class="sxs-lookup"><span data-stu-id="094aa-256">Sometimes there is no one correct response to an error.</span></span> <span data-ttu-id="094aa-257">在这种情况下，应考虑行为之间进行选择的用户可配置选项。</span><span class="sxs-lookup"><span data-stu-id="094aa-257">In this case, you should consider a user-configurable option to choose between behaviors.</span></span> <span data-ttu-id="094aa-258">MQSeries 适配器执行此操作。</span><span class="sxs-lookup"><span data-stu-id="094aa-258">The MQSeries adapter does this.</span></span>  
  
 <span data-ttu-id="094aa-259">适配器发现错误时挂起消息的问题是 BizTalk Server 中的挂起队列是类似"黑洞。</span><span class="sxs-lookup"><span data-stu-id="094aa-259">The problem with having the adapter suspend messages when it sees an error is that the Suspended queue in BizTalk Server is something of a "black hole."</span></span> <span data-ttu-id="094aa-260">它是相对较容易获取消息队列中，但更难以再次推出。</span><span class="sxs-lookup"><span data-stu-id="094aa-260">It is relatively easy to get messages into the queue, but harder to get them out again.</span></span>  
  
 <span data-ttu-id="094aa-261">适配器的某些用户可能不希望在挂起队列中的任何内容。</span><span class="sxs-lookup"><span data-stu-id="094aa-261">Some users of the adapter might not want anything in the Suspended queue.</span></span> <span data-ttu-id="094aa-262">例如，在 MQSeries 适配器的情况下为用户提供的配置选项执行以下任一操作：</span><span class="sxs-lookup"><span data-stu-id="094aa-262">For example, in the case of the MQSeries adapter, the user is offered a configuration option to do one of the following:</span></span>  
  
-   <span data-ttu-id="094aa-263">设置适配器以结束当前事务并禁用其自身时发现错误。</span><span class="sxs-lookup"><span data-stu-id="094aa-263">Set the adapter to end the current transaction and disable itself when it sees an error.</span></span>  
  
-   <span data-ttu-id="094aa-264">挂起失败的消息并提交该事务。</span><span class="sxs-lookup"><span data-stu-id="094aa-264">Suspend the failed message and commit the transaction.</span></span> <span data-ttu-id="094aa-265">即使在 BizTalk Server 已成功挂起消息时适配器就是这样。</span><span class="sxs-lookup"><span data-stu-id="094aa-265">The adapter does this even when BizTalk Server has successfully suspended the message.</span></span> <span data-ttu-id="094aa-266">此操作满足客户的要求，即使它会导致事件日志不是完全正确。</span><span class="sxs-lookup"><span data-stu-id="094aa-266">This action meets the requirements of the customer even if it causes the event log to not be strictly correct.</span></span>  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a><span data-ttu-id="094aa-267">实现接收排序使用单个线程和等待 BatchComplete</span><span class="sxs-lookup"><span data-stu-id="094aa-267">Implement Receive Ordering by Using a Single Thread and Waiting on BatchComplete</span></span>  
 <span data-ttu-id="094aa-268">BizTalk Server 的界面专为性能和横向扩展通过支持并发的功能。</span><span class="sxs-lookup"><span data-stu-id="094aa-268">The interface to BizTalk Server is designed for performance and the ability to scale out by supporting concurrency.</span></span> <span data-ttu-id="094aa-269">但是，如果你想要接收严格排序的消息 （因为有时需要从 MQSeries 或 MSMQ 这样的消息队列产品中接收消息时），然后必须执行额外操作以禁用某些并发的适配器。</span><span class="sxs-lookup"><span data-stu-id="094aa-269">However, if you want a strictly ordered receive of messages (as is sometimes required when receiving messages from a message queue product like MQSeries or MSMQ), then you must do some additional work in the adapter to disable some of that concurrency.</span></span> <span data-ttu-id="094aa-270">这可以在两个步骤：</span><span class="sxs-lookup"><span data-stu-id="094aa-270">This can be done in two steps:</span></span>  
  
1. <span data-ttu-id="094aa-271">有关在适配器中的所有数据处理，必须使用单个线程。</span><span class="sxs-lookup"><span data-stu-id="094aa-271">You must use a single thread for all the data processing in the adapter.</span></span>  
  
2. <span data-ttu-id="094aa-272">你必须等待 BizTalk Server 彻底处理每个批。</span><span class="sxs-lookup"><span data-stu-id="094aa-272">You must wait for BizTalk Server to completely process each batch.</span></span> <span data-ttu-id="094aa-273">此要求很重要，可以通过使用.NET 线程同步基元实现。</span><span class="sxs-lookup"><span data-stu-id="094aa-273">This requirement is important and can be accomplished by using .NET thread synchronization primitives.</span></span> <span data-ttu-id="094aa-274">例如，使用**AutoResetEvent**，你将：</span><span class="sxs-lookup"><span data-stu-id="094aa-274">For example, using an **AutoResetEvent**, you would:</span></span>  
  
   -   <span data-ttu-id="094aa-275">声明事件对象，并可通过这两个主工作线程访问并**BatchComplete**回调对象。</span><span class="sxs-lookup"><span data-stu-id="094aa-275">Declare the event object where it can be accessed by both the main worker thread and the **BatchComplete** callback object.</span></span>  
  
   -   <span data-ttu-id="094aa-276">像往常一样，在主工作线程上提交到批的消息，但然后调用**AutoResetEvent.Reset**对事件对象对批调用之前**ibttransportbatch:: Done**。</span><span class="sxs-lookup"><span data-stu-id="094aa-276">On the main worker thread, submit the messages to the batch as usual but then call **AutoResetEvent.Reset** on the event object just before the call to the batch **IBTTransportBatch::Done**.</span></span>  
  
   -   <span data-ttu-id="094aa-277">调用**AutoResetEvent.WaitOne**事件对象从同一个线程上。</span><span class="sxs-lookup"><span data-stu-id="094aa-277">Call **AutoResetEvent.WaitOne** on the event object from this same thread.</span></span> <span data-ttu-id="094aa-278">这会阻止主工作线程。</span><span class="sxs-lookup"><span data-stu-id="094aa-278">This causees the main worker thread to block.</span></span> <span data-ttu-id="094aa-279">在中**BatchComplete**从 BizTalk Server 的回调，然后调用**AutoResetEvent.Set**上相同的事件对象，若要取消阻止工作线程，因此它已准备好处理另一条消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-279">In the **BatchComplete** callback from BizTalk Server you then call **AutoResetEvent.Set** on the same event object to unblock the worker thread so it is ready to process another message.</span></span>  
  
   <span data-ttu-id="094aa-280">强烈建议，*接收排序*像这一点成为可配置，因为它会导致性能明显下降。</span><span class="sxs-lookup"><span data-stu-id="094aa-280">It is strongly suggested that *receive ordering* like this be made configurable because it causes significant performance degradation.</span></span> <span data-ttu-id="094aa-281">很多，如果不是大多数用户方案不需要消息的顺序。</span><span class="sxs-lookup"><span data-stu-id="094aa-281">Many, if not most, user scenarios do not require ordering of messages.</span></span> <span data-ttu-id="094aa-282">挂起消息也会中断排序。</span><span class="sxs-lookup"><span data-stu-id="094aa-282">Suspending messages can also break ordering.</span></span> <span data-ttu-id="094aa-283">究竟应该如何操作在这种情况下是依赖于应用程序的因此您的适配器来执行操作的最佳操作是将为用户提供一个配置点。</span><span class="sxs-lookup"><span data-stu-id="094aa-283">Exactly what to do in this case is application-dependent, so the best thing for your adapter to do is to offer the user a configuration point.</span></span>  
  
   <span data-ttu-id="094aa-284">在排序方案中，一些客户表示更，他们希望停止处理，即禁用适配器，而不会中断排序。</span><span class="sxs-lookup"><span data-stu-id="094aa-284">In ordered scenarios, some customers have stated that they would prefer to stop the processing, that is, disable the adapter, rather than break ordering.</span></span> <span data-ttu-id="094aa-285">MQSeries 适配器，支持排序接收，向用户提供此选项。</span><span class="sxs-lookup"><span data-stu-id="094aa-285">The MQSeries adapter, which supports ordered receive, provides this option to the user.</span></span>  
  
## <a name="handle-send-specific-batch-errors"></a><span data-ttu-id="094aa-286">处理特定于发送的批错误</span><span class="sxs-lookup"><span data-stu-id="094aa-286">Handle Send-Specific Batch Errors</span></span>  
  
### <a name="handle-send-retry-and-batching"></a><span data-ttu-id="094aa-287">处理发送重试和批处理</span><span class="sxs-lookup"><span data-stu-id="094aa-287">Handle Send Retry and Batching</span></span>  
 <span data-ttu-id="094aa-288">下面是发送端批处理的典型示例：</span><span class="sxs-lookup"><span data-stu-id="094aa-288">Here is a typical example of send-side batching:</span></span>  
  
- <span data-ttu-id="094aa-289">BizTalk Server 向适配器提供了一批消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-289">BizTalk Server gives a batch of messages to the adapter.</span></span>  
  
- <span data-ttu-id="094aa-290">如果适配器确定，这已提供消息到其目标正确，它将执行在完成重新打开 BizTalk Server，该值指示删除。</span><span class="sxs-lookup"><span data-stu-id="094aa-290">When the adapter determines that it has given the message to its destination correctly, it executes delete back on BizTalk Server indicating that it is done.</span></span> <span data-ttu-id="094aa-291">（像往常一样，数个删除消息可以是任意组成批以提高性能。）</span><span class="sxs-lookup"><span data-stu-id="094aa-291">(As usual, several delete messages can be arbitrarily batched up to improve performance.)</span></span>  
  
  <span data-ttu-id="094aa-292">如果发送端适配器无法处理一条消息，则它可能会执行对该消息的多个操作之一：</span><span class="sxs-lookup"><span data-stu-id="094aa-292">If the send-side adapter fails to process a message, then it may do one of several things with that message:</span></span>  
  
- <span data-ttu-id="094aa-293">适配器通知 BizTalk Server 想要重试某个消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-293">The adapter should tell BizTalk Server that it wants a message retried.</span></span> <span data-ttu-id="094aa-294">BizTalk Server 不会自动重试一条消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-294">BizTalk Server does not automatically retry a message.</span></span> <span data-ttu-id="094aa-295">BizTalk Server 保留计数的重试次数，并可以在消息上下文中看到此计数。</span><span class="sxs-lookup"><span data-stu-id="094aa-295">BizTalk Server keeps a count of the retries, and this count can be seen in the message context.</span></span>  
  
- <span data-ttu-id="094aa-296">适配器可以确定它无法处理的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-296">The adapter may determine that it cannot process a message.</span></span> <span data-ttu-id="094aa-297">在这种情况下，适配器可能会将消息移到下一个传输。</span><span class="sxs-lookup"><span data-stu-id="094aa-297">In this case, the adapter might move the message to the next transport.</span></span> <span data-ttu-id="094aa-298">适配器执行此操作与**MoveToNextTransport**上调用**批处理**对象。</span><span class="sxs-lookup"><span data-stu-id="094aa-298">The adapter does this with the **MoveToNextTransport** call on the **Batch** object.</span></span>  
  
- <span data-ttu-id="094aa-299">适配器可能会将消息移至挂起队列。</span><span class="sxs-lookup"><span data-stu-id="094aa-299">The adapter may move the message to the Suspended queue.</span></span>  
  
  <span data-ttu-id="094aa-300">适配器可以确定该消息会发生什么情况。</span><span class="sxs-lookup"><span data-stu-id="094aa-300">The adapter determines what happens to the message.</span></span> <span data-ttu-id="094aa-301">但是，建议让适配器行为以一致的方式，因为这样可以更轻松地支持 BizTalk Server 安装。</span><span class="sxs-lookup"><span data-stu-id="094aa-301">However, it is recommended that you have adapters behave in a consistent manner because this makes a BizTalk Server installation easier to support.</span></span>  
  
  <span data-ttu-id="094aa-302">强烈建议适配器具有下述行为。</span><span class="sxs-lookup"><span data-stu-id="094aa-302">It is highly recommended that adapters behave as described below.</span></span> <span data-ttu-id="094aa-303">与 BizTalk Server 一起提供的适配器的行为如下。</span><span class="sxs-lookup"><span data-stu-id="094aa-303">The adapters shipped with BizTalk Server behave like this.</span></span>  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a><span data-ttu-id="094aa-304">处理一批中的发送错误的推荐行为</span><span class="sxs-lookup"><span data-stu-id="094aa-304">Recommended Behavior for Handling Send Errors in a Batch</span></span>  
 <span data-ttu-id="094aa-305">发送适配器接收某些消息，并将其提交给 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="094aa-305">The send adapter receives some messages and submits them to BizTalk Server.</span></span>  
  
 <span data-ttu-id="094aa-306">为每个成功的消息，适配器应删除该消息在 BizTalk Server 上。</span><span class="sxs-lookup"><span data-stu-id="094aa-306">For each successful message the adapter should delete that message on BizTalk Server.</span></span> <span data-ttu-id="094aa-307">返回到 BizTalk Server 的所有通信均都通过批处理，并可以组成批删除。</span><span class="sxs-lookup"><span data-stu-id="094aa-307">All communication back to BizTalk Server is done through batches, and the deletes can be batched up.</span></span> <span data-ttu-id="094aa-308">它们无需将在适配器创建 BizTalk Server 在同一个批处理。</span><span class="sxs-lookup"><span data-stu-id="094aa-308">They do not have to be the same batch that BizTalk Server created on the adapter.</span></span> <span data-ttu-id="094aa-309">如果有任何响应消息 （如在 SolicitResponse 方案），则他们应已提交回 BizTalk Server （使用 SubmitResponse) 以及相关删除。</span><span class="sxs-lookup"><span data-stu-id="094aa-309">If there are any response messages (as in a SolicitResponse scenario), then they should be submitted back to BizTalk Server (with SubmitResponse) along with the associated delete.</span></span>  
  
- <span data-ttu-id="094aa-310">如果适配器中的消息处理不成功，请检查重试计数。</span><span class="sxs-lookup"><span data-stu-id="094aa-310">If the message processing in the adapter was unsuccessful, check the retry count.</span></span>  
  
  -   <span data-ttu-id="094aa-311">如果未超过重试计数，重新提交到 BizTalk Server，记住对消息设置重试时间的消息。</span><span class="sxs-lookup"><span data-stu-id="094aa-311">If the retry count was not exceeded, resubmit the message to BizTalk Server, remembering to set the retry time on the message.</span></span> <span data-ttu-id="094aa-312">消息上下文提供的重试计数和适配器应使用的重试间隔。</span><span class="sxs-lookup"><span data-stu-id="094aa-312">The message context provides the retry count and the retry interval the adapter should use.</span></span>  
  
  -   <span data-ttu-id="094aa-313">如果已超过重试计数，则适配器应尝试使用移动消息**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="094aa-313">If the retry count was exceeded, then the adapter should attempt to move the message by using **MoveToNextTransport**.</span></span> <span data-ttu-id="094aa-314">重新提交并**MoveToNextTransport**消息可以混合回 BizTalk Server 在同一批中删除项目。</span><span class="sxs-lookup"><span data-stu-id="094aa-314">The resubmit and **MoveToNextTransport** messages can be mixed with the deletes in the same batch back to BizTalk Server.</span></span> <span data-ttu-id="094aa-315">这不是必需的但可能是一个有用的步骤。</span><span class="sxs-lookup"><span data-stu-id="094aa-315">This is not required, but can be a useful step.</span></span>  
  
- <span data-ttu-id="094aa-316">重新提交并**MoveToNextTransport**方法可供适配器用于处理失败。</span><span class="sxs-lookup"><span data-stu-id="094aa-316">The resubmit and the **MoveToNextTransport** are ways for the adapter to deal with failures.</span></span> <span data-ttu-id="094aa-317">但是，在处理过程中失败的故障。</span><span class="sxs-lookup"><span data-stu-id="094aa-317">But there can be a failure within the processing of the failure.</span></span> <span data-ttu-id="094aa-318">在这种情况下，在处理来自 BizTalk Server 的响应 (在**BatchComplete**方法) 的适配器必须创建另一个批处理对 BizTalk 服务器，用于指示应如何处理该故障。</span><span class="sxs-lookup"><span data-stu-id="094aa-318">In this case, in processing the response from BizTalk Server (in the **BatchComplete** method) the adapter must create another batch against BizTalk Server to indicate what to do with that failure.</span></span>  
  
   <span data-ttu-id="094aa-319">处理的另一错误处理过程中发生的故障时，请执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="094aa-319">Follow these steps when processing a failure that occurs within the processing of another failure:</span></span>  
  
  -   <span data-ttu-id="094aa-320">如果重新提交失败，则使用**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="094aa-320">If the resubmit fails, use **MoveToNextTransport**.</span></span>  
  
  -   <span data-ttu-id="094aa-321">如果**MoveToNextTransport**失败，使用**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="094aa-321">If the **MoveToNextTransport** fails, use **MoveToSuspendQ**.</span></span>  
  
  <span data-ttu-id="094aa-322">您必须保留批处理上创建 BizTalk Server 之前收到成功操作在 BizTalk Server 上。</span><span class="sxs-lookup"><span data-stu-id="094aa-322">You must keep creating batches on BizTalk Server until you receive a successful action back on BizTalk Server.</span></span>  
  
### <a name="serialization-of-message-context-property"></a><span data-ttu-id="094aa-323">序列化的消息上下文属性</span><span class="sxs-lookup"><span data-stu-id="094aa-323">Serialization of Message Context Property</span></span>  
 <span data-ttu-id="094aa-324">分配给消息上下文属性的所有对象必须都可序列化。</span><span class="sxs-lookup"><span data-stu-id="094aa-324">All objects assigned to a message context property must be serializable.</span></span> <span data-ttu-id="094aa-325">否则，消息引擎将引发类型的异常**E_NOINTERFACE**。</span><span class="sxs-lookup"><span data-stu-id="094aa-325">Otherwise the Messaging Engine will throw an exception of type **E_NOINTERFACE**.</span></span> <span data-ttu-id="094aa-326">此返回值暗示正在尝试分配消息上下文的非可序列化对象。</span><span class="sxs-lookup"><span data-stu-id="094aa-326">This return value ambiguously represents a non-serializable object attempting to be assigned the message context.</span></span>