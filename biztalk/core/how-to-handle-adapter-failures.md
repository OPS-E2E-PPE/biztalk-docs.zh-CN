---
title: "如何处理适配器故障影响 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: bdceb364-38d6-4aab-a176-bf751da1be25
caps.latest.revision: "12"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 94ce45dbf8fcc46c952ddd5ccf7ed45e633641a4
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="how-to-handle-adapter-failures"></a><span data-ttu-id="dfbed-102">如何处理适配器错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-102">How to Handle Adapter Failures</span></span>
<span data-ttu-id="dfbed-103">通常，适配器应挂起无法处理的消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-103">In general, adapters should suspend messages that they cannot process.</span></span> <span data-ttu-id="dfbed-104">例如，虽然接收适配器挂起消息的决策取决于适配器的用途，但在其遇到提交失败时，通常应挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-104">For example, a receive adapter that experiences a submit failure should typically suspend the messages, although this decision depends upon the purpose of the adapter.</span></span> <span data-ttu-id="dfbed-105">关于失败的处理，还应注意安全事项。</span><span class="sxs-lookup"><span data-stu-id="dfbed-105">There are also security considerations around handling failures.</span></span> <span data-ttu-id="dfbed-106">例如，如果适配器自动挂起所有失败的消息，则该适配器可能会遭受拒绝服务攻击，导致 BizTalk Server 挂起队列向上填充。</span><span class="sxs-lookup"><span data-stu-id="dfbed-106">For example, if an adapter automatically suspends all failed messages, the adapter might be open to a denial-of-service attack that causes the BizTalk Server Suspended queue to fill up.</span></span>  <span data-ttu-id="dfbed-107">某些适配器（如 HTTP）会向客户端返回失败代码，指示请求已被拒绝。</span><span class="sxs-lookup"><span data-stu-id="dfbed-107">Some adapters, such as HTTP, can return a failure code to the client indicating that the request has been rejected.</span></span> <span data-ttu-id="dfbed-108">对于这些类型的适配器，返回失败代码通常要比挂起消息更有意义。</span><span class="sxs-lookup"><span data-stu-id="dfbed-108">For these types of adapters it often makes sense to return a failure code rather than suspend the message.</span></span> <span data-ttu-id="dfbed-109">通常，发送适配器仅在已重试了所允许的最大主传输和次要传输重试次数后才会挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-109">Typically send adapters only suspend messages after all of the retries have been exhausted for both primary and secondary transports.</span></span>  
  
## <a name="associate-error-processing-with-an-individual-operation-and-not-with-the-batch-that-contains-the-operation"></a><span data-ttu-id="dfbed-110">将错误处理与单个操作相关联而不与包含该操作的批相关联</span><span class="sxs-lookup"><span data-stu-id="dfbed-110">Associate Error Processing with an Individual Operation and Not with the Batch That Contains the Operation</span></span>  
 <span data-ttu-id="dfbed-111">适配器的用户应该能够看到适配器内的消息批处理。</span><span class="sxs-lookup"><span data-stu-id="dfbed-111">The batching of messages within an adapter should be invisible to the user of the adapter.</span></span> <span data-ttu-id="dfbed-112">这意味着批中某一操作的失败不应影响任何其他操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-112">This means that the failure of one operation in a batch should not affect any other operation in any way.</span></span> <span data-ttu-id="dfbed-113">但是，由于批是原子操作，一个消息的失败将会导致整个批出现错误，从而不会再处理任何操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-113">However, batches are atomic, so the failure of one message results in an error for the batch, and no operations are processed.</span></span>  
  
 <span data-ttu-id="dfbed-114">您需要编写负责处理错误的代码，重新提交成功的消息并挂起不成功的消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-114">You write the code that is responsible for handling the error, resubmitting the successful messages, and suspending the unsuccessful ones.</span></span> <span data-ttu-id="dfbed-115">幸运的是，BizTalk Server 可以提供详细的错误结构，使适配器能够确定具体的失败操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-115">Fortunately, BizTalk Server provides a detailed error structure that enables your adapter to determine the specific operation that failed.</span></span> <span data-ttu-id="dfbed-116">它允许构造进一步的批，在其中重新提交成功的操作并挂起不成功的操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-116">It permits construction of further batches in which the successful operations are resubmitted and the unsuccessful ones suspended.</span></span>  
  
 <span data-ttu-id="dfbed-117">操作的最终状态不应受适配器内批处理的影响。</span><span class="sxs-lookup"><span data-stu-id="dfbed-117">The final state of the operation should not be affected by the batching within the adapter.</span></span>  
  
## <a name="use-seterrorinfo-to-report-failure-to-biztalk-server"></a><span data-ttu-id="dfbed-118">使用 SetErrorInfo 向 BizTalk Server 报告失败</span><span class="sxs-lookup"><span data-stu-id="dfbed-118">Use SetErrorInfo to Report Failure to BizTalk Server</span></span>  
 <span data-ttu-id="dfbed-119">如果要挂起消息，必须从前一消息上下文向 BizTalk Server 提供失败信息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-119">If you are suspending a message, you must provide failure information to BizTalk Server from the previous message context.</span></span> <span data-ttu-id="dfbed-120">BizTalk Server 提供的错误报告功能使用**SetErrorInfo**方法同时**IBaseMessage**和**ITransportProxy**接口。</span><span class="sxs-lookup"><span data-stu-id="dfbed-120">BizTalk Server provides error reporting capabilities using the **SetErrorInfo** method on both the **IBaseMessage** and **ITransportProxy** interfaces.</span></span> <span data-ttu-id="dfbed-121">您可以按以下方式报告错误：</span><span class="sxs-lookup"><span data-stu-id="dfbed-121">You can report errors as follows:</span></span>  
  
-   <span data-ttu-id="dfbed-122">当在处理消息时出现错误时，异常使用设置**SetErrorInfo （异常 e）**对消息 (**IBaseMessage**) 要挂起。</span><span class="sxs-lookup"><span data-stu-id="dfbed-122">When a failure occurs while processing a message, set the exception using **SetErrorInfo(Exception e)** on the message (**IBaseMessage**) to be suspended.</span></span> <span data-ttu-id="dfbed-123">这会让引擎保留该错误和消息以便以后诊断，并将其记录到事件日志以便通知管理员。</span><span class="sxs-lookup"><span data-stu-id="dfbed-123">This allows the engine to preserve the error with the message for later diagnosis and logs it to the event log to alert the administrator.</span></span>  
  
-   <span data-ttu-id="dfbed-124">如果你遇到的错误在初始化或内部簿记过程 （不消息处理过程） 应调用**SetErrorInfo （异常 e）**上**ITransportProxy**指针传递到你在初始化过程。</span><span class="sxs-lookup"><span data-stu-id="dfbed-124">If you encounter an error during initialization or internal bookkeeping (not during message processing) you should call **SetErrorInfo(Exception e)** on the **ITransportProxy** pointer that was passed to you during initialization.</span></span> <span data-ttu-id="dfbed-125">如果适配器基于 BaseAdapter 实现，则应始终有权访问该指针。</span><span class="sxs-lookup"><span data-stu-id="dfbed-125">If your adapter is based on the BaseAdapter implementation, you should always have access to this pointer.</span></span> <span data-ttu-id="dfbed-126">否则，应确保对它进行缓存。</span><span class="sxs-lookup"><span data-stu-id="dfbed-126">Otherwise, you should be certain that you cache it.</span></span>  
  
 <span data-ttu-id="dfbed-127">使用以上任一方法报告错误均会将错误消息写入到事件日志中。</span><span class="sxs-lookup"><span data-stu-id="dfbed-127">Reporting an error with either of these methods results in the error message being written to the event log.</span></span> <span data-ttu-id="dfbed-128">如果可以，必须将错误与相关消息相关联。</span><span class="sxs-lookup"><span data-stu-id="dfbed-128">It is important that you associate the error with the related message if you are able to do so.</span></span>  
  
## <a name="handle-a-database-offline-condition"></a><span data-ttu-id="dfbed-129">处理数据库脱机情况</span><span class="sxs-lookup"><span data-stu-id="dfbed-129">Handle a Database-Offline Condition</span></span>  
 <span data-ttu-id="dfbed-130">如果其中一个 BizTalk Server 数据库脱机，则 BizTalk 服务将回收其自身。</span><span class="sxs-lookup"><span data-stu-id="dfbed-130">If one of the BizTalk Server databases goes offline, the BizTalk service recycles itself.</span></span> <span data-ttu-id="dfbed-131">在回收服务之前，消息引擎会尽可能关闭所有接收位置。</span><span class="sxs-lookup"><span data-stu-id="dfbed-131">The Messaging Engine makes a best effort to shut down all of the receive locations before recycling the service.</span></span> <span data-ttu-id="dfbed-132">如果此操作超过 60 秒，则服务将终止。</span><span class="sxs-lookup"><span data-stu-id="dfbed-132">If this takes longer than 60 seconds, the service terminates.</span></span> <span data-ttu-id="dfbed-133">因为引擎会执行事务处理，因此不会导致数据丢失。</span><span class="sxs-lookup"><span data-stu-id="dfbed-133">Because the engine is transacted, this does not cause data loss.</span></span>  
  
 <span data-ttu-id="dfbed-134">通过使用以下项可以在注册表中优化此超时：</span><span class="sxs-lookup"><span data-stu-id="dfbed-134">This time-out can be tuned in the registry by using the key:</span></span>  
  
```  
DWORD   
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\BTSSvc{Host Guid}\MessagingDBFailoverShutdownTimeLimit  
```  
  
 <span data-ttu-id="dfbed-135">对于独立的适配器，由于 BizTalk Server 不拥有该进程，因此当其中一个 BizTalk Server 数据库脱机时，会禁用这些接收位置。</span><span class="sxs-lookup"><span data-stu-id="dfbed-135">For isolated adapters, because BizTalk Server does not own the process, the receive locations are disabled when one of the BizTalk Server databases goes offline.</span></span> <span data-ttu-id="dfbed-136">数据库恢复联机后，会重新启用这些接收位置。</span><span class="sxs-lookup"><span data-stu-id="dfbed-136">After the database comes back online those receive locations are re-enabled.</span></span>  
  
## <a name="write-to-the-event-log"></a><span data-ttu-id="dfbed-137">写入事件日志</span><span class="sxs-lookup"><span data-stu-id="dfbed-137">Write to the Event Log</span></span>  
 <span data-ttu-id="dfbed-138">该适配器可以将事件日志条目写入使用**IBTTransportProxy**接口传递引发异常。</span><span class="sxs-lookup"><span data-stu-id="dfbed-138">The adapter can write event log entries by using the **IBTTransportProxy** interface passing in an exception.</span></span> <span data-ttu-id="dfbed-139">在本机代码中开发的适配器需要以通过**IErrorInfo**接口， **IBTTransportProxy.SetErrorInfo (异常** `e` **)**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-139">Adapters developed in native code need to pass in an **IErrorInfo** interface, **IBTTransportProxy.SetErrorInfo( Exception** `e` **)**.</span></span>  
  
 <span data-ttu-id="dfbed-140">对于像传输失败后适配器重试消息、将消息移动到备份传输或挂起消息这样的事件，消息引擎会代表适配器向事件日志中进行写入。</span><span class="sxs-lookup"><span data-stu-id="dfbed-140">The Messaging Engine writes to the event log on behalf of the adapter for events such as when an adapter retries a message after transmission failure, moves a message to its backup transport, or suspends a message.</span></span> <span data-ttu-id="dfbed-141">对于此类操作，适配器只需要在调用 API 之前对消息设置异常。</span><span class="sxs-lookup"><span data-stu-id="dfbed-141">For operations such as these the adapter only needs to set the exception on the message before calling the API.</span></span> <span data-ttu-id="dfbed-142">以下代码段演示了这一操作：</span><span class="sxs-lookup"><span data-stu-id="dfbed-142">The following code fragment demonstrates this:</span></span>  
  
```  
IBaseMessage msg;  
...  
// Set exception on msg to indicate why transmission failed...  
msg.SetErrorInfo(  
 new ApplicationException(  
 "The TCP connection was closed by the destination"));  
```  
  
## <a name="handle-receive-specific-batch-errors"></a><span data-ttu-id="dfbed-143">处理特定于接收的批错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-143">Handle Receive-Specific Batch Errors</span></span>  
  
### <a name="handle-receive-failures"></a><span data-ttu-id="dfbed-144">处理接收失败</span><span class="sxs-lookup"><span data-stu-id="dfbed-144">Handle Receive Failures</span></span>  
 <span data-ttu-id="dfbed-145">适配器向 BizTalk Server 提交操作（或批操作）时，可能有多种原因导致失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-145">When an adapter submits an operation (or batch of operations) to BizTalk Server there can be various reasons for failure.</span></span> <span data-ttu-id="dfbed-146">其中两种最主要的原因是：</span><span class="sxs-lookup"><span data-stu-id="dfbed-146">The two most significant are:</span></span>  
  
-   <span data-ttu-id="dfbed-147">接收管道失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-147">The receive pipeline failed.</span></span>  
  
-   <span data-ttu-id="dfbed-148">发布消息时发生路由失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-148">A routing failure occurred while publishing a message.</span></span>  
  
 <span data-ttu-id="dfbed-149">当消息引擎遇到接收管道失败时，会自动尝试挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-149">The Messaging Engine automatically tries to suspend the message when it gets a receive pipeline failure.</span></span> <span data-ttu-id="dfbed-150">挂起操作有时会失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-150">The suspend operation may not always be successful.</span></span> <span data-ttu-id="dfbed-151">例如，如果消息引擎在发布消息时遭遇路由失败，则引擎甚至不会尝试挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-151">For example, if the Messaging Engine hits a routing failure while publishing a message, then the engine does not even try to suspend the message.</span></span>  
  
 <span data-ttu-id="dfbed-152">通常，消息很容易失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-152">It is always possible that a message will fail.</span></span> <span data-ttu-id="dfbed-153">在这种情况下，应显式调用该适配器**MoveToSuspendQ** API 且应尝试挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-153">In such a situation, the adapter should explicitly call the **MoveToSuspendQ** API and should try to suspend the message.</span></span> <span data-ttu-id="dfbed-154">当适配器尝试挂起消息时，以下条件之一应为真：</span><span class="sxs-lookup"><span data-stu-id="dfbed-154">When an adapter tries to suspend a message, one of the following should be true:</span></span>  
  
-   <span data-ttu-id="dfbed-155">应该挂起适配器提交的同一个消息对象（建议）。</span><span class="sxs-lookup"><span data-stu-id="dfbed-155">The same message object that the adapter submitted (recommended) should be suspended.</span></span>  
  
-   <span data-ttu-id="dfbed-156">如果适配器必须创建新消息，则应设置新消息的消息上下文，其指针指向原来提交的消息的消息上下文。</span><span class="sxs-lookup"><span data-stu-id="dfbed-156">If the adapter has to create a new message, then it should set the message context of the new message with the pointer to the message context of the message that was originally submitted.</span></span> <span data-ttu-id="dfbed-157">这是因为消息的消息上下文包含很多有关该消息和失败的重要信息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-157">This is because the message context of a message has a lot of valuable information about the message and the failure.</span></span> <span data-ttu-id="dfbed-158">对失败的消息进行调试必需这些信息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-158">This information is required to debug the failed message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="dfbed-159">如果适配器创建新消息对象并将它挂起，则适配器应将错误信息从旧消息对象复制到新消息对象。</span><span class="sxs-lookup"><span data-stu-id="dfbed-159">If the adapter creates a new message object and suspends it, the adapter should copy the error information from the old message object to the new message object.</span></span>  
  
 <span data-ttu-id="dfbed-160">某些适配器（如与 BizTalk Server 一起提供的 HTTP 适配器）不需要挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-160">Some adapters, such as the HTTP adapter provided with BizTalk Server, do not require that the message be suspended.</span></span> <span data-ttu-id="dfbed-161">这些适配器会向其客户端返回一个错误。</span><span class="sxs-lookup"><span data-stu-id="dfbed-161">These adapters can return an error back to their client.</span></span>  
  
#### <a name="causes-of-failure"></a><span data-ttu-id="dfbed-162">失败原因</span><span class="sxs-lookup"><span data-stu-id="dfbed-162">Causes of failure</span></span>  
 <span data-ttu-id="dfbed-163">简单的失败的原因是构造批处理或时可能发生的错误**IBTTransportBatch::Done**调用。</span><span class="sxs-lookup"><span data-stu-id="dfbed-163">Simple causes of failure are the errors that can occur as the batch is constructed or when **IBTTransportBatch::Done** is called.</span></span>  
  
-   <span data-ttu-id="dfbed-164">**提交失败。**</span><span class="sxs-lookup"><span data-stu-id="dfbed-164">**Submit failure.**</span></span> <span data-ttu-id="dfbed-165">**提交**调用将会失败的有限数量的原因，并且所有这些都是致命。</span><span class="sxs-lookup"><span data-stu-id="dfbed-165">The **Submit** call can fail for a limited number of reasons, and all of them are fatal.</span></span> <span data-ttu-id="dfbed-166">这些原因包括：</span><span class="sxs-lookup"><span data-stu-id="dfbed-166">These reasons include:</span></span>  
  
-   <span data-ttu-id="dfbed-167">BizTalk Server 进程空间发生内存不足错误。</span><span class="sxs-lookup"><span data-stu-id="dfbed-167">Out-of-memory errors occurring in the BizTalk Server process space.</span></span>  
  
-   <span data-ttu-id="dfbed-168">已从部署中删除了架构程序集。</span><span class="sxs-lookup"><span data-stu-id="dfbed-168">The schema assembly has been dropped from the deployment.</span></span> <span data-ttu-id="dfbed-169">在这种情况下，**提交**失败，出现错误代码。</span><span class="sxs-lookup"><span data-stu-id="dfbed-169">In this case, the **Submit** fails with a cryptic error.</span></span> <span data-ttu-id="dfbed-170">在 MQSeries 适配器中，会捕获 BizTalk Server 中的一般失败异常，并会在系统事件日志中写入详细的错误消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-170">In the MQSeries adapter, the generic failure exception from BizTalk Server is caught, and an extended error message is written in the system event log.</span></span> <span data-ttu-id="dfbed-171">此消息建议导致错误的一种可能原因是已从部署中以某种形式删除了架构程序集。</span><span class="sxs-lookup"><span data-stu-id="dfbed-171">This message suggests that one of the possible causes of the error is that the schema assembly has somehow been dropped from the deployment.</span></span>  
  
     <span data-ttu-id="dfbed-172">通常情况下，如果**提交**应尝试挂起使用同一个事务的消息失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-172">In general, if **Submit** fails you should try to suspend the message using the same transaction.</span></span>  
  
-   <span data-ttu-id="dfbed-173">**IBTTransportBatch::Done 失败。**</span><span class="sxs-lookup"><span data-stu-id="dfbed-173">**IBTTransportBatch::Done failure.**</span></span> <span data-ttu-id="dfbed-174">**IBTTransportBatch::Done**调用几个原因之一可能会失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-174">The **IBTTransportBatch::Done** call can fail for one of several reasons.</span></span> <span data-ttu-id="dfbed-175">通常，始终应尝试执行挂起操作，如果挂起失败，则结束该事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-175">In general, you should always attempt one suspend operation and end the transaction only if that fails.</span></span> <span data-ttu-id="dfbed-176">你可能会从故障中收到的错误代码之一**IBTTransportBatch::Done**是 BizTalk Server 正在尝试关闭。</span><span class="sxs-lookup"><span data-stu-id="dfbed-176">One of the error codes you might receive from the failure of **IBTTransportBatch::Done** is that BizTalk Server is trying to shut down.</span></span> <span data-ttu-id="dfbed-177">在这种情况下，应只需结束该事务，并将其保留因为**终止**调用可能发生的并发情况。</span><span class="sxs-lookup"><span data-stu-id="dfbed-177">In this case, you should just end the transaction and leave it because the **Terminate** call is probably happening concurrently.</span></span> <span data-ttu-id="dfbed-178">当你成功构造批处理并已成功执行时，会出现其他情况**IBTTransportBatch::Done**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-178">Other scenarios occur when you have successfully constructed the batch and successfully executed **IBTTransportBatch::Done**.</span></span> <span data-ttu-id="dfbed-179">在这些情况下，在返回的错误**BatchComplete**和适配器必须确定应如何处理它们。</span><span class="sxs-lookup"><span data-stu-id="dfbed-179">In these cases, the errors are returned in **BatchComplete** and the adapter must determine what to do with them.</span></span> <span data-ttu-id="dfbed-180">本部分的其余内容将对这种情况加以说明。</span><span class="sxs-lookup"><span data-stu-id="dfbed-180">The rest of this section deals with this case.</span></span>  
  
#### <a name="processing-batchcomplete-errors"></a><span data-ttu-id="dfbed-181">处理 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-181">Processing BatchComplete errors</span></span>  
 <span data-ttu-id="dfbed-182">**BatchComplete**适配器调用的 BizTalk Server，以指示批处理操作的完成状态时提供的回调。</span><span class="sxs-lookup"><span data-stu-id="dfbed-182">**BatchComplete** is a callback provided by the adapter that is invoked by BizTalk Server to indicate the completion status of a batch operation.</span></span>  
  
 <span data-ttu-id="dfbed-183">最重要的参数传递给**BatchComplete**是批处理状态`hResult`。</span><span class="sxs-lookup"><span data-stu-id="dfbed-183">The most important parameter passed to **BatchComplete** is the batch status `hResult`.</span></span> <span data-ttu-id="dfbed-184">它可指示批是成功还是失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-184">This indicates success or failure for the batch.</span></span> <span data-ttu-id="dfbed-185">如果批失败，则意味着该批中的所有操作都已失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-185">If the batch failed, it means that none of the operations in the batch succeeded.</span></span> <span data-ttu-id="dfbed-186">适配器经历批处理状态结构，并确定哪些消息失败 (这称为*筛选批处理*)。</span><span class="sxs-lookup"><span data-stu-id="dfbed-186">The adapter goes through the batch status structure and determines which messages failed (this is known as *filtering the batch*).</span></span>  
  
#### <a name="nontransactional-batchcomplete-errors"></a><span data-ttu-id="dfbed-187">非事务性 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-187">Nontransactional BatchComplete errors</span></span>  
 <span data-ttu-id="dfbed-188">对于非事务性适配器，你必须选择您的响应为发生故障时**SubmitMessage**/**SubmitRequestMessage**或**SubmitResponseMessage**操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-188">For nontransactional adapters, you must choose your response if a failure occurs for a **SubmitMessage**/**SubmitRequestMessage** or **SubmitResponseMessage** operation.</span></span> <span data-ttu-id="dfbed-189">适配器通常通过调用挂起消息**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-189">Typically adapters suspend the message by calling **MoveToSuspendQ**.</span></span>  
  
 <span data-ttu-id="dfbed-190">执行以下操作始终需要传递： **DeleteMessage**， **MoveToSuspendQ**， **ResubmitMessage**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-190">The following operations are always expected to pass: **DeleteMessage**, **MoveToSuspendQ**, **ResubmitMessage**.</span></span> <span data-ttu-id="dfbed-191">如果这些操作失败，则通常意味着适配器中有错误。</span><span class="sxs-lookup"><span data-stu-id="dfbed-191">If these operations fail, it typically means that there is a bug in the adapter.</span></span> <span data-ttu-id="dfbed-192">在这些情况下，不必编写代码来处理失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-192">You do not have to write code to handle a failure in these cases.</span></span> <span data-ttu-id="dfbed-193">但是，如果由于其他操作失败而导致批失败，则必须在新批中重新执行这些操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-193">However if the batch failed because another operation failed, then these operations must be re-executed in a fresh batch.</span></span>  
  
 <span data-ttu-id="dfbed-194">如果适配器调用**MovetoBackupTransport**失败 （因为没有任何备份传输），然后应调用该适配器**MoveToSuspendQ**挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-194">If the adapter calls **MovetoBackupTransport** and that fails (because there was no backup transport), then the adapter should call **MoveToSuspendQ** to suspend the message.</span></span>  
  
#### <a name="transactional-batchcomplete-errors"></a><span data-ttu-id="dfbed-195">事务性 BatchComplete 错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-195">Transactional BatchComplete errors</span></span>  
 <span data-ttu-id="dfbed-196">在使用适配器创建的事务向 BizTalk Server 提交批时，应该遵循以下两种方案之一：</span><span class="sxs-lookup"><span data-stu-id="dfbed-196">When you submit batches to BizTalk Server using a transaction created by the adapter, you should follow one of these two scenarios:</span></span>  
  
-   <span data-ttu-id="dfbed-197">**使用单个消息批处理。**</span><span class="sxs-lookup"><span data-stu-id="dfbed-197">**Use single-message batches.**</span></span> <span data-ttu-id="dfbed-198">将包含单个消息的批发送至 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="dfbed-198">Send a single-message batch to BizTalk Server.</span></span> <span data-ttu-id="dfbed-199">如果该单个消息失败，则可以在同一个事务下向 BizTalk Server 发送另一个批，但必须将有问题的消息移动到挂起队列而不是重新提交该消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-199">If that single message fails, then you can legally send BizTalk Server a second batch under the same transaction, but you must move the offending message to the Suspended queue rather than resubmitting it.</span></span> <span data-ttu-id="dfbed-200">删除失败的消息后，第二个批的提交应该会成功。</span><span class="sxs-lookup"><span data-stu-id="dfbed-200">After the failed message is removed, the submission of the second batch should succeed.</span></span> <span data-ttu-id="dfbed-201">之后，当 BizTalk Server 确认第二个批成功时，可以提交该事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-201">After that occurs you can commit the transaction when BizTalk Server confirms that the second batch was successful.</span></span> <span data-ttu-id="dfbed-202">如果第二个批失败，则适配器必须中止该事务，或查找其他位置以存放该消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-202">If the second batch fails, the adapter must abort the transaction, or find somewhere else to place that message.</span></span> <span data-ttu-id="dfbed-203">在此方案中，由于事务回滚处理，性能可能会立即明显降低。</span><span class="sxs-lookup"><span data-stu-id="dfbed-203">In this scenario, you immediately take a significant performance hit due to transaction rollback processing.</span></span>  
  
     <span data-ttu-id="dfbed-204">可以采用一些方法来改善适配器的性能。</span><span class="sxs-lookup"><span data-stu-id="dfbed-204">There are some techniques that you can use to improve the performance of the adapter.</span></span> <span data-ttu-id="dfbed-205">例如，MQSeries 适配器在运行时会动态调整其方法。</span><span class="sxs-lookup"><span data-stu-id="dfbed-205">For example, the MQSeries adapter adjusts its approach dynamically at run time.</span></span> <span data-ttu-id="dfbed-206">它运行时处理 100 个消息的批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-206">It runs with 100-message batches.</span></span> <span data-ttu-id="dfbed-207">如果该适配器遇到错误，它必须结束该批，但会暂时切换到单消息批运行模式以避免错误消息，</span><span class="sxs-lookup"><span data-stu-id="dfbed-207">If it hits an error, it must end the batch, but it switches to single-message batches for a short time as it gets past the bad message.</span></span> <span data-ttu-id="dfbed-208">然后还原为 100 个消息的批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-208">It then reverts to 100-message batches.</span></span> <span data-ttu-id="dfbed-209">如果再次遇到错误，性能会再次降低。</span><span class="sxs-lookup"><span data-stu-id="dfbed-209">If it hits the error again, it slows down again.</span></span>  
  
-   <span data-ttu-id="dfbed-210">**使用抢先式挂起。**</span><span class="sxs-lookup"><span data-stu-id="dfbed-210">**Use preemptive suspension.**</span></span> <span data-ttu-id="dfbed-211">构造一个在其中抢先挂起错误消息的多消息批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-211">Construct a multi-message batch in which the erroneous messages are preemptively suspended.</span></span> <span data-ttu-id="dfbed-212">批处理包含多种**提交**和**MoveToSuspendQ**操作，和是第一个也仅在事务下的批处理。</span><span class="sxs-lookup"><span data-stu-id="dfbed-212">The batch contains a mix of **Submit** and **MoveToSuspendQ** operations, and is the first and only batch under the transaction.</span></span> <span data-ttu-id="dfbed-213">由于会抢先挂起错误的数据，因此该批应该成功，并可以提交事务（等到收到 BizTalk Server 的确认后）。</span><span class="sxs-lookup"><span data-stu-id="dfbed-213">It should succeed because the bad data was preemptively suspended, and the transaction can be committed (after waiting to receive the confirmation from BizTalk Server).</span></span>  
  
     <span data-ttu-id="dfbed-214">这看起来好象需要了解以后的情况，但这一方法已在 MSMQ 适配器中得到了应用。</span><span class="sxs-lookup"><span data-stu-id="dfbed-214">This might seem to require looking into the future, but this technique has been used in the MSMQ adapter.</span></span> <span data-ttu-id="dfbed-215">这种方法取决于是否具有唯一的消息 ID。</span><span class="sxs-lookup"><span data-stu-id="dfbed-215">It depends on having reliably unique message IDs.</span></span> <span data-ttu-id="dfbed-216">适配器会构造一个消息批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-216">This adapter constructs a batch of messages.</span></span> <span data-ttu-id="dfbed-217">如果出现任何错误，它将回滚事务（从而回滚该批），但会记住临时数据结构中的消息 ID。</span><span class="sxs-lookup"><span data-stu-id="dfbed-217">If anything fails it rolls back the transaction (and therefore the batch), but remembers the message ID in a temporary data structure.</span></span> <span data-ttu-id="dfbed-218">（为防止这一结构无限增长，其中的项目会在一定的时间延迟后被删除。）在提交每个批之前，适配器都会检查错误消息 ID 列表。</span><span class="sxs-lookup"><span data-stu-id="dfbed-218">(To prevent this structure from growing indefinitely, items in it are removed after some fixed time delay.) Before each batch is submitted, the adapter checks the list of bad message IDs.</span></span> <span data-ttu-id="dfbed-219">如果发现错误消息 ID，适配器就会知道该消息将会失败（因为以前失败过），并会抢先挂起该消息而不尝试提交该消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-219">If it sees one, it knows that message will fail (because it failed once in the past), and preemptively suspends it rather than trying to submit it.</span></span>  
  
     <span data-ttu-id="dfbed-220">并不是每个适配器都可靠地拥有唯一消息 ID，事务性存储就有可能不拥有这样的 ID。</span><span class="sxs-lookup"><span data-stu-id="dfbed-220">Not every adapter has a reliably unique message ID, and a transactional store is less likely to have one.</span></span> <span data-ttu-id="dfbed-221">因此，很多事务性适配器局限于发送单消息批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-221">Because of this, many transactional adapters are restricted to sending single-message batches.</span></span>  
  
#### <a name="processing-other-errors"></a><span data-ttu-id="dfbed-222">处理其他错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-222">Processing other errors</span></span>  
 <span data-ttu-id="dfbed-223">在所有其他情况下（如挂起消息失败），适配器必须结束事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-223">In all other cases (such as failures in suspending messages), the adapter must end the transaction.</span></span> <span data-ttu-id="dfbed-224">任何其他结果均会导致消息重复或消息被删除。</span><span class="sxs-lookup"><span data-stu-id="dfbed-224">Any other outcome results in either duplicate or dropped messages.</span></span>  
  
 <span data-ttu-id="dfbed-225">如果批失败，适配器应尽可能地中止事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-225">Whenever the adapter can, it should abort the transaction if a batch fails.</span></span> <span data-ttu-id="dfbed-226">但是，有时适配器无法中止事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-226">However there are scenarios where the adapter cannot abort the transaction.</span></span> <span data-ttu-id="dfbed-227">在这种情况下，适配器应使用同一个事务挂起消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-227">In such a scenario it should suspend the message using the same transaction.</span></span>  
  
#### <a name="processing-errors-on-transactional-receive"></a><span data-ttu-id="dfbed-228">处理事务性接收错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-228">Processing errors on transactional receive</span></span>  
 <span data-ttu-id="dfbed-229">常用的事务性处理模式是在发生错误时结束事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-229">A common transactional processing pattern is to end a transaction when an error occurs.</span></span> <span data-ttu-id="dfbed-230">在这种情况下，所有内容都将返回到其以前的状态，数据不会丢失。</span><span class="sxs-lookup"><span data-stu-id="dfbed-230">In this case everything returns to its previous state and no data is lost.</span></span> <span data-ttu-id="dfbed-231">但是，如果要使用事务性源中的数据（例如，从数据库的中间临时表中每次请求一行，或从 MQSeries 或 MSMQ 这样的队列产品中每次请求一个消息），则这种处理模式可能还不够。</span><span class="sxs-lookup"><span data-stu-id="dfbed-231">However, if you are consuming data from a transactional feed (for example, pulling a row at a time from a staging table in a database, or pulling one message at a time from a queuing product like MQSeries or MSMQ), then this might not be enough.</span></span> <span data-ttu-id="dfbed-232">如果只是结束事务并返回，然后重新提取相同的数据，则很可能发生同样的错误，系统会进入重复的循环。</span><span class="sxs-lookup"><span data-stu-id="dfbed-232">If you simply end the transaction and go back and pick up the same data again, the same error is likely to occur and the system becomes stuck in a repeated loop.</span></span>  
  
 <span data-ttu-id="dfbed-233">早期版本的 BizTalk Server 中的 SQL 适配器具有这种行为。</span><span class="sxs-lookup"><span data-stu-id="dfbed-233">The SQL adapter in an earlier version of BizTalk Server shipped with this behavior.</span></span> <span data-ttu-id="dfbed-234">但发行后不久，适配器的行为就被更改为尝试挂起失败的消息并提交事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-234">However, soon after release the adapter behavior was changed to attempt to suspend a failed message and commit the transaction.</span></span> <span data-ttu-id="dfbed-235">将消息移动到同一事务下的挂起队列，然后提交事务，这样可以使数据免于丢失，还可以使适配器绕过错误数据。</span><span class="sxs-lookup"><span data-stu-id="dfbed-235">Moving a message to the Suspended queue under the same transaction and then committing the transaction saves the data from being lost and also allows the adapter to get past bad data.</span></span>  
  
 <span data-ttu-id="dfbed-236">当适配器的接收部分传递一条错误消息，以响应**提交**消息操作，该适配器应处理该错误并将消息移至挂起队列。</span><span class="sxs-lookup"><span data-stu-id="dfbed-236">When the receive portion of an adapter is passed an error message in response to a **Submit** message operation, the adapter should process that error and move the message to the Suspended queue.</span></span>  
  
 <span data-ttu-id="dfbed-237">如果适配器已经在事务性批中创建了事务对象并在事务下提交了消息，则在发生失败时，适配器应以逻辑方式将消息移到同一事务下的挂起队列。</span><span class="sxs-lookup"><span data-stu-id="dfbed-237">In the case of transactional batches in which the adapter has created the transaction object and submits messages under the transaction, the adapter should logically move the message to the Suspended queue under the same transaction when failures occur.</span></span> <span data-ttu-id="dfbed-238">该事务可确保数据不会被删除，甚至是导致错误的数据也不会被删除。</span><span class="sxs-lookup"><span data-stu-id="dfbed-238">The transaction ensures that data is not dropped, and even data that is causing an error should never be dropped.</span></span>  
  
### <a name="handle-messages-without-subscriptions"></a><span data-ttu-id="dfbed-239">处理没有订阅的消息</span><span class="sxs-lookup"><span data-stu-id="dfbed-239">Handle Messages without Subscriptions</span></span>  
 <span data-ttu-id="dfbed-240">如果未定义接受消息的订阅，则 BizTalk Server 不接受在其 MessageBox 数据库中发布该消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-240">BizTalk Server does not accept a message to be published in its MessageBox database if there are no subscriptions defined to accept it.</span></span> <span data-ttu-id="dfbed-241">订阅由业务流程或发送端口注册。</span><span class="sxs-lookup"><span data-stu-id="dfbed-241">Subscriptions are registered by either orchestrations or send ports.</span></span> <span data-ttu-id="dfbed-242">可以定义多个订阅，在这种情况下，会将消息发送至多个目标。</span><span class="sxs-lookup"><span data-stu-id="dfbed-242">Multiple subscriptions can be defined, in which case the message is sent to multiple destinations.</span></span> <span data-ttu-id="dfbed-243">如果没有订阅，BizTalk Server 将会拒绝该消息，而不会尝试将其挂起。</span><span class="sxs-lookup"><span data-stu-id="dfbed-243">If there are no subscriptions, BizTalk Server rejects the message and does not attempt to suspend it.</span></span> <span data-ttu-id="dfbed-244">如果适配器不处理此错误并显式挂起该消息，则该消息将被删除，消息数据可能会丢失。</span><span class="sxs-lookup"><span data-stu-id="dfbed-244">If the adapter does not handle this error and explicitly suspend the message, then the message is dropped and its data is potentially lost.</span></span> <span data-ttu-id="dfbed-245">当然，事务性适配器可以结束事务并将消息返回到消息的目标。</span><span class="sxs-lookup"><span data-stu-id="dfbed-245">Of course a transactional adapter may end the transaction and return the message to its destination.</span></span>  
  
### <a name="support-seek-with-your-receive-stream"></a><span data-ttu-id="dfbed-246">使接收流支持 Seek</span><span class="sxs-lookup"><span data-stu-id="dfbed-246">Support Seek with Your Receive Stream</span></span>  
 <span data-ttu-id="dfbed-247">接收方流必须支持**Seek** BizTalk Server 能够挂起管道失败的消息的方法。</span><span class="sxs-lookup"><span data-stu-id="dfbed-247">The receive-side stream must support the **Seek** method for BizTalk Server to be able to suspend the message on a pipeline failure.</span></span> <span data-ttu-id="dfbed-248">如果消息流不是可查找，则它将尝试运行时，BizTalk Server 将生成错误**Seek**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-248">If the message stream is not seekable, then BizTalk Server generates an error when it tries to run **Seek**.</span></span>  
  
 <span data-ttu-id="dfbed-249">在许多情况下支持**Seek**并不容易。</span><span class="sxs-lookup"><span data-stu-id="dfbed-249">In many cases supporting **Seek** is not easy.</span></span> <span data-ttu-id="dfbed-250">例如，在对网络数据进行流式处理时，要返回到网络资源并重新请求数据可能会很难。</span><span class="sxs-lookup"><span data-stu-id="dfbed-250">When streaming data from a network, for example, it may be difficult to go back to the network resource and request the data again.</span></span>  
  
 <span data-ttu-id="dfbed-251">随 BizTalk Server 一起提供的多个适配器会在 BizTalk Server 读取数据的同时，将消息数据假脱机保存到磁盘上的文件中。</span><span class="sxs-lookup"><span data-stu-id="dfbed-251">Several adapters that ship with BizTalk Server spool the message data onto a file on disk at the same time as BizTalk Server reads the data.</span></span> <span data-ttu-id="dfbed-252">这样适配器，以使用**Seek**对该文件，如果遇到错误 （在消息数据，例如管道处理）。</span><span class="sxs-lookup"><span data-stu-id="dfbed-252">This allows the adapter to use **Seek** on that file if it encounters an error (in the pipeline processing of the message data, for example).</span></span> <span data-ttu-id="dfbed-253">适配器在内部使用**ReadOnlySeekableStream**类，该类包装传入不可查找的流并达到可配置大小阈值时溢出到磁盘。</span><span class="sxs-lookup"><span data-stu-id="dfbed-253">Internally the adapter uses the **ReadOnlySeekableStream** class that wraps an incoming non-seekable stream and overflows to disk when a configurable size threshold is reached.</span></span> <span data-ttu-id="dfbed-254">小于该阈值大小的消息不会保存到磁盘。</span><span class="sxs-lookup"><span data-stu-id="dfbed-254">For messages smaller than the threshold size, the disk is never hit.</span></span>  
  
### <a name="consider-user-configurable-error-handling-options"></a><span data-ttu-id="dfbed-255">考虑使用用户可配置的错误处理选项</span><span class="sxs-lookup"><span data-stu-id="dfbed-255">Consider User-Configurable Error-Handling Options</span></span>  
 <span data-ttu-id="dfbed-256">有时，在发生错误时并没有针对该错误的正确响应。</span><span class="sxs-lookup"><span data-stu-id="dfbed-256">Sometimes there is no one correct response to an error.</span></span> <span data-ttu-id="dfbed-257">在这种情况下，应该考虑使用用户可配置的选项在行为之间进行选择。</span><span class="sxs-lookup"><span data-stu-id="dfbed-257">In this case, you should consider a user-configurable option to choose between behaviors.</span></span> <span data-ttu-id="dfbed-258">MQSeries 适配器就是这样。</span><span class="sxs-lookup"><span data-stu-id="dfbed-258">The MQSeries adapter does this.</span></span>  
  
 <span data-ttu-id="dfbed-259">适配器发现错误时挂起消息这一行为之所以会出现问题，是因为 BizTalk Server 中的挂起队列有点像是一个“黑洞”。</span><span class="sxs-lookup"><span data-stu-id="dfbed-259">The problem with having the adapter suspend messages when it sees an error is that the Suspended queue in BizTalk Server is something of a "black hole."</span></span> <span data-ttu-id="dfbed-260">相对而言，让消息进入队列很容易，但让消息再从队列中出来很难。</span><span class="sxs-lookup"><span data-stu-id="dfbed-260">It is relatively easy to get messages into the queue, but harder to get them out again.</span></span>  
  
 <span data-ttu-id="dfbed-261">某些适配器用户可能不需要挂起队列中的任何内容。</span><span class="sxs-lookup"><span data-stu-id="dfbed-261">Some users of the adapter might not want anything in the Suspended queue.</span></span> <span data-ttu-id="dfbed-262">例如，在使用 MQSeries 适配器的情况下，用户可以使用为其提供的配置选项进行以下操作之一：</span><span class="sxs-lookup"><span data-stu-id="dfbed-262">For example, in the case of the MQSeries adapter, the user is offered a configuration option to do one of the following:</span></span>  
  
-   <span data-ttu-id="dfbed-263">将适配器设置为发现错误时结束当前事务并禁用该其自身。</span><span class="sxs-lookup"><span data-stu-id="dfbed-263">Set the adapter to end the current transaction and disable itself when it sees an error.</span></span>  
  
-   <span data-ttu-id="dfbed-264">挂起失败消息并提交事务。</span><span class="sxs-lookup"><span data-stu-id="dfbed-264">Suspend the failed message and commit the transaction.</span></span> <span data-ttu-id="dfbed-265">即使 BizTalk Server 已成功挂起消息，适配器也会这样做。</span><span class="sxs-lookup"><span data-stu-id="dfbed-265">The adapter does this even when BizTalk Server has successfully suspended the message.</span></span> <span data-ttu-id="dfbed-266">尽管此操作会导致事件日志不完全正确，但可以满足客户的要求。</span><span class="sxs-lookup"><span data-stu-id="dfbed-266">This action meets the requirements of the customer even if it causes the event log to not be strictly correct.</span></span>  
  
### <a name="implement-receive-ordering-by-using-a-single-thread-and-waiting-on-batchcomplete"></a><span data-ttu-id="dfbed-267">通过使用单个线程和等待 BatchComplete 实现接收排序</span><span class="sxs-lookup"><span data-stu-id="dfbed-267">Implement Receive Ordering by Using a Single Thread and Waiting on BatchComplete</span></span>  
 <span data-ttu-id="dfbed-268">BizTalk Server 接口的设计通过支持并发实现高性能和扩展能力。</span><span class="sxs-lookup"><span data-stu-id="dfbed-268">The interface to BizTalk Server is designed for performance and the ability to scale out by supporting concurrency.</span></span> <span data-ttu-id="dfbed-269">但如果想要接收严格排序的消息（比如接收来自 QSeries 或 MSMQ 这样的消息队列产品的消息时就需要如此），则必须在适配器中进行额外操作以禁用某些并发功能。</span><span class="sxs-lookup"><span data-stu-id="dfbed-269">However, if you want a strictly ordered receive of messages (as is sometimes required when receiving messages from a message queue product like MQSeries or MSMQ), then you must do some additional work in the adapter to disable some of that concurrency.</span></span> <span data-ttu-id="dfbed-270">此操作可以通过以下两步完成：</span><span class="sxs-lookup"><span data-stu-id="dfbed-270">This can be done in two steps:</span></span>  
  
1.  <span data-ttu-id="dfbed-271">必须为适配器中的所有数据处理使用单个线程。</span><span class="sxs-lookup"><span data-stu-id="dfbed-271">You must use a single thread for all the data processing in the adapter.</span></span>  
  
2.  <span data-ttu-id="dfbed-272">必须等待 BizTalk Server 彻底处理每个批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-272">You must wait for BizTalk Server to completely process each batch.</span></span> <span data-ttu-id="dfbed-273">这一要求很重要，可以通过使用 .NET 线程同步基元实现。</span><span class="sxs-lookup"><span data-stu-id="dfbed-273">This requirement is important and can be accomplished by using .NET thread synchronization primitives.</span></span> <span data-ttu-id="dfbed-274">例如，使用**AutoResetEvent**，你将：</span><span class="sxs-lookup"><span data-stu-id="dfbed-274">For example, using an **AutoResetEvent**, you would:</span></span>  
  
    -   <span data-ttu-id="dfbed-275">声明事件对象，并可通过两个主要的辅助线程访问和**BatchComplete**回调对象。</span><span class="sxs-lookup"><span data-stu-id="dfbed-275">Declare the event object where it can be accessed by both the main worker thread and the **BatchComplete** callback object.</span></span>  
  
    -   <span data-ttu-id="dfbed-276">主辅助线程上提交的批处理消息像往常一样，但然后调用**AutoResetEvent.Reset**上对批处理调用之前的事件对象**IBTTransportBatch::Done**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-276">On the main worker thread, submit the messages to the batch as usual but then call **AutoResetEvent.Reset** on the event object just before the call to the batch **IBTTransportBatch::Done**.</span></span>  
  
    -   <span data-ttu-id="dfbed-277">调用**AutoResetEvent.WaitOne**上此同一线程中的事件对象。</span><span class="sxs-lookup"><span data-stu-id="dfbed-277">Call **AutoResetEvent.WaitOne** on the event object from this same thread.</span></span> <span data-ttu-id="dfbed-278">这会阻止主工作线程。</span><span class="sxs-lookup"><span data-stu-id="dfbed-278">This causees the main worker thread to block.</span></span> <span data-ttu-id="dfbed-279">在**BatchComplete**然后调用回调从 BizTalk Server **AutoResetEvent.Set**上相同的事件对象，以取消阻止工作线程，以便它已准备好处理另一条消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-279">In the **BatchComplete** callback from BizTalk Server you then call **AutoResetEvent.Set** on the same event object to unblock the worker thread so it is ready to process another message.</span></span>  
  
 <span data-ttu-id="dfbed-280">强烈建议，*接收排序*像这一点成为可配置，因为它会导致性能明显下降。</span><span class="sxs-lookup"><span data-stu-id="dfbed-280">It is strongly suggested that *receive ordering* like this be made configurable because it causes significant performance degradation.</span></span> <span data-ttu-id="dfbed-281">许多（即使不是大多数）用户方案不需要对消息进行排序。</span><span class="sxs-lookup"><span data-stu-id="dfbed-281">Many, if not most, user scenarios do not require ordering of messages.</span></span> <span data-ttu-id="dfbed-282">挂起消息也会中断排序。</span><span class="sxs-lookup"><span data-stu-id="dfbed-282">Suspending messages can also break ordering.</span></span> <span data-ttu-id="dfbed-283">在这种情况下究竟应该如何操作取决于应用程序，因此适配器最好为用户提供一个配置点。</span><span class="sxs-lookup"><span data-stu-id="dfbed-283">Exactly what to do in this case is application-dependent, so the best thing for your adapter to do is to offer the user a configuration point.</span></span>  
  
 <span data-ttu-id="dfbed-284">在排序方案中，一些客户表示更愿意停止这种处理（即禁用适配器），而不是中断排序。</span><span class="sxs-lookup"><span data-stu-id="dfbed-284">In ordered scenarios, some customers have stated that they would prefer to stop the processing, that is, disable the adapter, rather than break ordering.</span></span> <span data-ttu-id="dfbed-285">支持排序接收的 MQSeries 适配器恰好可以为用户提供这一选项。</span><span class="sxs-lookup"><span data-stu-id="dfbed-285">The MQSeries adapter, which supports ordered receive, provides this option to the user.</span></span>  
  
## <a name="handle-send-specific-batch-errors"></a><span data-ttu-id="dfbed-286">处理特定于发送的批错误</span><span class="sxs-lookup"><span data-stu-id="dfbed-286">Handle Send-Specific Batch Errors</span></span>  
  
### <a name="handle-send-retry-and-batching"></a><span data-ttu-id="dfbed-287">处理发送重试和批处理</span><span class="sxs-lookup"><span data-stu-id="dfbed-287">Handle Send Retry and Batching</span></span>  
 <span data-ttu-id="dfbed-288">以下是发送端批处理的典型示例：</span><span class="sxs-lookup"><span data-stu-id="dfbed-288">Here is a typical example of send-side batching:</span></span>  
  
-   <span data-ttu-id="dfbed-289">BizTalk Server 为适配器提供一批消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-289">BizTalk Server gives a batch of messages to the adapter.</span></span>  
  
-   <span data-ttu-id="dfbed-290">如果适配器确定已将消息正确发送至目标，则会在 BizTalk Server 上执行向后删除，指示操作已完成。</span><span class="sxs-lookup"><span data-stu-id="dfbed-290">When the adapter determines that it has given the message to its destination correctly, it executes delete back on BizTalk Server indicating that it is done.</span></span> <span data-ttu-id="dfbed-291">（通常，可以任意选择数个删除消息组成批以提高性能。）</span><span class="sxs-lookup"><span data-stu-id="dfbed-291">(As usual, several delete messages can be arbitrarily batched up to improve performance.)</span></span>  
  
 <span data-ttu-id="dfbed-292">如果发送端适配器不能处理某个消息，则该适配器可以对该消息执行以下几种操作之一：</span><span class="sxs-lookup"><span data-stu-id="dfbed-292">If the send-side adapter fails to process a message, then it may do one of several things with that message:</span></span>  
  
-   <span data-ttu-id="dfbed-293">适配器通知 BizTalk Server 想要重试某个消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-293">The adapter should tell BizTalk Server that it wants a message retried.</span></span> <span data-ttu-id="dfbed-294">BizTalk Server 不会自动重试消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-294">BizTalk Server does not automatically retry a message.</span></span> <span data-ttu-id="dfbed-295">BizTalk Server 会对重试次数进行计数，此计数可以在消息上下文中看到。</span><span class="sxs-lookup"><span data-stu-id="dfbed-295">BizTalk Server keeps a count of the retries, and this count can be seen in the message context.</span></span>  
  
-   <span data-ttu-id="dfbed-296">适配器可以确定其无法处理某个消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-296">The adapter may determine that it cannot process a message.</span></span> <span data-ttu-id="dfbed-297">在这种情况下，适配器可能会将消息移至下一个传输。</span><span class="sxs-lookup"><span data-stu-id="dfbed-297">In this case, the adapter might move the message to the next transport.</span></span> <span data-ttu-id="dfbed-298">适配器实现此目的**MoveToNextTransport**上调用**批处理**对象。</span><span class="sxs-lookup"><span data-stu-id="dfbed-298">The adapter does this with the **MoveToNextTransport** call on the **Batch** object.</span></span>  
  
-   <span data-ttu-id="dfbed-299">适配器可将消息移至挂起队列。</span><span class="sxs-lookup"><span data-stu-id="dfbed-299">The adapter may move the message to the Suspended queue.</span></span>  
  
 <span data-ttu-id="dfbed-300">适配器可以确定对消息采取的操作。</span><span class="sxs-lookup"><span data-stu-id="dfbed-300">The adapter determines what happens to the message.</span></span> <span data-ttu-id="dfbed-301">不过，建议让适配器保持一致的行为，这样可以更易于为 BizTalk Server 系统提供支持。</span><span class="sxs-lookup"><span data-stu-id="dfbed-301">However, it is recommended that you have adapters behave in a consistent manner because this makes a BizTalk Server installation easier to support.</span></span>  
  
 <span data-ttu-id="dfbed-302">强烈建议适配器具有下述行为。</span><span class="sxs-lookup"><span data-stu-id="dfbed-302">It is highly recommended that adapters behave as described below.</span></span> <span data-ttu-id="dfbed-303">与 BizTalk Server 一起提供的适配器的行为如下。</span><span class="sxs-lookup"><span data-stu-id="dfbed-303">The adapters shipped with BizTalk Server behave like this.</span></span>  
  
### <a name="recommended-behavior-for-handling-send-errors-in-a-batch"></a><span data-ttu-id="dfbed-304">处理批中发送错误的推荐行为</span><span class="sxs-lookup"><span data-stu-id="dfbed-304">Recommended Behavior for Handling Send Errors in a Batch</span></span>  
 <span data-ttu-id="dfbed-305">发送适配器接收某些消息，并将这些消息提交给 BizTalk Server。</span><span class="sxs-lookup"><span data-stu-id="dfbed-305">The send adapter receives some messages and submits them to BizTalk Server.</span></span>  
  
 <span data-ttu-id="dfbed-306">对于每个成功的消息，适配器应在 BizTalk Server 上删除该消息。</span><span class="sxs-lookup"><span data-stu-id="dfbed-306">For each successful message the adapter should delete that message on BizTalk Server.</span></span> <span data-ttu-id="dfbed-307">通过批完成所有与 BizTalk Server 的通信，并且删除操作可以以批的形式进行。</span><span class="sxs-lookup"><span data-stu-id="dfbed-307">All communication back to BizTalk Server is done through batches, and the deletes can be batched up.</span></span> <span data-ttu-id="dfbed-308">这些批不一定是 BizTalk Server 在适配器上创建的批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-308">They do not have to be the same batch that BizTalk Server created on the adapter.</span></span> <span data-ttu-id="dfbed-309">如果有任何响应消息（如在 SolicitResponse 方案中），则这些消息应当与相关联的删除一起提交回 BizTalk Server（使用 SubmitResponse）。</span><span class="sxs-lookup"><span data-stu-id="dfbed-309">If there are any response messages (as in a SolicitResponse scenario), then they should be submitted back to BizTalk Server (with SubmitResponse) along with the associated delete.</span></span>  
  
-   <span data-ttu-id="dfbed-310">如果适配器中的消息处理不成功，请检查重试计数。</span><span class="sxs-lookup"><span data-stu-id="dfbed-310">If the message processing in the adapter was unsuccessful, check the retry count.</span></span>  
  
    -   <span data-ttu-id="dfbed-311">如果没有超出重试计数，则将消息重新提交给 BizTalk Server，记住对消息设置重试次数。</span><span class="sxs-lookup"><span data-stu-id="dfbed-311">If the retry count was not exceeded, resubmit the message to BizTalk Server, remembering to set the retry time on the message.</span></span> <span data-ttu-id="dfbed-312">消息上下文可提供适配器应当使用的重试计数和重试间隔。</span><span class="sxs-lookup"><span data-stu-id="dfbed-312">The message context provides the retry count and the retry interval the adapter should use.</span></span>  
  
    -   <span data-ttu-id="dfbed-313">如果超过了重试计数，则适配器应尝试将消息移使用**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-313">If the retry count was exceeded, then the adapter should attempt to move the message by using **MoveToNextTransport**.</span></span> <span data-ttu-id="dfbed-314">重新提交和**MoveToNextTransport**消息可以混合同一批处理回 BizTalk Server 中删除项目。</span><span class="sxs-lookup"><span data-stu-id="dfbed-314">The resubmit and **MoveToNextTransport** messages can be mixed with the deletes in the same batch back to BizTalk Server.</span></span> <span data-ttu-id="dfbed-315">这不是必需步骤，但很有用。</span><span class="sxs-lookup"><span data-stu-id="dfbed-315">This is not required, but can be a useful step.</span></span>  
  
-   <span data-ttu-id="dfbed-316">重新提交和**MoveToNextTransport**处理失败的适配器的方法。</span><span class="sxs-lookup"><span data-stu-id="dfbed-316">The resubmit and the **MoveToNextTransport** are ways for the adapter to deal with failures.</span></span> <span data-ttu-id="dfbed-317">但在处理失败的过程中可能会发生失败。</span><span class="sxs-lookup"><span data-stu-id="dfbed-317">But there can be a failure within the processing of the failure.</span></span> <span data-ttu-id="dfbed-318">在这种情况下，在处理来自 BizTalk 服务器的响应 (在**BatchComplete**方法) 的适配器必须创建针对 BizTalk Server，以指示应如何处理这种故障的另一个批处理。</span><span class="sxs-lookup"><span data-stu-id="dfbed-318">In this case, in processing the response from BizTalk Server (in the **BatchComplete** method) the adapter must create another batch against BizTalk Server to indicate what to do with that failure.</span></span>  
  
     <span data-ttu-id="dfbed-319">如果在处理一个失败的过程中发生另一个失败，请按以下步骤进行操作：</span><span class="sxs-lookup"><span data-stu-id="dfbed-319">Follow these steps when processing a failure that occurs within the processing of another failure:</span></span>  
  
    -   <span data-ttu-id="dfbed-320">如果重新提交失败，使用**MoveToNextTransport**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-320">If the resubmit fails, use **MoveToNextTransport**.</span></span>  
  
    -   <span data-ttu-id="dfbed-321">如果**MoveToNextTransport**失败，使用**MoveToSuspendQ**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-321">If the **MoveToNextTransport** fails, use **MoveToSuspendQ**.</span></span>  
  
 <span data-ttu-id="dfbed-322">在 BizTalk Server 上收到成功操作之前，必须一直在 BizTalk Server 上创建批。</span><span class="sxs-lookup"><span data-stu-id="dfbed-322">You must keep creating batches on BizTalk Server until you receive a successful action back on BizTalk Server.</span></span>  
  
### <a name="serialization-of-message-context-property"></a><span data-ttu-id="dfbed-323">消息上下文属性的序列化</span><span class="sxs-lookup"><span data-stu-id="dfbed-323">Serialization of Message Context Property</span></span>  
 <span data-ttu-id="dfbed-324">所有分配给消息上下文属性的对象必须可以序列化。</span><span class="sxs-lookup"><span data-stu-id="dfbed-324">All objects assigned to a message context property must be serializable.</span></span> <span data-ttu-id="dfbed-325">否则，消息引擎将引发类型的异常**E_NOINTERFACE**。</span><span class="sxs-lookup"><span data-stu-id="dfbed-325">Otherwise the Messaging Engine will throw an exception of type **E_NOINTERFACE**.</span></span> <span data-ttu-id="dfbed-326">此返回值暗示正在尝试向某个非序列化对象分配消息上下文。</span><span class="sxs-lookup"><span data-stu-id="dfbed-326">This return value ambiguously represents a non-serializable object attempting to be assigned the message context.</span></span>