---
title: 批处理消息的接收处理 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 32bf0b70-e9d1-4fab-9c74-160e51390700
caps.latest.revision: 8
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 21ce691f51d6c389073c98dadc9ce0f5dfb68504
ms.sourcegitcommit: 266308ec5c6a9d8d80ff298ee6051b4843c5d626
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 06/27/2018
ms.locfileid: "36971054"
---
# <a name="batching-messages-for-receive-processing"></a><span data-ttu-id="3c5ef-102">批处理消息的接收处理</span><span class="sxs-lookup"><span data-stu-id="3c5ef-102">Batching Messages for Receive Processing</span></span>
## <a name="batch-callbacks"></a><span data-ttu-id="3c5ef-103">批回调</span><span class="sxs-lookup"><span data-stu-id="3c5ef-103">Batch Callbacks</span></span>  
 <span data-ttu-id="3c5ef-104">提交的批次接收到消息引擎适配器异步处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-104">Batches submitted by receive adapters to the Messaging Engine are processed asynchronously.</span></span> <span data-ttu-id="3c5ef-105">因此适配器需要一种机制来将绑定到适配器中的某些状态回调，因此它可以成功或失败通知并执行任何必要的清理操作。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-105">Therefore the adapter needs a mechanism to tie a callback to some state in the adapter so it can be notified of success or failure and perform any necessary cleanup actions.</span></span> <span data-ttu-id="3c5ef-106">回调语义非常灵活，以便适配器可以使用一个或这三种方法的组合。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-106">The callback semantics are flexible such that adapters can use one or a combination of three approaches.</span></span> <span data-ttu-id="3c5ef-107">以下是：</span><span class="sxs-lookup"><span data-stu-id="3c5ef-107">These are:</span></span>  
  
- <span data-ttu-id="3c5ef-108">实现在同一对象实例上进行所有回调**IBTBatchCallBack**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-108">All callbacks are made on the same object instance that implements **IBTBatchCallBack**.</span></span>  
  
- <span data-ttu-id="3c5ef-109">当请求一个新的批处理用于关联到适配器中的状态回调时，cookie 传递到引擎中。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-109">The cookie passed into the engine when requesting a new batch is used to correlate the callback to the state in the adapters.</span></span>  
  
- <span data-ttu-id="3c5ef-110">没有实现每个批次不同的回调对象**IBTBatchCallBack**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-110">There is a different callback object for each batch that implements **IBTBatchCallBack**.</span></span> <span data-ttu-id="3c5ef-111">此处的每个对象包含其自己的私有状态。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-111">Here each object holds its own private state.</span></span>  
  
  <span data-ttu-id="3c5ef-112">适配器时已处理批，实现其回叫**IBTBatchCallBack.BatchComplete**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-112">When the batch has been processed, the adapter is called back on its implementation of **IBTBatchCallBack.BatchComplete**.</span></span> <span data-ttu-id="3c5ef-113">由第一个参数，HRESULT 状态指示批处理的总体状态。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-113">The overall status of the batch is indicated by the first parameter, the HRESULT status.</span></span> <span data-ttu-id="3c5ef-114">如果此值是大于或等于零，然后在批处理成功意义上说，该引擎还具有数据的所有权和适配器可以自由地从网络中删除该数据。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-114">If this value is greater than or equal to zero, then the batch was successful in the sense that the engine has ownership of the data and the adapter is free to delete that data from the wire.</span></span> <span data-ttu-id="3c5ef-115">负值状态表示该批次失败： 任何批处理中的操作都成功，适配器负责处理失败。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-115">A negative status indicates that the batch failed: None of the operations in the batch were successful and the adapter is responsible for handling the failure.</span></span>  
  
  <span data-ttu-id="3c5ef-116">如果批失败，适配器需要知道哪一项操作失败，在其中。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-116">If the batch failed, then the adapter needs to know which item in which operation failed.</span></span> <span data-ttu-id="3c5ef-117">例如，假设适配器已从磁盘并将它们到提交读取 20 个文件[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]并用一批。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-117">For example, suppose that the adapter was reading 20 files from disk and submitting them into [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] using a single batch.</span></span> <span data-ttu-id="3c5ef-118">如果第 10 个文件已损坏，适配器需要挂起的文件，然后重新提交剩余 19。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-118">If the tenth file was corrupted, the adapter would need to suspend that one file and resubmit the remaining 19.</span></span> <span data-ttu-id="3c5ef-119">此信息可供适配器中的第二个和第三个参数 —`opCount` （操作计数） 的 short 类型和`operationStatus`，它属于类型 BTBatchOperationStatus []。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-119">This information is available to the adapter in the second and third parameters—`opCount` (operation count) of type short and `operationStatus`, which is of type BTBatchOperationStatus[].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3c5ef-120">在单个批处理对象应永远不会提交一条消息超过一次。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-120">On a single batch object you should never submit a message more than once.</span></span> <span data-ttu-id="3c5ef-121">在同一个批处理多次提交同一个消息对象将导致引擎错误。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-121">Submitting the same message object more than once on the same batch will result in engine errors.</span></span>  
  
 <span data-ttu-id="3c5ef-122">将操作计数指示如何许多类型的操作是批处理中 (的大小**BTBatchOperationStatus**数组)。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-122">The operation count indicates how many types of operations were in the batch (the size of the **BTBatchOperationStatus** array).</span></span> <span data-ttu-id="3c5ef-123">操作状态数组中的每个元素对应于给定的操作类型。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-123">Each element in the operation status array corresponds to a given operation type.</span></span> <span data-ttu-id="3c5ef-124">通过使用**BTBatchOperationStatus**数组，该适配器可以确定哪一项中给定的操作失败，通过查看**BTBatchOperationStatus.MessageStatus**负 HRESULT 的数组表明失败的值。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-124">By using the **BTBatchOperationStatus** array, the adapter can determine which item in a given operation failed by looking at the **BTBatchOperationStatus.MessageStatus** array for negative HRESULT values signifying failure.</span></span> <span data-ttu-id="3c5ef-125">在上述方案中，适配器创建新的批处理包含 19 提交消息和一条消息挂起。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-125">In the scenario above, the adapter creates a new batch containing 19 message submits and one message suspend.</span></span>  
  
 <span data-ttu-id="3c5ef-126">下面的代码段演示如何适配器从引擎通过其传输代理请求一个新的批处理，并将一条消息提交到引擎中使用 cookie 的方法。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-126">The following code fragment shows how an adapter requests a new batch from the engine through its transport proxy and submits a single message into the engine using the cookie approach.</span></span> <span data-ttu-id="3c5ef-127">消息引擎调用**BatchComplete**方法作为批回调处理的整批完成提交消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-127">The Messaging Engine calls the **BatchComplete** method as the batch callback when it has completed processing the entire batch of submitted messages.</span></span>  
  
```  
using Microsoft.BizTalk.TransportProxy.Interop;  
using Microsoft.BizTalk.Message.Interop;  
  
public class MyAdapter :   
                  IBTTransport,   
                  IBTTransportConfig,   
                  IBTTransportControl,  
                  IPersistPropertyBag,   
                  IBaseComponent,  
                  IBTBatchCallBack  
{  
      private IBTTransportProxy _tp;  
  
      public void BatchComplete(      
            Int32                         status,   
            Int16                         opCount,   
            BTBatchOperationStatus[]      operationStatus,   
            System.Object                 callbackCookie)  
      {  
            // Use cookie to correlate callback with work done,  
            // in this example the batch is to submit a single  
            // file the name of which will be in the  
            // callbackCookie  
            string fileName = (string)callbackCookie;  
            if ( status >= 0 )  
                  // DeleteFile from disc  
                  File.Delete(fileName);          
            else  
                  // Rename file to fileName.bad  
                  File.Move(fileName, fileName + ".bad");  
      }  
  
      private void SubmitMessage(  
            IBaseMessage                  msg,   
            string                        fileName)  
      {  
            // Note: Pass in the filename as the cookie  
            IBTTransportBatch batch =   
                  _tp.GetBatch(this, (object)fileName);  
  
            // Add msg to batch for submitting   
            batch.SubmitMessage(msg);   
  
            // Process this batch  
            batch.Done(null);  
      }  
}  
```  
  
 <span data-ttu-id="3c5ef-128">[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] SDK 包括下列适配器的示例： 文件、 HTTP、 MSMQ 和事务性适配器。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-128">The [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] SDK includes samples for the following adapters: File, HTTP, MSMQ, and the Transactional Adapter.</span></span> <span data-ttu-id="3c5ef-129">所有这些适配器是基于名为 BaseAdapter 常见构建基块。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-129">All of these adapters are built on top of a common building block called the BaseAdapter.</span></span> <span data-ttu-id="3c5ef-130">版本 1.0.1 的 baseadapter 包括所有相关的代码分析操作状态并重新生成新的批次提交。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-130">Version 1.0.1 of the BaseAdapter includes all of the relevant code to parse the operation status and rebuild a new batch to submit.</span></span>  
  
## <a name="race-condition"></a><span data-ttu-id="3c5ef-131">争用条件</span><span class="sxs-lookup"><span data-stu-id="3c5ef-131">Race Condition</span></span>  
 <span data-ttu-id="3c5ef-132">解决错误，并决定提交了一批的最终结果的两个任务看似非常简单，但实际上它们依赖于来自不同线程的信息：</span><span class="sxs-lookup"><span data-stu-id="3c5ef-132">The two tasks of resolving errors and deciding the final outcome of a submitted batch seem simple enough, but in fact they rely on information from different threads:</span></span>  
  
- <span data-ttu-id="3c5ef-133">适配器处理错误时，基于传递的信息[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]与适配器的**BatchComplete**回调方法。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-133">The adapter processes errors based on information passed by [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] to the adapter's **BatchComplete** callback method.</span></span> <span data-ttu-id="3c5ef-134">适配器的线程上执行此回调。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-134">This callback executes on the adapter's thread.</span></span>  
  
- <span data-ttu-id="3c5ef-135">**DTCCommitConfirm**上是一种方法**IBTDTCCommitConfirm**对象。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-135">**DTCCommitConfirm** is a method on the **IBTDTCCommitConfirm** object.</span></span> <span data-ttu-id="3c5ef-136">实例**IBTDTCCommitConfirm**对象返回的批处理**ibttransportbatch:: Done**调用。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-136">An instance of the **IBTDTCCommitConfirm** object is returned by the batch **IBTTransportBatch::Done** call.</span></span> <span data-ttu-id="3c5ef-137">此实例是作为在同一线程上**ibttransportbatch:: Done**调用，这是不同于适配器的回调线程。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-137">This instance is on the same thread as the **IBTTransportBatch::Done** call, which is different from the adapter's callback thread.</span></span>  
  
  <span data-ttu-id="3c5ef-138">对于适配器对每个调用**ibttransportbatch:: Done** ，消息引擎会相应地调用的回调方法**BatchComplete**在单独的线程以报告的结果批提交。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-138">For every call that the adapter makes to **IBTTransportBatch::Done** the Messaging Engine makes a corresponding call to the callback method **BatchComplete** in a separate thread to report the result of the batch submission.</span></span> <span data-ttu-id="3c5ef-139">在中**BatchComplete**批的适配器需要提交或回滚该事务基于是否通过或失败。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-139">In **BatchComplete** the adapter needs to commit or roll back the transaction based on whether the batch passed or failed.</span></span> <span data-ttu-id="3c5ef-140">在任一情况下，适配器应然后调用**DTCCommitConfirm**报告事务的状态。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-140">In either case, the adapter should then call **DTCCommitConfirm** to report the status of the transaction.</span></span>  
  
  <span data-ttu-id="3c5ef-141">因为不存在可能出现的争用条件的适配器的实现**BatchComplete**可以假设**IBTDTCCommitConfirm**返回对象**ibttransportbatch:: Done**时，才始终可用**BatchComplete**执行。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-141">A possible race condition exists because the adapter’s implementation of **BatchComplete** can assume that the **IBTDTCCommitConfirm** object returned by **IBTTransportBatch::Done** is always available when **BatchComplete** executes.</span></span> <span data-ttu-id="3c5ef-142">但是， **BatchComplete**可以在单独的消息引擎线程，即使之前调用**ibttransportbatch:: Done**返回。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-142">However, **BatchComplete** can be called in a separate Messaging Engine thread, even before **IBTTransportBatch::Done** returns.</span></span> <span data-ttu-id="3c5ef-143">可能的适配器尝试访问**IBTDTCCommitConfirm**对象的一部分**BatchComplete**实现中，则会访问冲突，因为调用线程不能再存在。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-143">It is possible that when the adapter tries to access the **IBTDTCCommitConfirm** object as a part of the **BatchComplete** implementation, there is an access violation because that calling thread no longer exists.</span></span> <span data-ttu-id="3c5ef-144">使用以下解决方案来避免这种情况。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-144">Use the following solution to avoid this condition.</span></span>  
  
  <span data-ttu-id="3c5ef-145">在以下示例中，通过使用事件解决此问题。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-145">In the following example, the problem is solved by using an event.</span></span> <span data-ttu-id="3c5ef-146">在这里，通过使用事件的属性来访问接口指针。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-146">Here the interface pointer is accessed through a property that uses the event.</span></span> <span data-ttu-id="3c5ef-147">Get 总是等待设置完成，然后继续下一步。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-147">The get always waits for the set to complete before proceeding.</span></span>  
  
```  
protected IBTDTCCommitConfirm CommitConfirm  
{  
      set  
      {  
            this.commitConfirm = value;  
            this.commitConfirmEvent.Set();  
      }  
      get  
      {  
            this.commitConfirmEvent.WaitOne();  
            return this.commitConfirm;  
      }  
}  
protected IBTDTCCommitConfirm commitConfirm = null;  
private ManualResetEvent commitConfirmEvent = new ManualResetEvent(false);  
```  
  
## <a name="batch-status-codes"></a><span data-ttu-id="3c5ef-148">批处理状态代码</span><span class="sxs-lookup"><span data-stu-id="3c5ef-148">Batch Status Codes</span></span>  
 <span data-ttu-id="3c5ef-149">总体批状态代码指示批的结果。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-149">The overall batch status code indicates the outcome of the batch.</span></span> <span data-ttu-id="3c5ef-150">操作状态的提交状态代码为单个消息项。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-150">The operation status gives the submission status code for individual message items.</span></span> <span data-ttu-id="3c5ef-151">批次可能会出于各种原因而失败。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-151">Batches can fail for various reasons.</span></span> <span data-ttu-id="3c5ef-152">可能与安全相关的故障，或者消息可能已提交时引擎已关闭。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-152">There might be a security-related failure, or the message might have been submitted when the engine was shutting down.</span></span> <span data-ttu-id="3c5ef-153">（通常在引擎关闭时它不接受任何新的工作，但要完成的进程内工作。）下表指示在批处理状态或操作状态中返回一些常见的 HRESULT 值。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-153">(Typically when the engine shuts down it does not accept any new work but does allow in-process work to be completed.) The following table indicates some common HRESULT values that are returned either in the batch status or the operation status.</span></span> <span data-ttu-id="3c5ef-154">它还指示它们是否成功或失败代码。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-154">It also indicates whether these are success or failure codes.</span></span> <span data-ttu-id="3c5ef-155">正确处理这些代码的方法是更全面中所述[如何处理适配器故障](../core/how-to-handle-adapter-failures.md)。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-155">The proper handling of these codes is described more fully in [How to Handle Adapter Failures](../core/how-to-handle-adapter-failures.md).</span></span>  
  
|<span data-ttu-id="3c5ef-156">代码 （BTTransportProxy 的类中定义）</span><span class="sxs-lookup"><span data-stu-id="3c5ef-156">Code (defined in the class BTTransportProxy)</span></span>|<span data-ttu-id="3c5ef-157">成功/失败代码</span><span class="sxs-lookup"><span data-stu-id="3c5ef-157">Success/failure code</span></span>|<span data-ttu-id="3c5ef-158">Description</span><span class="sxs-lookup"><span data-stu-id="3c5ef-158">Description</span></span>|  
|----------------------------------------------------|---------------------------|-----------------|  
|<span data-ttu-id="3c5ef-159">BTS_S_EPM_SECURITY_CHECK_FAILED</span><span class="sxs-lookup"><span data-stu-id="3c5ef-159">BTS_S_EPM_SECURITY_CHECK_FAILED</span></span>|<span data-ttu-id="3c5ef-160">成功</span><span class="sxs-lookup"><span data-stu-id="3c5ef-160">Success</span></span>|<span data-ttu-id="3c5ef-161">该端口已配置为执行安全检查和删除身份验证失败的消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-161">The port was configured to perform a security check and drop messages that failed authentication.</span></span> <span data-ttu-id="3c5ef-162">适配器应挂起返回此状态代码的批处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-162">Adapters should not suspend batches that return this status code.</span></span>|  
|<span data-ttu-id="3c5ef-163">BTS_S_EPM_MESSAGE_SUSPENDED，则</span><span class="sxs-lookup"><span data-stu-id="3c5ef-163">BTS_S_EPM_MESSAGE_SUSPENDED</span></span>|<span data-ttu-id="3c5ef-164">成功</span><span class="sxs-lookup"><span data-stu-id="3c5ef-164">Success</span></span>|<span data-ttu-id="3c5ef-165">指示一个或多个消息被挂起，并且该引擎还具有数据的所有权。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-165">Indicates that one or more messages were suspended, and the engine has ownership of the data.</span></span> <span data-ttu-id="3c5ef-166">它是成功代码，因为消息引擎已接受提交消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-166">It is a success code in that the Messaging Engine has accepted the message submission.</span></span>|  
|<span data-ttu-id="3c5ef-167">E_BTS_URL_DISALLOWED</span><span class="sxs-lookup"><span data-stu-id="3c5ef-167">E_BTS_URL_DISALLOWED</span></span>|<span data-ttu-id="3c5ef-168">失败</span><span class="sxs-lookup"><span data-stu-id="3c5ef-168">Failure</span></span>|<span data-ttu-id="3c5ef-169">一条消息已提交具有无效**InboundTransportLocation**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-169">A message was submitted with an invalid **InboundTransportLocation**.</span></span>|  
  
## <a name="batch-operations"></a><span data-ttu-id="3c5ef-170">批处理操作</span><span class="sxs-lookup"><span data-stu-id="3c5ef-170">Batch Operations</span></span>  
 <span data-ttu-id="3c5ef-171">下表详细说明的成员方法和操作**IBTTransportBatch**对象适配器用于将工作添加到给定的批。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-171">The following table details the member methods and operations of the **IBTTransportBatch** object that the adapter uses to add work to a given batch.</span></span>  
  
|<span data-ttu-id="3c5ef-172">方法名称</span><span class="sxs-lookup"><span data-stu-id="3c5ef-172">Method name</span></span>|<span data-ttu-id="3c5ef-173">操作类型</span><span class="sxs-lookup"><span data-stu-id="3c5ef-173">Operation type</span></span>|<span data-ttu-id="3c5ef-174">Description</span><span class="sxs-lookup"><span data-stu-id="3c5ef-174">Description</span></span>|  
|-----------------|--------------------|-----------------|  
|<span data-ttu-id="3c5ef-175">**SubmitMessage**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-175">**SubmitMessage**</span></span>|<span data-ttu-id="3c5ef-176">提交</span><span class="sxs-lookup"><span data-stu-id="3c5ef-176">Submit</span></span>|<span data-ttu-id="3c5ef-177">将消息提交到引擎中。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-177">Submits a message into the engine.</span></span>|  
|<span data-ttu-id="3c5ef-178">**SubmitResponseMessage**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-178">**SubmitResponseMessage**</span></span>|<span data-ttu-id="3c5ef-179">提交</span><span class="sxs-lookup"><span data-stu-id="3c5ef-179">Submit</span></span>|<span data-ttu-id="3c5ef-180">将响应消息提交到引擎。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-180">Submits a response message into the engine.</span></span> <span data-ttu-id="3c5ef-181">这是在要求-响应对中的响应消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-181">This is the response message in a solicit-response pair.</span></span>|  
|<span data-ttu-id="3c5ef-182">**DeleteMessage**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-182">**DeleteMessage**</span></span>|<span data-ttu-id="3c5ef-183">DELETE</span><span class="sxs-lookup"><span data-stu-id="3c5ef-183">Delete</span></span>|<span data-ttu-id="3c5ef-184">删除适配器已成功传输通过网络使用非阻塞发送一条消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-184">Deletes a message that an adapter has successfully transmitted over the wire using a non-blocking send.</span></span> <span data-ttu-id="3c5ef-185">使用阻塞发送的适配器无需调用此方法，因为消息引擎将删除该适配器的代表如果适配器返回`true`从**TransmitMesssage**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-185">Adapters that use blocking sends do not need to call this method because the Messaging Engine will delete it on the adapter's behalf if the adapter returns `true` from **TransmitMesssage**.</span></span>|  
|<span data-ttu-id="3c5ef-186">**MoveToSuspendQ**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-186">**MoveToSuspendQ**</span></span>|<span data-ttu-id="3c5ef-187">MoveToSuspendQ</span><span class="sxs-lookup"><span data-stu-id="3c5ef-187">MoveToSuspendQ</span></span>|<span data-ttu-id="3c5ef-188">将一条消息移至挂起队列。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-188">Moves a message into the Suspended queue.</span></span>|  
|<span data-ttu-id="3c5ef-189">**重新提交**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-189">**Resubmit**</span></span>|<span data-ttu-id="3c5ef-190">重新提交</span><span class="sxs-lookup"><span data-stu-id="3c5ef-190">Resubmit</span></span>|<span data-ttu-id="3c5ef-191">一条消息，应在更高版本时传输重试请求。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-191">Requests that a message should be retried for transmission at a later time.</span></span> <span data-ttu-id="3c5ef-192">这通常称为后传输尝试已失败。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-192">This is typically called after a transmission attempt has failed.</span></span>|  
|<span data-ttu-id="3c5ef-193">**MoveToNextTransport**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-193">**MoveToNextTransport**</span></span>|<span data-ttu-id="3c5ef-194">MoveToNextTransport</span><span class="sxs-lookup"><span data-stu-id="3c5ef-194">MoveToNextTransport</span></span>|<span data-ttu-id="3c5ef-195">请求，如果一条消息将传输使用其备份传输。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-195">Requests that a message be transmitted using its backup transport.</span></span> <span data-ttu-id="3c5ef-196">已用完所有重试后，通常调用。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-196">Typically called after all retries have been exhausted.</span></span> <span data-ttu-id="3c5ef-197">如果存在没有备份传输，则此方法将失败</span><span class="sxs-lookup"><span data-stu-id="3c5ef-197">If no backup transport is present this method will fail</span></span>|  
|<span data-ttu-id="3c5ef-198">**SubmitRequestMessage**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-198">**SubmitRequestMessage**</span></span>|<span data-ttu-id="3c5ef-199">SubmitRequest</span><span class="sxs-lookup"><span data-stu-id="3c5ef-199">SubmitRequest</span></span>|<span data-ttu-id="3c5ef-200">提交请求消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-200">Submits a request message.</span></span> <span data-ttu-id="3c5ef-201">这是请求-响应对中的请求消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-201">This is a request message in a request-response pair.</span></span>|  
|<span data-ttu-id="3c5ef-202">**CancelRequestForResponse**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-202">**CancelRequestForResponse**</span></span>|<span data-ttu-id="3c5ef-203">CancelRequestForResponse</span><span class="sxs-lookup"><span data-stu-id="3c5ef-203">CancelRequestForResponse</span></span>|<span data-ttu-id="3c5ef-204">通知引擎，该适配器不再想要等待的请求-响应对中的响应消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-204">Notifies the engine that the adapter no longer wishes to wait for the response message in a request-response pair.</span></span>|  
|<span data-ttu-id="3c5ef-205">**Clear**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-205">**Clear**</span></span>|<span data-ttu-id="3c5ef-206">不适用</span><span class="sxs-lookup"><span data-stu-id="3c5ef-206">NA</span></span>|<span data-ttu-id="3c5ef-207">清除批处理中的所有工作。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-207">Clears all work from the batch.</span></span>|  
|<span data-ttu-id="3c5ef-208">**完成**</span><span class="sxs-lookup"><span data-stu-id="3c5ef-208">**Done**</span></span>|<span data-ttu-id="3c5ef-209">不适用</span><span class="sxs-lookup"><span data-stu-id="3c5ef-209">NA</span></span>|<span data-ttu-id="3c5ef-210">将提交一批引擎进行处理的消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-210">Submits a batch of messages to the engine for processing.</span></span>|  
  
## <a name="batch-management"></a><span data-ttu-id="3c5ef-211">Batch 管理</span><span class="sxs-lookup"><span data-stu-id="3c5ef-211">Batch Management</span></span>  
 <span data-ttu-id="3c5ef-212">消息引擎中的本机代码中实现批处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-212">Batches are implemented in native code in the Messaging Engine.</span></span> <span data-ttu-id="3c5ef-213">出于此原因在托管代码中编写的适配器应释放运行时可调用包装 (RCW) 批处理使用批处理完成之后。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-213">For this reason an adapter written in managed code should release the runtime callable wrapper (RCW) for the batch after it has finished with the batch.</span></span> <span data-ttu-id="3c5ef-214">这是通过托管代码中使用**Marshal.ReleaseComObject** API。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-214">This is done in managed code by using the **Marshal.ReleaseComObject** API.</span></span> <span data-ttu-id="3c5ef-215">务必要记住，应在一段时间中调用此 API 循环播放，直到返回的引用计数达到零时。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-215">It is important to remember that this API should be called in a while loop until the returned reference count reaches zero.</span></span>  
  
 [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]<span data-ttu-id="3c5ef-216"> 处理批中的同步消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-216"> processes messages synchronously within a batch.</span></span> <span data-ttu-id="3c5ef-217">同时，它提供的信息在适配器中的某些优化机会通过调整应用程序域中的批大小，均可以处理许多批处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-217">Many batches may be processed concurrently, which may provide an opportunity for some optimization in the adapter by adjusting the batch size in the application domain.</span></span> <span data-ttu-id="3c5ef-218">例如，您可能会处理 FTP 站点上的所有文件 （直到命中某些限制）。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-218">For example, you might process all the files on an FTP site (until some limit is hit).</span></span> <span data-ttu-id="3c5ef-219">在 SAP 的情况下可能有数量的消息，然后作为批处理提交到处理单个流。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-219">In the case of SAP you might process a single stream into a number of messages that are then submitted as a batch.</span></span>  
  
 <span data-ttu-id="3c5ef-220">适配器用于将操作的批处理回[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]不需要完全对应于消息的列表，[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]给适配器。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-220">The batch used by an adapter to pass operations back to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] does not need to exactly correspond to the list of messages that [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] gives to the adapter.</span></span> <span data-ttu-id="3c5ef-221">换而言之，当执行事务性发送必须重新提交操作将拆分**MoveToNextTransport**并**MoveToSuspendQ**到单独的批。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-221">In other words, when doing transactional sends you must split the resubmit operations **MoveToNextTransport** and **MoveToSuspendQ** into separate batches.</span></span> <span data-ttu-id="3c5ef-222">许多适配器对一批消息的多个终结点提交到单独的进一步处理的消息的列表进行排序。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-222">Many adapters sort a batch of messages that have been submitted for multiple endpoints into separate lists of messages for further processing.</span></span>  
  
 <span data-ttu-id="3c5ef-223">在于没有 （除了那些与事务关联） 的规则与中的消息批处理相关联[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-223">The point is that there are no rules (besides those associated with the transaction) associated with message batching in [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="3c5ef-224">批处理是只需输入和输出消息的分块的消息的适配器的特定于实现的方法[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-224">Batching is simply an implementation-specific way for the adapter to chunk messages into and out of [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span>  
  
 <span data-ttu-id="3c5ef-225">适配器可以批处理消息从多个较小批[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]提供它到较大的批的响应[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-225">An adapter can batch messages from multiple smaller batches that [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] has given it into a larger batch for the response to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="3c5ef-226">这可能是在面对大量非常小的消息的事务性适配器中进行了显著优化。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-226">This might be a significant optimization in transactional adapters that are dealing with large numbers of very small messages.</span></span> <span data-ttu-id="3c5ef-227">它最小化"的每个消息的事务总数"比率。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-227">It minimizes the "total number of transactions per message" ratio.</span></span>  
  
 <span data-ttu-id="3c5ef-228">通常[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]生成的 5 到 10 的消息之间的发送端批处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-228">Typically [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] produces send-side batches of between 5 and 10 messages.</span></span> <span data-ttu-id="3c5ef-229">如果这些是非常小的消息，适配器可能会将批最多 100 个消息或详细信息之前它将删除的事务性批处理提交回[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-229">If these are very small messages, an adapter might batch up to 100 messages or more before it submits a transactional batch of deletes back to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)].</span></span> <span data-ttu-id="3c5ef-230">一种优化，此类不是可轻松实现;您必须确保消息永远不会在适配器内存中，获取遇到无休止地等待一些必须满足的阈值。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-230">An optimization like this is not easy to implement; you must make sure that messages never get stuck in the adapter memory, waiting endlessly for some threshold to be met.</span></span>  
  
 <span data-ttu-id="3c5ef-231">批处理的重要性所示的性能数字[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]如 MQSeries 的高吞吐量适配器。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-231">The significance of batching can be seen in the performance numbers for [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] for the high-throughput adapters like MQSeries.</span></span> <span data-ttu-id="3c5ef-232">这些适配器可以在至少两次经常与将它们发送接收消息。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-232">In these adapters, messages are received at least twice as often as they are sent.</span></span> <span data-ttu-id="3c5ef-233">默认情况下，接收适配器使用批 100 个消息和发送适配器将使用默认值[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]赋予它的批处理。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-233">By default the receive adapter uses batches of 100 messages and the send adapter uses the default [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] batch it is given.</span></span>  
  
## <a name="transactional-batches"></a><span data-ttu-id="3c5ef-234">在事务性批</span><span class="sxs-lookup"><span data-stu-id="3c5ef-234">Transactional Batches</span></span>  
 <span data-ttu-id="3c5ef-235">当你编写的适配器的创建事务对象，并将其到[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]，表明您接受负责编写代码，执行以下操作：</span><span class="sxs-lookup"><span data-stu-id="3c5ef-235">When you write an adapter that creates a transaction object and hands it to [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)], you are accepting responsibility for writing code that does the following:</span></span>  
  
- <span data-ttu-id="3c5ef-236">确定批处理操作的最终结果： 提交或结束事务。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-236">Decides the final outcome of the batch operation: to either commit or end the transaction.</span></span> <span data-ttu-id="3c5ef-237">这可能取决于其他事务分支的作用域内的此事务不是[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]相关，如写入消息队列 (MSMQ) 队列或事务性数据库操作。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-237">This may depend upon other transactional branches within the scope of this one transaction that are not [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] dependent, such as writing to an Message Queuing (MSMQ) queue or a transactional database operation.</span></span>  
  
- <span data-ttu-id="3c5ef-238">告知[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]通过调用将最终结果**IBTDTCCommitConfirm.DTCCommitConfirm**方法。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-238">Informs [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] of the final outcome by calling the **IBTDTCCommitConfirm.DTCCommitConfirm** method.</span></span> <span data-ttu-id="3c5ef-239">返回`true`指示成功提交事务; 返回`false`表示失败并回滚该事务。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-239">Returning `true` indicates a successful commit of the transaction; returning `false` signifies failure and rollback of the transaction.</span></span>  
  
  <span data-ttu-id="3c5ef-240">适配器必须通知[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]要维护其内部的事务的最终结果跟踪数据。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-240">The adapter must inform [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] about the final outcome of the transaction to maintain its internal tracking data.</span></span> <span data-ttu-id="3c5ef-241">适配器通知[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]的结果通过调用**DTCCommitConfirm**。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-241">The adapter informs [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] of the outcome by calling **DTCCommitConfirm**.</span></span> <span data-ttu-id="3c5ef-242">如果适配器不会执行此操作，会发生重大内存泄漏和 MSDTC 事务可能会超时，并且尽管成功完成其操作失败。</span><span class="sxs-lookup"><span data-stu-id="3c5ef-242">If the adapter does not do this, a significant memory leak occurs and the MSDTC transaction could time out and fail despite its operations completing successfully.</span></span>