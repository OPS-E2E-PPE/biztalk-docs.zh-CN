---
title: 适配器如何处理大消息 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: c48671fd-b6cf-4507-92b4-35a4cd135714
caps.latest.revision: 15
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 131d757e1df910b33d92bbc7b02a576edad8efcd
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65344249"
---
# <a name="how-adapters-handle-large-messages"></a><span data-ttu-id="51e98-102">适配器如何处理大消息</span><span class="sxs-lookup"><span data-stu-id="51e98-102">How Adapters Handle Large Messages</span></span>
<span data-ttu-id="51e98-103">BizTalk 消息引擎可以处理非常大的消息，并施加的一条消息的最大大小没有限制。</span><span class="sxs-lookup"><span data-stu-id="51e98-103">The BizTalk Messaging Engine can process very large messages and imposes no restriction on the maximum size of a message.</span></span> <span data-ttu-id="51e98-104">但是，应该考虑限制消息大小，以便获得最佳性能和资源管理。</span><span class="sxs-lookup"><span data-stu-id="51e98-104">However, you should consider limits to message size to maintain optimum performance and resource management.</span></span> <span data-ttu-id="51e98-105">随着消息大小的增加的每个第二个减少处理的消息数。</span><span class="sxs-lookup"><span data-stu-id="51e98-105">As message size increases the number of messages processed per second decreases.</span></span> <span data-ttu-id="51e98-106">平均消息大小、 消息类型和正在处理的消息数，请考虑[!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)]时设计使用方案和容量规划。</span><span class="sxs-lookup"><span data-stu-id="51e98-106">Consider the average message size, message type, and number of messages being processed by [!INCLUDE[btsBizTalkServerNoVersion](../includes/btsbiztalkservernoversion-md.md)] when designing your scenario and planning for capacity.</span></span>  
  
## <a name="stream-based-processing"></a><span data-ttu-id="51e98-107">基于 Stream 的处理</span><span class="sxs-lookup"><span data-stu-id="51e98-107">Stream-Based Processing</span></span>  
 <span data-ttu-id="51e98-108">请务必在开发适配器时牢记处理大消息。</span><span class="sxs-lookup"><span data-stu-id="51e98-108">It is important to keep large message handling in mind when developing adapters.</span></span> <span data-ttu-id="51e98-109">整个数据流加载到内存中而不考虑其大小是强烈建议不要使用，因为这可能会无法停止 BizTalk Server 进程。</span><span class="sxs-lookup"><span data-stu-id="51e98-109">Loading the entire data stream into memory regardless of its size is strongly discouraged because this could potentially stop the BizTalk Server process.</span></span> <span data-ttu-id="51e98-110">根据大小和该引擎在任何给定时间处理的消息数，虚拟内存不足可能会成为问题。</span><span class="sxs-lookup"><span data-stu-id="51e98-110">Depending on the size and number of messages that the engine is processing at any given time, low virtual memory could become a problem.</span></span> <span data-ttu-id="51e98-111">相反，应处理消息以流的形式，如下所示：</span><span class="sxs-lookup"><span data-stu-id="51e98-111">Instead, messages should be processed in a streaming fashion as follows:</span></span>  
  
- <span data-ttu-id="51e98-112">**入站消息。**</span><span class="sxs-lookup"><span data-stu-id="51e98-112">**Inbound messages.**</span></span> <span data-ttu-id="51e98-113">入站消息的网络流附加到 BizTalk 消息离开"拉拽"的流到 BizTalk 消息引擎接收适配器。</span><span class="sxs-lookup"><span data-stu-id="51e98-113">For inbound messages the network stream is attached to the BizTalk message by the receive adapter leaving the "pulling" of the stream to the BizTalk Messaging Engine.</span></span>  
  
- <span data-ttu-id="51e98-114">**出站消息。**</span><span class="sxs-lookup"><span data-stu-id="51e98-114">**Outbound messages.**</span></span> <span data-ttu-id="51e98-115">对于出站消息，适配器负责提取流。</span><span class="sxs-lookup"><span data-stu-id="51e98-115">For outbound messages the adapter is responsible for pulling the stream.</span></span> <span data-ttu-id="51e98-116">这有效地提取从 MessageBox 数据库的流，并通过发送管道。</span><span class="sxs-lookup"><span data-stu-id="51e98-116">This effectively pulls the stream from the MessageBox database and though the send pipeline.</span></span> <span data-ttu-id="51e98-117">适配器应通过网络传输流的形式发送数据。</span><span class="sxs-lookup"><span data-stu-id="51e98-117">The adapter should send the data over the wire in a streaming fashion.</span></span>  
  
  <span data-ttu-id="51e98-118">下图显示了基于流的消息引擎在接收端处理。</span><span class="sxs-lookup"><span data-stu-id="51e98-118">The following figure shows stream-based processing on the receive side of the Messaging Engine.</span></span>  
  
  <span data-ttu-id="51e98-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span><span class="sxs-lookup"><span data-stu-id="51e98-119">![](../core/media/streambasedprocessing.gif "Streambasedprocessing")</span></span>  
  
  <span data-ttu-id="51e98-120">适配器提交到引擎的消息时它应将其数据流附加到 BizTalk 消息。</span><span class="sxs-lookup"><span data-stu-id="51e98-120">When an adapter submits a message to the engine it should attach its data stream to the BizTalk message.</span></span> <span data-ttu-id="51e98-121">对于某些适配器，这意味着实现网络流。</span><span class="sxs-lookup"><span data-stu-id="51e98-121">For some adapters this may mean implementing a network stream.</span></span> <span data-ttu-id="51e98-122">当提交消息时，引擎执行接收管道。</span><span class="sxs-lookup"><span data-stu-id="51e98-122">When the message is submitted, the engine executes the receive pipeline.</span></span> <span data-ttu-id="51e98-123">在管道执行期间想要更改的数据的管道组件将克隆该消息，绑定到上一个消息流来自新的消息流。</span><span class="sxs-lookup"><span data-stu-id="51e98-123">During pipeline execution, the pipeline components that want to change the data clone the message, wiring up the stream from the new message to the stream on the previous message.</span></span> <span data-ttu-id="51e98-124">管道执行完毕后，消息引擎将从管道中取出消息，并执行循环中读取该消息上的流。</span><span class="sxs-lookup"><span data-stu-id="51e98-124">After the pipeline has been executed, the Messaging Engine takes a message out of the pipeline and executes a loop reading the stream on that message.</span></span> <span data-ttu-id="51e98-125">此读取流的调用在上一个流，因此，在返回到网络流上反过来调用读取对先前流读取。</span><span class="sxs-lookup"><span data-stu-id="51e98-125">This reading of the stream invokes a read on the previous stream, which in turn invokes a read on the previous stream, and so on back to the network stream.</span></span> <span data-ttu-id="51e98-126">引擎定期刷新数据到 MessageBox，以维护平面内存模型。</span><span class="sxs-lookup"><span data-stu-id="51e98-126">The engine periodically flushes the data to the MessageBox to maintain a flat memory model.</span></span>  
  
  <span data-ttu-id="51e98-127">**故障排除提示：** 在发送端适配器负责读取流。</span><span class="sxs-lookup"><span data-stu-id="51e98-127">**Troubleshooting Tip:** On the send side, the adapter is responsible for reading the stream.</span></span> <span data-ttu-id="51e98-128">如果发送适配器要读取的任何消息上下文属性升级或写入在发送管道中，读取整个流之前，可能不会写入这些属性。</span><span class="sxs-lookup"><span data-stu-id="51e98-128">If the send adapter wants to read any message context properties that are promoted or written in the send pipeline, these properties may not be written until the entire stream is read.</span></span> <span data-ttu-id="51e98-129">仅当完全读取流时，适配器才能确保保证所有管道组件已完成执行。</span><span class="sxs-lookup"><span data-stu-id="51e98-129">Only when the stream has been completely read can the adapter be sure that all of the pipeline components have finished executing.</span></span>  
  
## <a name="locating-a-specific-byte-in-the-stream"></a><span data-ttu-id="51e98-130">在 Stream 中定位特定字节</span><span class="sxs-lookup"><span data-stu-id="51e98-130">Locating a Specific Byte in the Stream</span></span>  
 <span data-ttu-id="51e98-131">有一个适配器可能需要在其中找到流返回到开始处，以便处理需要挂起的失败的消息的方案。</span><span class="sxs-lookup"><span data-stu-id="51e98-131">There are scenarios in which an adapter may need to locate the stream back to the beginning to handle failed messages that need to be suspended.</span></span> <span data-ttu-id="51e98-132">此示例是 HTTP 适配器接收使用 chunked 编码来提交响应消息，要求-响应对中的数据。</span><span class="sxs-lookup"><span data-stu-id="51e98-132">An example of this is an HTTP adapter that is receiving data using chunked encoding to submit the response message in a solicit-response pair.</span></span>  
  
 <span data-ttu-id="51e98-133">但是，在许多情况下您可能无法跟踪数据流。</span><span class="sxs-lookup"><span data-stu-id="51e98-133">However, in many scenarios you may not be able to trace the data stream.</span></span> <span data-ttu-id="51e98-134">例如，考虑 HTTP 适配器接收使用 chunked 编码数据。</span><span class="sxs-lookup"><span data-stu-id="51e98-134">For example, consider an HTTP adapter receiving data using chunked encoding.</span></span> <span data-ttu-id="51e98-135">数据流的设计要便于您可以找到失败的消息，适配器将需要它读取时，在内存中或磁盘上缓存数据。</span><span class="sxs-lookup"><span data-stu-id="51e98-135">For the data stream to be designed so you can find the messages that failed, the adapter would need to cache the data as it is read, either in memory or onto disk.</span></span> <span data-ttu-id="51e98-136">显然，这不是最佳且需要的其他资源。</span><span class="sxs-lookup"><span data-stu-id="51e98-136">Clearly this is not optimal and requires additional resources.</span></span> <span data-ttu-id="51e98-137">此外，许多开箱管道组件进行操作以只进流的形式。</span><span class="sxs-lookup"><span data-stu-id="51e98-137">Further, many of the out-of-the-box pipeline components operate in a forward-only streaming fashion.</span></span> <span data-ttu-id="51e98-138">对于这种情况在 SDK 中的 BaseAdapter 使用名为的帮助器类**为 VirtualStream**。</span><span class="sxs-lookup"><span data-stu-id="51e98-138">For these scenarios the BaseAdapter in the SDK uses a helper class called **VirtualStream**.</span></span> <span data-ttu-id="51e98-139">包含此功能的文件命名为 VirtualStream.cs。</span><span class="sxs-lookup"><span data-stu-id="51e98-139">The file that contains this functionality is named VirtualStream.cs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="51e98-140">VirtualStream.cs 文件位于以下两个位置管道 SDK 示例 —: SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler 和 SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm。</span><span class="sxs-lookup"><span data-stu-id="51e98-140">The VirtualStream.cs file is located in two locations under the Pipelines SDK Samples—SDK\Samples\Pipelines\ArbitraryXPathPropertyHandler and SDK\Samples\Pipelines\SchemaResolverComponent\SchemaResolverFlatFileDasm.</span></span>  
  
 <span data-ttu-id="51e98-141">虚拟流背后的理念是直到它达到的阈值，对其数据将溢出到磁盘上的安全位置，在流中的数据被缓存到内存流中。</span><span class="sxs-lookup"><span data-stu-id="51e98-141">The idea behind a virtual stream is that the data in the stream is cached in a memory stream until it reaches a threshold, over which the data is overflowed to a secure location on disk.</span></span> <span data-ttu-id="51e98-142">流已关闭后会自动删除磁盘文件。</span><span class="sxs-lookup"><span data-stu-id="51e98-142">After the stream is closed the disk file is automatically deleted.</span></span> <span data-ttu-id="51e98-143">以这种方式，可以设计为只进流。</span><span class="sxs-lookup"><span data-stu-id="51e98-143">Forward-only streams can be designed in this way.</span></span>