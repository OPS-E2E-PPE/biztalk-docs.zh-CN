---
title: "持久性和业务流程引擎 |Microsoft 文档"
ms.custom: 
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: 
ms.suite: 
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- orchestration engine, persistence
- persistence
- orchestration engine, serialization
ms.assetid: 088230ef-13b3-440b-9875-6449f29dd5c6
caps.latest.revision: "11"
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 5e9e1c8b158d313681a6e1374a586ca957b1aa15
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
---
# <a name="persistence-and-the-orchestration-engine"></a>持久化和业务流程引擎
状态持久性、 管理和还原形成了大量基本功能的业务流程引擎的基础。 具体而言，持久性至关重要的正确运行：  
  
-   冻结和 rehydration  
  
-   计算机不可知执行和 rehydration  
  
-   补偿模型  
  
-   受控的系统关闭  
  
-   恢复  
  
 业务流程引擎将保存到持久性存储区的各个点，在正在运行的业务流程实例的整个状态，以便在内存中，该实例可以更高版本完全还原。 状态包括：  
  
-   引擎，包括其当前进行的内部状态。  
  
-   维护状态信息和正在使用的业务流程的任何.NET 组件的状态。  
  
-   消息和变量的值。  
  
## <a name="persistence-points"></a>持久性点  
 业务流程引擎保存在不同的时间点正在运行的业务流程实例的状态。 如果它需要 rehydrate 业务流程实例、 从受控关机，启动或从意外关闭恢复，它将从最后一个持久点时，运行业务流程实例，就像其他任何内容出现。 例如，如果收到一条消息，但没有发生意外的关闭之前可以保存状态，它接收的消息，并将它再次出现在重新启动时将不会记录引擎。 引擎会将业务流程的状态保存在下列情况：  
  
-   结束一个事务范围。  
  
    -   引擎保存在一个事务范围末尾的状态，以便明确，定义应从该处恢复业务流程的点并以便补偿可以执行正确如有必要。  
  
    -   业务流程将继续运行后面的作用域，如果持久性成功;否则，将调用相应的异常处理程序。  
  
    -   如果在作用域是事务性的且原子，引擎将时它会将提交保存末尾的原子作用域的状态。  
  
    -   如果作用域是事务性的且长时间运行，则引擎将生成一个新的事务，并将完成状态的运行时保存范围完成时。  
  
-   调试断点为止。  
  
-   发送的消息。 唯一的例外是在原子事务范围内从发送消息时。  
  
-   业务流程以异步方式启动另一个业务流程与**启动 Orchestration**形状。  
  
-   业务流程实例处于挂起状态。  
  
-   当系统询问业务流程引擎若要关闭的情况下时，它将尝试保存控制信息，以及所有运行的业务流程实例的当前状态，以便才能继续执行时再次启动时运行它们。 如果引擎都不能成功保存的当前状态，引擎将恢复发生之前关闭最后一个持久点中的业务流程实例。 这适用于在受控的条件以及异常终止系统关闭。  
  
-   引擎确定，应已冻结实例。  
  
-   业务流程实例已完成。  
  
## <a name="serialization"></a>序列化  
 您的业务流程直接或间接引用的所有对象实例 （通过其他对象一样） 必须是可序列化你的业务流程的状态要保留的。 有以下两种例外情况：  
  
-   你可以在原子事务声明的不可序列化对象。 因为原子作用域不包含持久性点时，可以执行此操作。  
  
-   不是可序列化的类; System.Xml.XmlDocument。它作为一种特殊情况进行处理，并可以使用任意位置。  
  
> [!CAUTION]
>  为了使要持久化.NET 对象，它必须标记为可序列化。  
  
> [!NOTE]
>  不能使用标准.NET 序列化过程持续 COM 对象。 如果你想要调用 COM 对象在原子事务之外，你必须在.NET 对象，即.NET 可序列化并且知道如何保存和还原的 COM 对象的状态中包装的 COM 对象。  
  
## <a name="system-shutdown"></a>系统关闭  
 当系统询问业务流程引擎若要关闭的情况下时，它将尝试保存控制信息，以及所有运行的业务流程实例的当前状态，以便才能继续执行时再次启动时运行它们。 如果引擎都不能成功保存的当前状态，引擎将恢复发生之前关闭最后一个持久点中的业务流程实例。 这适用于在受控的条件以及异常终止系统关闭。  
  
## <a name="recovery"></a>恢复  
 引擎定期将保存到持久性存储区的状态信息的业务流程实例，并将保存发生系统关闭时的状态。  
  
 当业务流程实例出于任何原因失败异常时，可以从上次保持的状态恢复实例，并且它可以继续运行，好像没有中断。 这是 true，即使原始服务器实例上运行超出出于某种原因; 的服务实例可以只需恢复在单独的计算机上运行。 由于此多服务器恢复模型，你不再需要群集。  
  
## <a name="see-also"></a>另请参阅  
 [业务流程冻结和 Rehydration](../core/orchestration-dehydration-and-rehydration.md)