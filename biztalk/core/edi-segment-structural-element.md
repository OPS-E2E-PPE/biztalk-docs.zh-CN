---
title: EDI 段结构元素 |Microsoft Docs
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 1f474a3d-004a-4981-b155-b0a5775918ba
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: e1afe63e8830166c388a8d1ffc65782b6a473aa9
ms.sourcegitcommit: 381e83d43796a345488d54b3f7413e11d56ad7be
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/07/2019
ms.locfileid: "65389183"
---
# <a name="edi-segment-structural-element"></a><span data-ttu-id="6b7c7-102">EDI 段结构元素</span><span class="sxs-lookup"><span data-stu-id="6b7c7-102">EDI Segment Structural Element</span></span>
<span data-ttu-id="6b7c7-103">段包含一个或多个数据元素，且是消息中的信息的中间单元。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-103">The segment contains one or more data elements, and is an intermediate unit of information in the message.</span></span> <span data-ttu-id="6b7c7-104">每个段以三个字符的数据段标识符开头和结尾段终止符 （默认情况下为撇号 （'））。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-104">Each segment starts with a three-character data segment identifier, and ends with a segment terminator (by default the apostrophe (')).</span></span> <span data-ttu-id="6b7c7-105">在段中的数据元素由数据元素分隔符分隔。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-105">The data elements within the segment are separated by data element separators.</span></span> <span data-ttu-id="6b7c7-106">数据元素分隔符为加号 （+） 默认情况下。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-106">The data element separator is by default the plus sign (+).</span></span> <span data-ttu-id="6b7c7-107">一个段归类为必需或可选。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-107">A segment is classified as Mandatory or Optional.</span></span> <span data-ttu-id="6b7c7-108">可以在两个贸易合作伙伴之间或后备贸易合作伙伴协议的一部分的协议设置用于传出交换的分隔符。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-108">Separators for outgoing interchanges can be set in the agreements between two trading partners or as part of fallback trading partner agreement.</span></span>  
  
## <a name="nesting"></a><span data-ttu-id="6b7c7-109">嵌套</span><span class="sxs-lookup"><span data-stu-id="6b7c7-109">Nesting</span></span>  
 <span data-ttu-id="6b7c7-110">可能会在名为层次结构关系中分组段**嵌套**。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-110">Segments may be grouped in a hierarchical relationship called **nesting**.</span></span> <span data-ttu-id="6b7c7-111">有两个不同类型的嵌套： 显式和隐式。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-111">There are two distinct type of nesting: explicit and implicit.</span></span> <span data-ttu-id="6b7c7-112">任何一个交换中可以使用只有一个类型的嵌套。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-112">Within any one interchange only one type of nesting can be used.</span></span>  
  
-   <span data-ttu-id="6b7c7-113">显式嵌套使用显式指示循环嵌套。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-113">Explicit nesting uses an explicit indication that the loop is nested.</span></span> <span data-ttu-id="6b7c7-114">使用显式嵌套时，段标记中的第一个组件数据元素将为段代码。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-114">When explicit nesting is used, the first component data element in the segment tag will be the segment code.</span></span> <span data-ttu-id="6b7c7-115">它将遵循的条件组件数据元素，该值指示的级别和血小板减少症的段的重复。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-115">It will be followed by conditional component data elements indicating both the level and the incidence of repetition of the segment.</span></span> <span data-ttu-id="6b7c7-116">用于此目的的组件数据元素的数目取决于在这段出现在消息结构的层次结构级别。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-116">The number of component data elements used for this purpose depends upon the hierarchical level in which the segment appears in the message structure.</span></span> <span data-ttu-id="6b7c7-117">如果段将出现在级别一，会使用紧跟在段代码的组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-117">If the segment is to appear at level one, the component data element immediately following the segment code will be used.</span></span> <span data-ttu-id="6b7c7-118">如果段将出现在级别二，紧跟在段代码和下一个组件数据元素的组件数据元素将同时使用。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-118">If the segment is to appear at level two, the component data element immediately following the segment code and the next component data element will both be used.</span></span> <span data-ttu-id="6b7c7-119">如果段将出现在级别三，将使用段代码之后的三个组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-119">If the segment is to appear at level three, the three component data elements following the segment code will be used.</span></span> <span data-ttu-id="6b7c7-120">管道不能执行将数据与层次结构比较的结构验证。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-120">Pipelines cannot perform structural verification comparing data to hierarchy.</span></span>  
  
-   <span data-ttu-id="6b7c7-121">在隐式嵌套严格遵循在消息结构中指定的段的顺序。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-121">In Implicit nesting, the order of the segments specified in the message structure is strictly followed.</span></span> <span data-ttu-id="6b7c7-122">段之间的嵌套关系是隐式，处理所需的任何进一步的迹象。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-122">The nesting relationship between the segments is implicitly evident and no further indication is required for processing.</span></span>  
  
## <a name="loops"></a><span data-ttu-id="6b7c7-123">循环</span><span class="sxs-lookup"><span data-stu-id="6b7c7-123">Loops</span></span>  
 <span data-ttu-id="6b7c7-124">一个或多个段可以作为重复**循环**事务内设置。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-124">One or more segment can repeat as a **loop** inside a transaction set.</span></span> <span data-ttu-id="6b7c7-125">有两个不同类型的循环： 未绑定和绑定。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-125">There are two distinct types of loops: unbounded and bounded.</span></span>  
  
### <a name="unbounded-loops"></a><span data-ttu-id="6b7c7-126">未绑定的循环</span><span class="sxs-lookup"><span data-stu-id="6b7c7-126">Unbounded Loops</span></span>  
 <span data-ttu-id="6b7c7-127">未绑定的循环不具有唯一标识段标记的开头和结尾的循环。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-127">An unbounded loop does not have a unique identifying segment to mark the beginning and end of the loop.</span></span> <span data-ttu-id="6b7c7-128">未绑定的循环按照计数进行重复。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-128">An unbounded loop repeats according to a count.</span></span> <span data-ttu-id="6b7c7-129">如果计数没有值，则循环将重复两次。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-129">If the count does not have a value, the loop will repeat twice.</span></span> <span data-ttu-id="6b7c7-130">循环中的每个段可以一次出现在指定的顺序。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-130">Each segment in the loop can occur only once in a specified order.</span></span>  
  
 <span data-ttu-id="6b7c7-131">未绑定循环的开头都是唯一的第一个数据元素即可建立。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-131">The start of an unbounded loop is established by a first data element that is unique.</span></span> <span data-ttu-id="6b7c7-132">第一个元素可以出现一次且只有一次，在每个匹配项。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-132">The first element can appear once and only once in each occurrence.</span></span> <span data-ttu-id="6b7c7-133">未绑定的循环可以嵌套在循环;如果是，内部未绑定的循环不能在与任何外部循环相同的序号位置处开始，并且不能以与任何外部循环相同的段 ID 开头。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-133">Unbounded loops can be nested within loops; if so, the inner unbounded loop cannot start at the same ordinal position as any outer loop and cannot start with the same segment ID as any outer loop.</span></span> <span data-ttu-id="6b7c7-134">嵌套的循环不能包含也是同一嵌套结构中任何外部循环的起始段的段。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-134">The nested loop cannot contain a segment that is also the beginning segment of any outer loop in the same nesting structure.</span></span>  
  
### <a name="bounded-loops"></a><span data-ttu-id="6b7c7-135">绑定的循环</span><span class="sxs-lookup"><span data-stu-id="6b7c7-135">Bounded Loops</span></span>  
 <span data-ttu-id="6b7c7-136">一个绑定的循环预定义的段 LS （循环开始） 开始和结束的预定义的段 LE （循环结束）。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-136">A bounded loop starts with the predefined segment LS (Loop Start) and ends with the predefined segment LE (Loop End).</span></span> <span data-ttu-id="6b7c7-137">LS 段的可选性必须与匹配的循环中的第一个段。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-137">The optionality of the LS segment must match that of the first segment in the loop.</span></span> <span data-ttu-id="6b7c7-138">一个绑定的循环可以包含另一个绑定的循环。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-138">A bounded loop can contain another bounded loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="6b7c7-139">一个绑定的循环在 X12 和 EDIFACT 中的显式循环是等效的。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-139">A bounded loop in X12 and an explicit loop in EDIFACT are equivalent.</span></span>  
  
 <span data-ttu-id="6b7c7-140">在循环中使用绑定来解决二义性。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-140">Binding is used in a loop to resolve ambiguity.</span></span> <span data-ttu-id="6b7c7-141">LS/LE 段上的要求指示符与循环的第一个段的要求指示符相匹配。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-141">The requirement designator on the LS/LE segments matches the requirement designator of the first segment of the loop.</span></span> <span data-ttu-id="6b7c7-142">绑定会放松对某些经常重复段的使用情况结构限制。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-142">Binding loosens structural restrictions imposed on the usage of certain commonly repeating segments.</span></span> <span data-ttu-id="6b7c7-143">绑定的段具有起始段 ID 没有限制。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-143">Bounded segments have no restrictions with respect to the beginning segment ID.</span></span> <span data-ttu-id="6b7c7-144">这使同一段在启动绑定的循环和用于外部循环中，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="6b7c7-144">This enables the same segment to start a bounded loop and be used outside of the loop, as in the following example:</span></span>  
  
```  
AA  
LS  
BB  
CC  
LE  
BB  
```  
  
 <span data-ttu-id="6b7c7-145">允许存在从属循环 （循环内的循环）。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-145">Subordinate loops (loops within loops) are allowed.</span></span> <span data-ttu-id="6b7c7-146">如果绑定的循环循环内进行嵌套，内部循环不能在与任何外部循环相同的序号位置处开始。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-146">If bounded loops are nested within loops, the inner loop cannot start at the same ordinal position as any outer loop.</span></span> <span data-ttu-id="6b7c7-147">内部绑定的循环必须在相邻的外部循环之前结束。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-147">The inner bounded loop must end before the immediate outer loop.</span></span>  
  
 <span data-ttu-id="6b7c7-148">事务集内的每个绑定的循环必须具有唯一定义 < 也 > 值的一至四个大写字母或数字组成。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-148">Each bounded loop within a transaction set must have a uniquely defined <loop_id> value of one to four uppercase letters or numeric digits.</span></span> <span data-ttu-id="6b7c7-149">建议对应的 LS 和 LE 段包含相同的唯一 < 也 > 值。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-149">It is recommended that the corresponding LS and LE segments contain the same unique <loop_id> value.</span></span> <span data-ttu-id="6b7c7-150">< 也 > 数据元素将其作为"常规"数据元素进行处理和验证数据类型、 最小/最大长度、 可选性等。将不执行跨段 （跨越 LS 和 LE） 验证。BizTalk Server 将验证模糊解析通过是否存在 LS 和 LE 段而不是其他。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-150">The <loop_id> data element will be processed as a “regular” data element and validated for data type, min/max length, optionality, etc. Cross-segment validation (across LS and LE) will not be carried out. BizTalk Server will verify ambiguity resolution via the presence of the LS and LE segment and nothing else.</span></span> <span data-ttu-id="6b7c7-151">对于数据元素规则发生冲突，但出现错误，接受的事务集和 BizTalk Server 返回 AK501 = E 和 AK2/AK3 确认中的相应评估</span><span class="sxs-lookup"><span data-stu-id="6b7c7-151">In the case of data-element rule violation, the transaction set is accepted with errors, and BizTalk Server returns AK501=E and the appropriate valuation in AK2/AK3 in the ACK.</span></span>  
  
 <span data-ttu-id="6b7c7-152">它也是所需的 LS/LE 段配对强制执行。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-152">It is also required that pairing of LS/LE segments is enforced.</span></span> <span data-ttu-id="6b7c7-153">如果不匹配的事务集被拒绝由于存在内在的模糊解析问题和 AK501 = E 和 AK502 = 5 会返回到事件查看器和 997 确认。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-153">In case of a mismatch, the transaction set is rejected due to an inherent ambiguity resolution issue, and AK501 = E and AK502 = 5 are returned in the Event Viewer and the 997 ACK.</span></span> <span data-ttu-id="6b7c7-154">事务集在一个或两个 LS/LE 段缺失，但事务集不是不明确，将接受存在错误和 AK501 = E 和 AK502 = 5 返回。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-154">When  either or both LS/LE segments are missing, but the transaction set is not ambiguous, the transaction set will be accepted with errors, and AK501=E and AK502 = 5 returned.</span></span>  
  
 <span data-ttu-id="6b7c7-155">LS/LE 对可以是可选或必需。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-155">An LS/LE pair can be optional or mandatory.</span></span> <span data-ttu-id="6b7c7-156">但是，除非该对包含可重复的父循环中，对可以永远不会是可重复。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-156">However, unless the pair is contained in a parent loop that is repeatable, the pair can never be repeatable.</span></span> <span data-ttu-id="6b7c7-157">在任一情况下，LS/LE 对的 MaxOccurs 可为 1，但不能大于 1，这强制要求在架构验证。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-157">In either case, both MaxOccurs for an LS/LE pair can be 1, but not greater than 1.This is enforced in schema validation.</span></span>  
  
 <span data-ttu-id="6b7c7-158">EDI 拆装器和 EDI 组装器处理 LS 和 LE 段。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-158">The EDI Disassembler and EDI Assembler handle LS and LE segments.</span></span> <span data-ttu-id="6b7c7-159">分析过程中，拆装器创建的 XML 节点的 LS 和 LE 段，并验证段。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-159">During parsing, the Disassembler created XML nodes for the LS and LE segments, and validates the segments.</span></span> <span data-ttu-id="6b7c7-160">在过程中进行序列化，则组装器将创建 LS 和 LE 段从 XML 节点，并对其进行验证。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-160">During serializing, the Assembler creates the LS and LE segments from XML nodes, and validates them.</span></span> <span data-ttu-id="6b7c7-161">如果所需的 LS 或 LE 段缺失，事务集被挂起/拒绝 AK501 = E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-161">If an expected LS or LE segment is missing, the transaction set is suspended/rejected with an AK501 = E and AK502 = 5.</span></span> <span data-ttu-id="6b7c7-162">如果 LS/LE 段存在不带相应数据元素，并且启用 EDI 验证，并出现错误和 AK501 接受的事务集 = E 和 AK502 = 5 会报告在事件查看器和 997 确认。</span><span class="sxs-lookup"><span data-stu-id="6b7c7-162">If LS/LE segments are present without corresponding data element, and EDI validation is enabled, the transaction set is accepted with errors and AK501 = E and AK502 = 5 are reported in the Event Viewer and the 997 ACK.</span></span>