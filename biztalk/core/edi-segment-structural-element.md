---
title: EDI 段结构化元素 |Microsoft 文档
ms.custom: ''
ms.date: 06/08/2017
ms.prod: biztalk-server
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 1f474a3d-004a-4981-b155-b0a5775918ba
caps.latest.revision: 6
author: MandiOhlinger
ms.author: mandia
manager: anneta
ms.openlocfilehash: 5b05d7a793fe515b8d0254d63b9b96994ddb35d9
ms.sourcegitcommit: cb908c540d8f1a692d01dc8f313e16cb4b4e696d
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 09/20/2017
ms.locfileid: "22242213"
---
# <a name="edi-segment-structural-element"></a><span data-ttu-id="30334-102">EDI 段结构化元素</span><span class="sxs-lookup"><span data-stu-id="30334-102">EDI Segment Structural Element</span></span>
<span data-ttu-id="30334-103">段包含一个或多个数据元素，是消息中的中间信息单位。</span><span class="sxs-lookup"><span data-stu-id="30334-103">The segment contains one or more data elements, and is an intermediate unit of information in the message.</span></span> <span data-ttu-id="30334-104">每个段均以一个由三个字符组成的数据段标识符开头，以段终止符（默认情况下为撇号 (')）结尾。</span><span class="sxs-lookup"><span data-stu-id="30334-104">Each segment starts with a three-character data segment identifier, and ends with a segment terminator (by default the apostrophe (')).</span></span> <span data-ttu-id="30334-105">段内的数据元素由数据元素分隔符分隔。</span><span class="sxs-lookup"><span data-stu-id="30334-105">The data elements within the segment are separated by data element separators.</span></span> <span data-ttu-id="30334-106">默认情况下，数据元素分隔符为加号 (+)。</span><span class="sxs-lookup"><span data-stu-id="30334-106">The data element separator is by default the plus sign (+).</span></span> <span data-ttu-id="30334-107">段可分为两类：必需段和可选段。</span><span class="sxs-lookup"><span data-stu-id="30334-107">A segment is classified as Mandatory or Optional.</span></span> <span data-ttu-id="30334-108">传出交换的分隔符可在两贸易合作伙伴间的协议中设置，也可设置为后备贸易合作伙伴协议的一部分。</span><span class="sxs-lookup"><span data-stu-id="30334-108">Separators for outgoing interchanges can be set in the agreements between two trading partners or as part of fallback trading partner agreement.</span></span>  
  
## <a name="nesting"></a><span data-ttu-id="30334-109">嵌套</span><span class="sxs-lookup"><span data-stu-id="30334-109">Nesting</span></span>  
 <span data-ttu-id="30334-110">可能在层次结构关系调用分组段**嵌套**。</span><span class="sxs-lookup"><span data-stu-id="30334-110">Segments may be grouped in a hierarchical relationship called **nesting**.</span></span> <span data-ttu-id="30334-111">有两个不同类型的嵌套： 显式和隐式。</span><span class="sxs-lookup"><span data-stu-id="30334-111">There are two distinct type of nesting: explicit and implicit.</span></span> <span data-ttu-id="30334-112">在任何一个交换内，只能使用一种类型的嵌套。</span><span class="sxs-lookup"><span data-stu-id="30334-112">Within any one interchange only one type of nesting can be used.</span></span>  
  
-   <span data-ttu-id="30334-113">显式嵌套显式指示循环是嵌套的。</span><span class="sxs-lookup"><span data-stu-id="30334-113">Explicit nesting uses an explicit indication that the loop is nested.</span></span> <span data-ttu-id="30334-114">使用显式嵌套时，段标记中的第一个组件数据元素将为段代码。</span><span class="sxs-lookup"><span data-stu-id="30334-114">When explicit nesting is used, the first component data element in the segment tag will be the segment code.</span></span> <span data-ttu-id="30334-115">段代码后将为表示段的级别和重复发生率的条件组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="30334-115">It will be followed by conditional component data elements indicating both the level and the incidence of repetition of the segment.</span></span> <span data-ttu-id="30334-116">用于此目的的组件数据元素的数量由段在消息结构中出现的层级决定。</span><span class="sxs-lookup"><span data-stu-id="30334-116">The number of component data elements used for this purpose depends upon the hierarchical level in which the segment appears in the message structure.</span></span> <span data-ttu-id="30334-117">如果段将出现在级别一，则会使用紧跟在段代码之后的组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="30334-117">If the segment is to appear at level one, the component data element immediately following the segment code will be used.</span></span> <span data-ttu-id="30334-118">如果段将出现在级别二，则会使用紧跟在段代码之后的组件数据元素和下一个组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="30334-118">If the segment is to appear at level two, the component data element immediately following the segment code and the next component data element will both be used.</span></span> <span data-ttu-id="30334-119">如果段将出现在级别三，则会使用段代码之后的三个组件数据元素。</span><span class="sxs-lookup"><span data-stu-id="30334-119">If the segment is to appear at level three, the three component data elements following the segment code will be used.</span></span> <span data-ttu-id="30334-120">管道无法执行将数据与层次结构比较的结构验证。</span><span class="sxs-lookup"><span data-stu-id="30334-120">Pipelines cannot perform structural verification comparing data to hierarchy.</span></span>  
  
-   <span data-ttu-id="30334-121">在隐式嵌套中，将严格遵循在消息结构中指定的段的顺序。</span><span class="sxs-lookup"><span data-stu-id="30334-121">In Implicit nesting, the order of the segments specified in the message structure is strictly followed.</span></span> <span data-ttu-id="30334-122">段之间的嵌套关系是隐式的，处理时不需要进一步的指示。</span><span class="sxs-lookup"><span data-stu-id="30334-122">The nesting relationship between the segments is implicitly evident and no further indication is required for processing.</span></span>  
  
## <a name="loops"></a><span data-ttu-id="30334-123">循环</span><span class="sxs-lookup"><span data-stu-id="30334-123">Loops</span></span>  
 <span data-ttu-id="30334-124">可以作为反复使用一个或多个段**循环**在事务内设置。</span><span class="sxs-lookup"><span data-stu-id="30334-124">One or more segment can repeat as a **loop** inside a transaction set.</span></span> <span data-ttu-id="30334-125">有两种不同类型的循环： 不受限制和受限。</span><span class="sxs-lookup"><span data-stu-id="30334-125">There are two distinct types of loops: unbounded and bounded.</span></span>  
  
### <a name="unbounded-loops"></a><span data-ttu-id="30334-126">未绑定循环</span><span class="sxs-lookup"><span data-stu-id="30334-126">Unbounded Loops</span></span>  
 <span data-ttu-id="30334-127">未绑定循环不具有标记循环的开头和结尾的唯一标识段。</span><span class="sxs-lookup"><span data-stu-id="30334-127">An unbounded loop does not have a unique identifying segment to mark the beginning and end of the loop.</span></span> <span data-ttu-id="30334-128">未绑定循环按照计数进行重复。</span><span class="sxs-lookup"><span data-stu-id="30334-128">An unbounded loop repeats according to a count.</span></span> <span data-ttu-id="30334-129">如果计数没有值，则循环将重复两次。</span><span class="sxs-lookup"><span data-stu-id="30334-129">If the count does not have a value, the loop will repeat twice.</span></span> <span data-ttu-id="30334-130">循环中的每个段只能按指定的顺序出现一次。</span><span class="sxs-lookup"><span data-stu-id="30334-130">Each segment in the loop can occur only once in a specified order.</span></span>  
  
 <span data-ttu-id="30334-131">未绑定循环以唯一的第一个数据元素开头。</span><span class="sxs-lookup"><span data-stu-id="30334-131">The start of an unbounded loop is established by a first data element that is unique.</span></span> <span data-ttu-id="30334-132">在每次出现中，第一个元素可出现一次且仅出现一次。</span><span class="sxs-lookup"><span data-stu-id="30334-132">The first element can appear once and only once in each occurrence.</span></span> <span data-ttu-id="30334-133">未绑定循环可在循环内进行嵌套；如果在循环内进行嵌套，则内部未绑定循环不能在与任何外部循环相同的序号位置处开始，也不能以与任何外部循环相同的段 ID 开头。</span><span class="sxs-lookup"><span data-stu-id="30334-133">Unbounded loops can be nested within loops; if so, the inner unbounded loop cannot start at the same ordinal position as any outer loop and cannot start with the same segment ID as any outer loop.</span></span> <span data-ttu-id="30334-134">嵌套循环包含的段不能同时为同一嵌套结构中任何外部循环的起始段。</span><span class="sxs-lookup"><span data-stu-id="30334-134">The nested loop cannot contain a segment that is also the beginning segment of any outer loop in the same nesting structure.</span></span>  
  
### <a name="bounded-loops"></a><span data-ttu-id="30334-135">绑定循环</span><span class="sxs-lookup"><span data-stu-id="30334-135">Bounded Loops</span></span>  
 <span data-ttu-id="30334-136">绑定循环以预定义的段 LS（循环开头）开头，以预定义的段 LE（循环结束）结束。</span><span class="sxs-lookup"><span data-stu-id="30334-136">A bounded loop starts with the predefined segment LS (Loop Start) and ends with the predefined segment LE (Loop End).</span></span> <span data-ttu-id="30334-137">LS 段的可选性必须与循环中第一个段的可选性匹配。</span><span class="sxs-lookup"><span data-stu-id="30334-137">The optionality of the LS segment must match that of the first segment in the loop.</span></span> <span data-ttu-id="30334-138">一个绑定循环可以包含另一个绑定循环。</span><span class="sxs-lookup"><span data-stu-id="30334-138">A bounded loop can contain another bounded loop.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="30334-139">X12 中的绑定循环与 EDIFACT 中的显式循环等价。</span><span class="sxs-lookup"><span data-stu-id="30334-139">A bounded loop in X12 and an explicit loop in EDIFACT are equivalent.</span></span>  
  
 <span data-ttu-id="30334-140">在循环中使用绑定是为了解决不明确的问题。</span><span class="sxs-lookup"><span data-stu-id="30334-140">Binding is used in a loop to resolve ambiguity.</span></span> <span data-ttu-id="30334-141">LS/LE 段上的要求指示符与循环的第一个段的要求指示符相匹配。</span><span class="sxs-lookup"><span data-stu-id="30334-141">The requirement designator on the LS/LE segments matches the requirement designator of the first segment of the loop.</span></span> <span data-ttu-id="30334-142">绑定会放松对某些经常重复段的用法的结构限制。</span><span class="sxs-lookup"><span data-stu-id="30334-142">Binding loosens structural restrictions imposed on the usage of certain commonly repeating segments.</span></span> <span data-ttu-id="30334-143">绑定段对起始段 ID 没有限制。</span><span class="sxs-lookup"><span data-stu-id="30334-143">Bounded segments have no restrictions with respect to the beginning segment ID.</span></span> <span data-ttu-id="30334-144">这样可使同一段在作为一个绑定循环的开头的同时在该循环之外使用，如下例所示：</span><span class="sxs-lookup"><span data-stu-id="30334-144">This enables the same segment to start a bounded loop and be used outside of the loop, as in the following example:</span></span>  
  
```  
AA  
LS  
BB  
CC  
LE  
BB  
```  
  
 <span data-ttu-id="30334-145">允许存在从属循环（循环内的循环）。</span><span class="sxs-lookup"><span data-stu-id="30334-145">Subordinate loops (loops within loops) are allowed.</span></span> <span data-ttu-id="30334-146">如果绑定循环在循环内进行嵌套，则内部循环不能在与任何外部循环相同的序号位置处开始。</span><span class="sxs-lookup"><span data-stu-id="30334-146">If bounded loops are nested within loops, the inner loop cannot start at the same ordinal position as any outer loop.</span></span> <span data-ttu-id="30334-147">内部绑定循环必须在与之相邻的外部循环之前结束。</span><span class="sxs-lookup"><span data-stu-id="30334-147">The inner bounded loop must end before the immediate outer loop.</span></span>  
  
 <span data-ttu-id="30334-148">每个事务集内的界限的循环必须具有唯一定义 < loop_id > 值为一至四个大写首字母或数字。</span><span class="sxs-lookup"><span data-stu-id="30334-148">Each bounded loop within a transaction set must have a uniquely defined <loop_id> value of one to four uppercase letters or numeric digits.</span></span> <span data-ttu-id="30334-149">建议的相应 LS 和 LE 段包含相同的唯一 < loop_id > 值。</span><span class="sxs-lookup"><span data-stu-id="30334-149">It is recommended that the corresponding LS and LE segments contain the same unique <loop_id> value.</span></span> <span data-ttu-id="30334-150">将"常规"数据元素作为处理和验证的数据类型、 最小/最大长度、 可选性等 < loop_id > 数据元素。跨段 （在 LS 和 LE） 将不会执行验证。BizTalk Server 将通过存在且仅存在 LS 和 LE 段来验证模糊解析。</span><span class="sxs-lookup"><span data-stu-id="30334-150">The <loop_id> data element will be processed as a “regular” data element and validated for data type, min/max length, optionality, etc. Cross-segment validation (across LS and LE) will not be carried out. BizTalk Server will verify ambiguity resolution via the presence of the LS and LE segment and nothing else.</span></span> <span data-ttu-id="30334-151">在数据元素规则发生冲突的情况下，将接受存在错误的事务集，且 BizTalk Server 在确认中返回 AK501=E 和 AK2/AK3 的相应评估。</span><span class="sxs-lookup"><span data-stu-id="30334-151">In the case of data-element rule violation, the transaction set is accepted with errors, and BizTalk Server returns AK501=E and the appropriate valuation in AK2/AK3 in the ACK.</span></span>  
  
 <span data-ttu-id="30334-152">还要求强制 LS/LE 段配对。</span><span class="sxs-lookup"><span data-stu-id="30334-152">It is also required that pairing of LS/LE segments is enforced.</span></span> <span data-ttu-id="30334-153">在不匹配的情况下，由于存在内在的模糊解析问题而拒绝事务集，且在事件查看器和 997 确认中返回 AK501 = E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="30334-153">In case of a mismatch, the transaction set is rejected due to an inherent ambiguity resolution issue, and AK501 = E and AK502 = 5 are returned in the Event Viewer and the 997 ACK.</span></span> <span data-ttu-id="30334-154">如果缺少 LS/LE 段之一或两者，而事务集是明确的，将接受存在错误的事务集并返回 AK501=E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="30334-154">When  either or both LS/LE segments are missing, but the transaction set is not ambiguous, the transaction set will be accepted with errors, and AK501=E and AK502 = 5 returned.</span></span>  
  
 <span data-ttu-id="30334-155">LS/LE 对可以是可选的，也可以是必需的。</span><span class="sxs-lookup"><span data-stu-id="30334-155">An LS/LE pair can be optional or mandatory.</span></span> <span data-ttu-id="30334-156">但是，除非该对包含在可重复的父循环中，否则该对永不会是可重复的。</span><span class="sxs-lookup"><span data-stu-id="30334-156">However, unless the pair is contained in a parent loop that is repeatable, the pair can never be repeatable.</span></span> <span data-ttu-id="30334-157">在任一种情况下，LS/LE 对的 MaxOccurs 可为 1，但不能大于 1。在架构验证中，这是强制要求。</span><span class="sxs-lookup"><span data-stu-id="30334-157">In either case, both MaxOccurs for an LS/LE pair can be 1, but not greater than 1.This is enforced in schema validation.</span></span>  
  
 <span data-ttu-id="30334-158">EDI 拆装器和 EDI 组装器处理 LS 和 LE 段。</span><span class="sxs-lookup"><span data-stu-id="30334-158">The EDI Disassembler and EDI Assembler handle LS and LE segments.</span></span> <span data-ttu-id="30334-159">在解析过程中，拆装器为 LS 和 LE 段创建 XML 节点，并验证这两个段。</span><span class="sxs-lookup"><span data-stu-id="30334-159">During parsing, the Disassembler created XML nodes for the LS and LE segments, and validates the segments.</span></span> <span data-ttu-id="30334-160">在序列化过程中，组装器从 XML 节点创建 LS 和 LE 段，并验证这两个段。</span><span class="sxs-lookup"><span data-stu-id="30334-160">During serializing, the Assembler creates the LS and LE segments from XML nodes, and validates them.</span></span> <span data-ttu-id="30334-161">如果预期 LS 或 LE 段是缺少，事务集是与 AK501 挂起/拒绝 = E 和 AK502 = 5。</span><span class="sxs-lookup"><span data-stu-id="30334-161">If an expected LS or LE segment is missing, the transaction set is suspended/rejected with an AK501 = E and AK502 = 5.</span></span> <span data-ttu-id="30334-162">如果 LS/LE 段有不带相应数据元素，并且启用 EDI 验证，但出现错误和 AK501 接受事务集 = E 和 AK502 = 5 报告在事件查看器和 997 确认</span><span class="sxs-lookup"><span data-stu-id="30334-162">If LS/LE segments are present without corresponding data element, and EDI validation is enabled, the transaction set is accepted with errors and AK501 = E and AK502 = 5 are reported in the Event Viewer and the 997 ACK.</span></span>